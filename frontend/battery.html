<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>AGV 电量曲线（WebSocket + Chart.js）</title>
    <style>
      body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 0; background: #0f172a; color: #eaeaea; }
      header { padding: 12px 16px; border-bottom: 1px solid #1f2937; display: flex; gap: 12px; align-items: center; flex-wrap: wrap; }
      header h1 { font-size: 16px; margin: 0 12px 0 0; color: #93c5fd; font-weight: 600; }
      .ctrl { display: inline-flex; gap: 8px; align-items: center; }
      .ctrl label { color: #cbd5e1; }
      select { background: #0b1220; color: #eaeaea; border: 1px solid #334155; padding: 6px 8px; border-radius: 6px; }
      main { padding: 16px; }
      .card { background: #0b1220; border: 1px solid #1f2937; border-radius: 8px; padding: 12px; max-width: 1700px; margin: 0 auto; }
      .status { margin-left: auto; color: #9ca3af; font-size: 12px; }
      /* 调整绘图区域：x轴显示区域增加20%（宽度上限从1200→1440），y轴显示区域缩小10%（高度从380→342），并居中显示 */
      canvas { width: 100%; max-width: 1440px; height: 380px; display: block; margin: 0 auto; }
    </style>
    <!-- Chart.js CDN -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
  </head>
  <body>
    <header>
      <h1>AGV 电量曲线</h1>
      <div class="ctrl">
        <label for="robot">机器人</label>
        <select id="robot"></select>
      </div>
      <div class="ctrl">
        <label for="interval">观察间隔</label>
        <select id="interval">
          <option value="1">1s</option>
          <option value="10">10s</option>
          <option value="30">30s</option>
          <option value="60">60s</option>
          <option value="120">120s</option>
        </select>
      </div>
      <div id="wsStatus" class="status">WS: 连接中...</div>
    </header>
    <main>
      <div class="card">
        <canvas id="chart"></canvas>
      </div>
    </main>

    <script>
      // 工具：统一读取 snake/camel 键
      function pick(obj, snake, camel, def) {
        if (!obj || typeof obj !== 'object') return def;
        if (snake in obj) return obj[snake];
        if (camel in obj) return obj[camel];
        return def;
      }

      // 机器人选择与观察间隔
      const robotSel = document.getElementById('robot');
      const intervalSel = document.getElementById('interval');
      const wsStatus = document.getElementById('wsStatus');

      let selectedRobot = '';
      let seenRobots = new Set();
      let aggIntervalSec = Number(intervalSel.value || 10);

      // 聚合器：仅保留时间与平均电量，不保存原始 state
      const startTs = Date.now();
      let currentBin = null; // bin index: floor(seconds / aggIntervalSec)
      let currentSum = 0;
      let currentCount = 0;
      // 图表数据只保留聚合点
      const dataPoints = []; // {x: seconds since start, y: avg battery}
      const MAX_POINTS = 1000;

      const chart = new Chart(document.getElementById('chart'), {
        type: 'line',
        data: {
          datasets: [{
            label: 'Battery %',
            data: dataPoints,
            borderColor: '#4a90e2',
            backgroundColor: 'rgba(74, 144, 226, 0.15)',
            tension: 0.2,
            pointRadius: 0,
            borderWidth: 2,
          }],
        },
        options: {
          responsive: true,
          animation: false,
          plugins: {
            legend: { display: true },
            tooltip: { enabled: true },
          },
          scales: {
            x: {
              type: 'linear',
              title: { display: true, text: 'Time (s)' },
              ticks: { color: '#cbd5e1' },
              grid: { color: 'rgba(148,163,184,0.1)' },
            },
            y: {
              min: 0,
              max: 100,
              title: { display: true, text: 'Battery (%)' },
              ticks: { color: '#cbd5e1' },
              grid: { color: 'rgba(148,163,184,0.1)' },
            },
          },
        },
      });

      function resetAggregator() {
        currentBin = null;
        currentSum = 0;
        currentCount = 0;
        dataPoints.length = 0;
        chart.update('none');
      }

      function pushAvgPoint(binIndex, avg) {
        const xSec = binIndex * aggIntervalSec + aggIntervalSec / 2; // bin 中点
        dataPoints.push({ x: xSec, y: avg });
        if (dataPoints.length > MAX_POINTS) dataPoints.shift();
      }

      function updateAvgPoint(avg) {
      if (dataPoints.length === 0) return;
        dataPoints[dataPoints.length - 1].y = avg;
      }

      function addBatterySample(value) {
        const nowSec = (Date.now() - startTs) / 1000;
        const bin = Math.floor(nowSec / aggIntervalSec);
        const v = Number(value);
        if (!Number.isFinite(v)) return;
        const vv = Math.max(0, Math.min(100, v));
        if (currentBin === null) {
          currentBin = bin;
          currentSum = vv;
          currentCount = 1;
          pushAvgPoint(currentBin, vv);
          chart.update('none');
          return;
        }
        if (bin === currentBin) {
          currentSum += vv;
          currentCount += 1;
          const avg = currentSum / currentCount;
          updateAvgPoint(avg);
          chart.update('none');
          return;
        }
        // 进入新 bin：先用上一个 bin 的平均值结束，再开始新 bin
        const prevAvg = currentSum / Math.max(1, currentCount);
        // 最后一点已代表 prevAvg，无需重复 push；开始新 bin
        currentBin = bin;
        currentSum = vv;
        currentCount = 1;
        pushAvgPoint(currentBin, vv);
        chart.update('none');
      }

      // 加载已注册 AGV 列表以便选择
      async function initAgvList() {
        try {
          const resp = await fetch('/api/agvs');
          if (!resp.ok) return;
          const list = await resp.json();
          const serials = (Array.isArray(list) ? list : []).map(x => String(x.serial_number || ''))
            .filter(s => !!s);
          for (const s of serials) {
            if (!seenRobots.has(s)) {
              const opt = document.createElement('option');
              opt.value = s; opt.textContent = s;
              robotSel.appendChild(opt);
              seenRobots.add(s);
            }
          }
          if (!selectedRobot && serials.length > 0) {
            selectedRobot = serials[0];
            robotSel.value = selectedRobot;
          }
        } catch (_) { /* 忽略 */ }
      }

      // WebSocket 连接与消息处理
      let ws = null;
      function initWS() {
        try {
          const url = (location.protocol === 'https:' ? 'wss' : 'ws') + '://' + location.host + '/ws';
          ws = new WebSocket(url);
          ws.onopen = () => { wsStatus.textContent = 'WS: 已连接'; };
          ws.onclose = () => { wsStatus.textContent = 'WS: 断开，重连中...'; setTimeout(initWS, 1000); };
          ws.onerror = () => { try { ws.close(); } catch (_) {} };
          ws.onmessage = (ev) => {
            try {
              const msg = JSON.parse(ev.data);
              if (!msg || msg.type !== 'mqtt_state' || !msg.payload) return;
              const p = msg.payload;
              const serial = String(p.serial_number || p.serialNumber || '').trim();
              if (serial) {
                if (!seenRobots.has(serial)) {
                  const opt = document.createElement('option');
                  opt.value = serial; opt.textContent = serial;
                  robotSel.appendChild(opt);
                  seenRobots.add(serial);
                  if (!selectedRobot) { selectedRobot = serial; robotSel.value = serial; }
                }
              }
              if (!selectedRobot || (serial && serial !== selectedRobot)) return; // 仅处理选中机器人
              const bs = pick(p, 'battery_state', 'batteryState', {}) || {};
              const v = pick(bs, 'battery_charge', 'batteryCharge', null);
              if (v === null || typeof v === 'undefined') return;
              addBatterySample(Number(v));
            } catch (_) { /* 忽略单次错误 */ }
          };
        } catch (err) {
          wsStatus.textContent = 'WS: 连接失败';
        }
      }

      robotSel.addEventListener('change', () => {
        selectedRobot = String(robotSel.value || '').trim();
        resetAggregator();
      });

      intervalSel.addEventListener('change', () => {
        const v = Number(intervalSel.value || 10);
        aggIntervalSec = Math.max(1, Math.min(120, v));
        resetAggregator();
      });

      // 初始化
      initAgvList();
      initWS();
    </script>
  </body>
</html>