// See inline references in index.html; this file contains the main UI logic.
// Keeping the same global API as before to avoid breaking changes.

(function () { let _statusRafId = null; function _stopStatusAutoScroll() { try { if (_statusRafId) cancelAnimationFrame(_statusRafId); } catch (e) { } _statusRafId = null; } function startStatusAutoScroll() { const el = document.getElementById('status'); if (!el) return; _stopStatusAutoScroll(); const max = el.scrollWidth - el.clientWidth; if (max <= 0) return; let pos = el.scrollLeft || 0; let dir = 1; const step = 1; function tick() { const node = document.getElementById('status'); if (!node) return; pos += dir * step; if (pos >= max) { pos = max; dir = -1; } else if (pos <= 0) { pos = 0; dir = 1; } node.scrollLeft = pos; _statusRafId = requestAnimationFrame(tick); } _statusRafId = requestAnimationFrame(tick); } function setStatusMessage(msg) { try { const el = document.getElementById('status'); if (el) { el.textContent = String(msg); setTimeout(startStatusAutoScroll, 0); } } catch (e) { } } window.printErrorToStatus = function (err, context) { const msg = (err && err.message) ? err.message : String(err); const prefix = context ? '[' + String(context) + '] ' : ''; setStatusMessage(prefix + msg); }; const originalFetch = window.fetch; window.fetch = async function (input, init) { const url = (typeof input === 'string') ? input : (input && input.url ? input.url : ''); const method = (init && init.method) || (typeof input === 'object' && input && input.method) || 'GET'; try { const res = await originalFetch(input, init); if (!res.ok) { let detail = ''; try { const txt = await res.clone().text(); try { const obj = JSON.parse(txt); detail = obj && (obj.detail || obj.message) ? (obj.detail || obj.message) : txt; } catch (_) { detail = txt; } } catch (_) { detail = res.statusText || '未知错误'; } setStatusMessage(`错误 ${res.status} ${method} ${url}: ${String(detail).trim()}`); } return res; } catch (err) { setStatusMessage(`网络错误 ${method} ${url}: ${err && err.message ? err.message : String(err)}`); throw err; } }; window.addEventListener('unhandledrejection', function (ev) { const reason = ev && ev.reason ? (ev.reason.message || String(ev.reason)) : '未知异常'; setStatusMessage(`未捕获错误: ${reason}`); }); window.addEventListener('error', function (ev) { setStatusMessage(`脚本错误: ${ev.message} @ ${ev.filename}:${ev.lineno}`); }); try { setTimeout(startStatusAutoScroll, 0); } catch (_) { } })();

const API_BASE_URL = window.location.origin + '/api';
window.FRONTEND_POLL_INTERVAL_MS = 1000;
window.CENTER_FORWARD_OFFSET_M = 0.1;
async function loadFrontendConfig() { try { const resp = await fetch(`${API_BASE_URL}/config`); if (resp && resp.ok) { const data = await resp.json(); const v = Number(data && data.polling_interval_ms); if (isFinite(v) && v > 0) { window.FRONTEND_POLL_INTERVAL_MS = v; } const off = Number(data && (data.center_forward_offset_m ?? data.centerForwardOffsetM)); if (isFinite(off)) { window.CENTER_FORWARD_OFFSET_M = Math.max(0, Math.min(5, off)); } } } catch (_) { } }

const CURRENT_MAP_ID = 'ViewerMap/testmap.scene';
const POINT_TYPE_INFO = { 1: { label: '普通点', color: '#f39c12' }, 2: { label: '等待点', color: '#2980b9' }, 3: { label: '避让点', color: '#8e44ad' }, 4: { label: '临时避让点', color: '#9b59b6' }, 5: { label: '库区点', color: '#16a085' }, 7: { label: '不可避让点', color: '#c0392b' }, 11: { label: '电梯点', color: '#e91e63' }, 12: { label: '自动门点', color: '#00bcd4' }, 13: { label: '充电点', color: '#4caf50' }, 14: { label: '停靠点', color: '#7f8c8d' }, 15: { label: '动作点', color: '#e74c3c' }, 16: { label: '禁行点', color: '#ff3860' } };
const PASS_TYPE_INFO = { 0: { label: '普通路段', color: '#3498db' }, 1: { label: '仅空载可通行', color: '#f1c40f' }, 2: { label: '仅载货可通行', color: '#e67e22' }, 10: { label: '禁行路段', color: '#e74c3c' } };

let canvas, ctx, mapData = null; let viewTransform = { x: 0, y: 0, scale: 1 }; let isDragging = false; let lastMousePos = { x: 0, y: 0 }; let showGrid = true; let sidebarOpen = false; let registeredRobots = []; let ws = null; let selectedRobotId = null; let selectedStationId = null; let selectedRouteId = null; let selectedNavStation = null; let lastRouteCandidates = []; let lastRouteCandidateIndex = 0; let mapLayers = []; let floorNames = []; let currentFloorIndex = 0;

window.onload = function () { initCanvas(); loadMapData(); setupEventListeners(); updateRegisterMapOptions(); Promise.all([loadFrontendConfig(), loadRobotList(), loadEquipmentList()]).catch(() => { }); initWebSocket(); startRenderLoop(); setupKeyboardControl(); startCommStatusGuard(); };

function initCanvas() { canvas = document.getElementById('mapCanvas'); ctx = canvas.getContext('2d'); resizeCanvas(); window.addEventListener('resize', resizeCanvas); } function resizeCanvas() { const c = document.querySelector('.canvas-container'); canvas.width = c.clientWidth; canvas.height = c.clientHeight; if (mapData) { drawMap(); } }
function setupEventListeners() { canvas.addEventListener('mousedown', onMouseDown); canvas.addEventListener('mousemove', onMouseMove); canvas.addEventListener('mouseup', onMouseUp); canvas.addEventListener('wheel', onWheel); canvas.addEventListener('contextmenu', e => e.preventDefault()); document.addEventListener('click', (ev) => { const robotMenu = document.getElementById('robotContextMenu'); const stationMenu = document.getElementById('stationContextMenu'); const tgt = ev.target; if (robotMenu && robotMenu.style.display === 'block' && !robotMenu.contains(tgt)) { hideRobotContextMenu(); } if (stationMenu && stationMenu.style.display === 'block' && !stationMenu.contains(tgt)) { hideStationContextMenu(); } }); const regMapSel = document.getElementById('registerMapSelect'); if (regMapSel) { regMapSel.addEventListener('change', () => { const lbl = document.getElementById('registerMapSelectedLabel'); if (lbl) lbl.textContent = regMapSel.value || '未设置'; updateRegisterInitialPositionOptions(); }); } }

async function onMouseDown(e) { const p = getMousePos(e); if (e.button === 2) { const robot = findRobotAtScreenPoint(p.x, p.y); if (robot) { selectedRobotId = robot.robot_name; showRobotContextMenu(p.x, p.y, robot); } else { const hitPoint = findPointAtScreenPos(p.x, p.y); if (hitPoint) { showStationContextMenu(p.x, p.y, hitPoint); } else { hideRobotContextMenu(); hideStationContextMenu(); } } return; } const hitPoint = findPointAtScreenPos(p.x, p.y); if (hitPoint) { selectedStationId = hitPoint.id; const info = getStationDetails(hitPoint); updateStationInfoPanel(info); selectedRouteId = null; lastRouteCandidates = []; lastRouteCandidateIndex = 0; updateRouteInfoPanel(null); drawMap(); hideRobotContextMenu(); return; } const routeCandidates = findRoutesAtScreenPos(p.x, p.y); if (routeCandidates.length > 0) { const candidateIds = routeCandidates.map(rt => String(rt.id ?? (`${rt.from}->${rt.to}`))); const sameSet = (lastRouteCandidates.length === candidateIds.length) && lastRouteCandidates.every((id, idx) => id === candidateIds[idx]); if (!sameSet) { lastRouteCandidates = candidateIds; lastRouteCandidateIndex = 0; } else { lastRouteCandidateIndex = (lastRouteCandidateIndex + 1) % lastRouteCandidates.length; } const targetRoute = routeCandidates[lastRouteCandidateIndex]; selectedRouteId = lastRouteCandidates[lastRouteCandidateIndex]; const rinfo = getRouteDetails(targetRoute); updateRouteInfoPanel(rinfo); selectedStationId = null; updateStationInfoPanel(null); drawMap(); hideRobotContextMenu(); return; } isDragging = true; lastMousePos = p; canvas.style.cursor = 'grabbing'; const mi = document.getElementById('mapInfoSection'); if (mi) mi.style.display = 'block'; const rh = document.getElementById('routeHeader'); if (rh) rh.style.display = 'none'; const sh = document.getElementById('stationHeader'); if (sh) sh.style.display = 'none'; const rd = document.getElementById('routeDetails'); if (rd) rd.style.display = 'none'; const sd = document.getElementById('stationDetails'); if (sd) sd.style.display = 'none'; hideRobotContextMenu(); hideStationContextMenu(); }
function onMouseMove(e) { const p = getMousePos(e); const wp = screenToWorld(p.x, p.y); document.getElementById('mousePos').textContent = `${wp.x.toFixed(2)}, ${wp.y.toFixed(2)}`; if (isDragging) { viewTransform.x += p.x - lastMousePos.x; viewTransform.y += p.y - lastMousePos.y; drawMap(); lastMousePos = p; } } function onMouseUp() { isDragging = false; canvas.style.cursor = 'grab'; }
function onWheel(e) { e.preventDefault(); const p = getMousePos(e); const wp = screenToWorld(p.x, p.y); const sf = e.deltaY > 0 ? 0.9 : 1.1; const ns = Math.max(0.1, Math.min(5, viewTransform.scale * sf)); if (ns !== viewTransform.scale) { viewTransform.scale = ns; const nwp = screenToWorld(p.x, p.y); viewTransform.x += (wp.x - nwp.x) * viewTransform.scale; viewTransform.y += (wp.y - nwp.y) * viewTransform.scale; updateZoomDisplay(); drawMap(); } }
function getMousePos(e) { const r = canvas.getBoundingClientRect(); return { x: e.clientX - r.left, y: e.clientY - r.top }; }
function screenToWorld(sx, sy) { return { x: (sx - viewTransform.x) / viewTransform.scale / 20, y: -((sy - viewTransform.y) / viewTransform.scale / 20) }; } function worldToScreen(wx, wy) { return { x: (wx * 20) * viewTransform.scale + viewTransform.x, y: (-wy * 20) * viewTransform.scale + viewTransform.y }; }

function deriveClassFromName(name) { if (!name) return 'Station'; if (/^CP/i.test(name)) return 'CP'; if (/^DP/i.test(name)) return 'DP'; if (/^WP/i.test(name)) return 'WP'; if (/^Pallet/i.test(name)) return 'Pallet'; return 'Station'; }
function pointDrawSize() { const base = 3; const s = Math.max(4, Math.min(24, base * viewTransform.scale)); return s; }

function findPointAtScreenPos(sx, sy) { if (!mapData || !mapData.points) return null; const radius = pointDrawSize() + 2; const currentFloorName = floorNames[currentFloorIndex] || null; for (const p of mapData.points) { const pfloor = extractFloorNameFromLayer(p.layer || ''); if (currentFloorName && pfloor && String(pfloor).trim().toLowerCase() !== String(currentFloorName).trim().toLowerCase()) continue; const sp = worldToScreen(p.x, p.y); const dx = sx - sp.x, dy = sy - sp.y; if (dx * dx + dy * dy <= radius * radius) { return { id: String(p.id || p.name || `${p.x},${p.y}`), name: p.name || p.id || '未知', type: p.type, properties: (Array.isArray(p.properties) ? p.properties : (Array.isArray(p.property) ? p.property : [])), associatedStorageLocations: (Array.isArray(p.associatedStorageLocations) ? p.associatedStorageLocations : []), layer: p.layer || '', pos: { x: p.x, y: p.y }, dir: p.dir || 0 }; } } return null; }

async function loadSceneStations() { }
function getStationDetails(pt) { const id = String(pt.id || pt.name || ''); const name = String(pt.name || pt.id || ''); const typeCode = (pt.type !== undefined) ? Number(pt.type) : NaN; const className = (POINT_TYPE_INFO[typeCode]?.label) || '未知类型'; const dir = (typeof pt.dir === 'number') ? pt.dir : undefined; const ignoreDir = false; let spin = false; const props = Array.isArray(pt.properties) ? pt.properties : (Array.isArray(pt.property) ? pt.property : []); for (const prop of props) { if (prop && prop.key === 'spin' && prop.boolValue === true) { spin = true; break; } } const stor = Array.isArray(pt.associatedStorageLocations) ? pt.associatedStorageLocations : []; return { id, className, instanceName: name, pos: pt.pos, dir, ignoreDir, spin, associatedStorageLocations: stor }; }
function updateStationInfoPanel(info) { if (!info) { document.getElementById('stId').textContent = '-'; document.getElementById('stType').textContent = '-'; document.getElementById('stName').textContent = '-'; document.getElementById('stPos').textContent = '-'; document.getElementById('stDir').textContent = '-'; document.getElementById('stSpin').textContent = '-'; document.getElementById('stStorage').textContent = '-'; const sr = document.getElementById('stStorageRow'); if (sr) sr.style.display = 'none'; const sdr = document.getElementById('stStorageDetailsRow'); if (sdr) sdr.style.display = 'none'; const sdt = document.getElementById('stStorageDetails'); if (sdt) sdt.textContent = '-'; const sd = document.getElementById('stationDetails'); if (sd) sd.style.display = 'none'; const sh = document.getElementById('stationHeader'); if (sh) sh.style.display = 'none'; return; } document.getElementById('stId').textContent = info.id || '-'; document.getElementById('stType').textContent = info.className || '-'; document.getElementById('stName').textContent = info.instanceName || '-'; const posStr = info.pos ? `(${Number(info.pos.x).toFixed(2)}, ${Number(info.pos.y).toFixed(2)})` : '-'; document.getElementById('stPos').textContent = posStr; const orientationText = (info.ignoreDir === true) ? '任意' : (typeof info.dir === 'number' ? `${Number(info.dir * 180 / Math.PI).toFixed(2)}°` : '-'); document.getElementById('stDir').textContent = orientationText; document.getElementById('stSpin').textContent = (info.spin === true) ? 'true' : 'false'; const bin = lookupBinLocationInfo(info.instanceName || info.id); const storNames = Array.isArray(bin?.locationNames) ? bin.locationNames : []; const hasDetails = renderBinTaskDetails(bin); const sr = document.getElementById('stStorageRow'); const sdr = document.getElementById('stStorageDetailsRow'); if (sr) sr.style.display = (storNames.length > 0) ? 'block' : 'none'; if (sdr) sdr.style.display = hasDetails ? 'block' : 'none'; const storEl = document.getElementById('stStorage'); if (storEl) storEl.textContent = (storNames.length > 0) ? storNames.join(', ') : '-'; const sdt = document.getElementById('stStorageDetails'); if (sdt) sdt.style.display = hasDetails ? 'block' : 'none'; const sd = document.getElementById('stationDetails'); if (sd) sd.style.display = 'block'; const sh = document.getElementById('stationHeader'); if (sh) sh.style.display = 'block'; const rh = document.getElementById('routeHeader'); if (rh) rh.style.display = 'none'; const rd = document.getElementById('routeDetails'); if (rd) rd.style.display = 'none'; const mi = document.getElementById('mapInfoSection'); if (mi) mi.style.display = 'none'; }
function getRoutePassLabel(passCode) { const code = Number(passCode); const info = Object.prototype.hasOwnProperty.call(PASS_TYPE_INFO, code) ? PASS_TYPE_INFO[code] : PASS_TYPE_INFO[0]; return info.label; } function getRouteColorByPass(passCode) { const code = Number(passCode); const info = Object.prototype.hasOwnProperty.call(PASS_TYPE_INFO, code) ? PASS_TYPE_INFO[code] : PASS_TYPE_INFO[0]; return info.color; }
function getRouteDetails(route) { if (!route) return null; const id = String(route.id ?? (`${route.from}->${route.to}`)); const desc = String(route.desc || route.name || '-'); const type = String(route.type || '-'); const pass = (route.pass !== undefined) ? Number(route.pass) : 0; return { id, desc, type, passLabel: getRoutePassLabel(pass), passCode: pass }; }
function updateRouteInfoPanel(info) { const panel = document.getElementById('routeDetails'); if (!panel) return; if (!info) { document.getElementById('rtId').textContent = '-'; document.getElementById('rtDesc').textContent = '-'; document.getElementById('rtType').textContent = '-'; document.getElementById('rtPass').textContent = '-'; panel.style.display = 'none'; const rh = document.getElementById('routeHeader'); if (rh) rh.style.display = 'none'; return; } document.getElementById('rtId').textContent = info.id || '-'; document.getElementById('rtDesc').textContent = info.desc || '-'; document.getElementById('rtType').textContent = info.type || '-'; document.getElementById('rtPass').textContent = info.passLabel || '-'; panel.style.display = 'block'; const rh = document.getElementById('routeHeader'); if (rh) rh.style.display = 'block'; const sd = document.getElementById('stationDetails'); if (sd) sd.style.display = 'none'; const sh = document.getElementById('stationHeader'); if (sh) sh.style.display = 'none'; const mi = document.getElementById('mapInfoSection'); if (mi) mi.style.display = 'none'; }
function pointToSegmentDistance(px, py, x1, y1, x2, y2) { const dx = x2 - x1, dy = y2 - y1; if (dx === 0 && dy === 0) return Math.hypot(px - x1, py - y1); const t = ((px - x1) * dx + (py - y1) * dy) / (dx * dx + dy * dy); const tt = Math.max(0, Math.min(1, t)); const cx = x1 + tt * dx, cy = y1 + tt * dy; return Math.hypot(px - cx, py - cy); }
function findRoutesAtScreenPos(sx, sy) { if (!mapData || !Array.isArray(mapData.routes)) return []; const pmap = {}; (mapData.points || []).forEach(p => { pmap[p.id] = p; }); const threshold = Math.max(6, 8 * (viewTransform.scale)); const candidates = []; for (let i = (mapData.routes.length - 1); i >= 0; i--) { const route = mapData.routes[i]; const fp = pmap[route.from], tp = pmap[route.to]; if (!fp || !tp) continue; if (route.type === 'bezier3' && route.c1 && route.c2) { const N = 24; let minD = Infinity; let prev = worldToScreen(fp.x, fp.y); for (let j = 1; j <= N; j++) { const t = j / N; const bt = bezierPoint({ x: fp.x, y: fp.y }, { x: route.c1.x, y: route.c1.y }, { x: route.c2.x, y: route.c2.y }, { x: tp.x, y: tp.y }, t); const cur = worldToScreen(bt.x, bt.y); const d = pointToSegmentDistance(sx, sy, prev.x, prev.y, cur.x, cur.y); if (d < minD) minD = d; prev = cur; } if (minD <= threshold) candidates.push(route); } else { const s1 = worldToScreen(fp.x, fp.y); const s2 = worldToScreen(tp.x, tp.y); const d = pointToSegmentDistance(sx, sy, s1.x, s1.y, s2.x, s2.y); if (d <= threshold) candidates.push(route); } } return candidates; }
function findRobotAtScreenPoint(sx, sy) { for (const robot of registeredRobots) { if (robot.currentMap) { const robotFloor = extractFloorFromMapId(robot.currentMap); const currentFloorName = floorNames[currentFloorIndex] || null; if (robotFloor && currentFloorName && robotFloor !== currentFloorName) continue; } const pos = robot.currentPosition || robot.initialPosition || null; if (!pos) continue; const sp = worldToScreen(pos.x, pos.y); const dx = sx - sp.x; const dy = sy - sp.y; const ang = (pos.theta ?? pos.orientation ?? 0); const cosA = Math.cos(ang + Math.PI / 2), sinA = Math.sin(ang + Math.PI / 2); const lx = dx * cosA - dy * sinA; const ly = dx * sinA + dy * cosA; const s = Math.max(0.5, Math.min(2, viewTransform.scale)); const half = 12 * s; if (lx >= -half && lx <= half && ly >= -half && ly <= half) { return robot; } } return null; }
function showRobotContextMenu(sx, sy, robot) { const menu = document.getElementById('robotContextMenu'); if (!menu) return; const hasPallet = !!robot.hasPallet; menu.innerHTML = ''; const item = document.createElement('div'); item.style.padding = '8px 12px'; item.style.cursor = 'pointer'; item.textContent = hasPallet ? '卸载托盘' : '加载托盘'; item.onclick = function () { if (hasPallet) unloadPallet(robot.robot_name); else loadPallet(robot.robot_name); hideRobotContextMenu(); }; menu.appendChild(item); const container = document.getElementById('canvasContainer'); const rect = container.getBoundingClientRect(); menu.style.left = (sx + rect.left - rect.left) + 'px'; menu.style.top = (sy + rect.top - rect.top) + 'px'; menu.style.display = 'block'; }
function hideRobotContextMenu() { const menu = document.getElementById('robotContextMenu'); if (menu) menu.style.display = 'none'; }
function isWorkStationPoint(point) { const nm = String(point?.name || point?.id || '').trim(); return /^AP/i.test(nm); } function isChargingStationPoint(point) { const nm = String(point?.name || point?.id || '').trim(); const typeCode = (point && typeof point.type !== 'undefined') ? Number(point.type) : NaN; if (typeCode === 13) return true; return /^CP/i.test(nm); }
function showStationContextMenu(sx, sy, point) { const menu = document.getElementById('stationContextMenu'); if (!menu) return; menu.innerHTML = ''; const itemNav = document.createElement('div'); itemNav.style.padding = '8px 12px'; itemNav.style.cursor = 'pointer'; itemNav.textContent = '导航至该站点'; itemNav.onclick = async function (ev) { if (ev && ev.stopPropagation) ev.stopPropagation(); try { await navigateRobotToStation(point); } catch (err) { console.error('导航失败:', err); try { window.printErrorToStatus(err, '导航失败'); } catch (_) { } } finally { hideStationContextMenu(); } }; if (!selectedRobotId) { itemNav.style.opacity = '0.6'; itemNav.style.pointerEvents = 'none'; const tip = document.createElement('div'); tip.style.padding = '6px 12px'; tip.style.fontSize = '12px'; tip.style.color = '#bdc3c7'; tip.textContent = '请先在列表中选中机器人'; menu.appendChild(tip); } menu.appendChild(itemNav); const isCharge = isChargingStationPoint(point); if (isCharge) { const itemCharge = document.createElement('div'); itemCharge.style.padding = '8px 12px'; itemCharge.style.cursor = 'pointer'; itemCharge.textContent = '执行充电任务'; itemCharge.onclick = async function (ev) { if (ev && ev.stopPropagation) ev.stopPropagation(); try { await navigateRobotToStationWithAction(point, 'StartCharging', { source: 'CPMenu' }); } catch (err) { console.error('充电任务发布失败:', err); try { window.printErrorToStatus(err, '充电任务发布失败'); } catch (_) { } } finally { hideStationContextMenu(); } }; if (!selectedRobotId) { itemCharge.style.opacity = '0.6'; itemCharge.style.pointerEvents = 'none'; } menu.appendChild(itemCharge); } const options = extractBinTaskOptionsForPoint(point); const isWork = isWorkStationPoint(point); if (isWork && options.length > 0) { const actionItem = document.createElement('div'); actionItem.style.padding = '8px 12px'; actionItem.style.cursor = 'pointer'; actionItem.textContent = '至站点执行动作'; const sub = document.createElement('div'); sub.style.display = 'none'; sub.style.borderTop = '1px solid #34495e'; sub.style.marginTop = '6px'; sub.style.paddingTop = '6px'; for (const opt of options) { const btn = document.createElement('div'); btn.style.padding = '6px 12px'; btn.style.cursor = 'pointer'; btn.textContent = opt.title; btn.onclick = async function (ev) { if (ev && ev.stopPropagation) ev.stopPropagation(); try { await navigateRobotToStationWithAction(point, opt.title, opt.params); } catch (err) { console.error('执行动作失败:', err); try { window.printErrorToStatus(err, '执行动作失败'); } catch (_) { } } finally { hideStationContextMenu(); } }; if (!selectedRobotId) { btn.style.opacity = '0.6'; btn.style.pointerEvents = 'none'; } sub.appendChild(btn); } actionItem.onclick = function (ev) { if (ev && ev.stopPropagation) ev.stopPropagation(); sub.style.display = (sub.style.display === 'none') ? 'block' : 'none'; }; menu.appendChild(actionItem); menu.appendChild(sub); } const container = document.getElementById('canvasContainer'); const rect = container.getBoundingClientRect(); menu.style.left = (sx + rect.left - rect.left) + 'px'; menu.style.top = (sy + rect.top - rect.top) + 'px'; menu.style.display = 'block'; }
function hideStationContextMenu() { const menu = document.getElementById('stationContextMenu'); if (menu) menu.style.display = 'none'; }
function extractBinTaskOptionsForPoint(point) { try { const key = String(point?.name || point?.id || '').trim(); if (!key) return []; const entry = lookupBinLocationInfo(key); const objs = Array.isArray(entry?.binTaskObjects) ? entry.binTaskObjects : []; const options = []; for (const obj of objs) { const list = Array.isArray(obj) ? obj : [obj]; for (const item of list) { if (item && typeof item === 'object' && Object.keys(item).length > 0) { const actionName = Object.keys(item)[0]; const params = item[actionName]; options.push({ title: String(actionName), params: (params && typeof params === 'object') ? params : {} }); } } } if (options.length === 0) { const raws = Array.isArray(entry?.binTaskStrings) ? entry.binTaskStrings : []; for (const s of raws) { let title = String(s).trim(); title = title.replace(/\s+/g, ' ').slice(0, 50) || 'RawAction'; options.push({ title, params: { content: s } }); } } return options; } catch (e) { return []; } }
async function navigateRobotToStation(point) { if (!selectedRobotId) { try { window.printErrorToStatus('请先在机器人列表中选中机器人', '导航'); } catch (_) { } return; } const robot = registeredRobots.find(r => r.robot_name === selectedRobotId); if (!robot) { try { window.printErrorToStatus('未找到选中机器人', '导航'); } catch (_) { } return; } const pos = robot.currentPosition || robot.initialPosition; if (!pos) { try { window.printErrorToStatus('机器人没有当前位置或初始位置', '导航'); } catch (_) { } return; } const mapName = resolveMapNameForNav(robot, point); if (!mapName) { try { window.printErrorToStatus('无法解析地图文件名', '导航'); } catch (_) { } return; } document.getElementById('status').textContent = '正在读取地图并规划路径...'; const resp = await fetch('/maps/' + mapName); if (!resp.ok) { try { window.printErrorToStatus(`读取地图失败: HTTP ${resp.status}`, '导航'); } catch (_) { } return; } const sceneData = await resp.json(); const topo = parseSceneTopology(sceneData); if (!Array.isArray(topo.stations) || topo.stations.length === 0 || !Array.isArray(topo.paths) || topo.paths.length === 0) { try { window.printErrorToStatus('地图缺少站点或路段（routes），无法规划', '导航'); } catch (_) { } return; } const stations = await getSceneStationsForMap(mapName); const targetId = findStationIdForPoint(stations, point); if (!targetId) { try { window.printErrorToStatus('无法匹配到对应的站点', '导航'); } catch (_) { } return; } const targetStation = (stations || []).find(s => String(s.instanceName || s.id || s.pointName) === String(targetId)); if (!targetStation || !targetStation.pos) { try { window.printErrorToStatus('无法获取目标站点坐标', '导航'); } catch (_) { } return; } const startStationId = findNearestStation({ x: Number(pos.x), y: Number(pos.y) }, topo.stations); const endStationId = findNearestStation({ x: Number(targetStation.pos.x), y: Number(targetStation.pos.y) }, topo.stations); if (!startStationId || !endStationId) { try { window.printErrorToStatus('无法选取起止站点', '导航'); } catch (_) { } return; } const nodePath = aStar(String(startStationId), String(endStationId), topo.stations, topo.paths); if (!nodePath || nodePath.length < 2) { try { window.printErrorToStatus('未找到可达路径，请检查地图 routes', '导航'); } catch (_) { } return; } const agvInfo = { serial_number: selectedRobotId, manufacturer: robot.manufacturer || 'SEER', version: (robot.version || '2.0.0') }; const mapIdShort = extractFloorFromMapId(mapName); const order = generateVdaOrder(nodePath, agvInfo, topo, mapIdShort, { allowedDeviationXY: 0.5, allowedDeviationTheta: 0.5 }); try { const pubResp = await fetch(`${API_BASE_URL}/agv/${encodeURIComponent(selectedRobotId)}/order`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(order) }); if (!pubResp.ok) throw new Error(`HTTP ${pubResp.status}: ${pubResp.statusText}`); await pubResp.json(); const stationNameById = new Map((topo.stations || []).map(s => [String(s.id), s.name || String(s.id)])); const displayPath = nodePath.map(id => stationNameById.get(String(id)) || String(id)); document.getElementById('status').textContent = `订单已发布，路径: ${displayPath.join(' -> ')}`; } catch (e) { console.error('订单发布失败:', e); try { window.printErrorToStatus(e, '订单发布失败'); } catch (_) { } } }
async function navigateRobotToStationWithAction(point, actionTitle, actionParams) { if (!selectedRobotId) { try { window.printErrorToStatus('请先在机器人列表中选中机器人', '执行动作'); } catch (_) { } return; } const robot = registeredRobots.find(r => r.robot_name === selectedRobotId); if (!robot) { try { window.printErrorToStatus('未找到选中机器人', '执行动作'); } catch (_) { } return; } const pos = robot.currentPosition || robot.initialPosition; if (!pos) { try { window.printErrorToStatus('机器人没有当前位置或初始位置', '执行动作'); } catch (_) { } return; } const mapName = resolveMapNameForNav(robot, point); if (!mapName) { try { window.printErrorToStatus('无法解析地图文件名', '执行动作'); } catch (_) { } return; } document.getElementById('status').textContent = '正在读取地图并规划路径...'; const resp = await fetch('/maps/' + mapName); if (!resp.ok) { try { window.printErrorToStatus(`读取地图失败: HTTP ${resp.status}`, '执行动作'); } catch (_) { } return; } const sceneData = await resp.json(); const topo = parseSceneTopology(sceneData); if (!Array.isArray(topo.stations) || topo.stations.length === 0 || !Array.isArray(topo.paths) || topo.paths.length === 0) { try { window.printErrorToStatus('地图缺少站点或路段（routes），无法规划', '执行动作'); } catch (_) { } return; } const stations = await getSceneStationsForMap(mapName); const targetId = findStationIdForPoint(stations, point); if (!targetId) { try { window.printErrorToStatus('无法匹配到对应的站点', '执行动作'); } catch (_) { } return; } const targetStation = (stations || []).find(s => String(s.instanceName || s.id || s.pointName) === String(targetId)); if (!targetStation || !targetStation.pos) { try { window.printErrorToStatus('无法获取目标站点坐标', '执行动作'); } catch (_) { } return; } const startStationId = findNearestStation({ x: Number(pos.x), y: Number(pos.y) }, topo.stations); const endStationId = findNearestStation({ x: Number(targetStation.pos.x), y: Number(targetStation.pos.y) }, topo.stations); if (!startStationId || !endStationId) { try { window.printErrorToStatus('无法选取起止站点', '执行动作'); } catch (_) { } return; } const nodePath = aStar(String(startStationId), String(endStationId), topo.stations, topo.paths); if (!nodePath || nodePath.length < 2) { try { window.printErrorToStatus('未找到可达路径，请检查地图 routes', '执行动作'); } catch (_) { } return; } const agvInfo = { serial_number: selectedRobotId, manufacturer: robot.manufacturer || 'SEER', version: (robot.version || '2.0.0') }; const mapIdShort = extractFloorFromMapId(mapName); const order = generateVdaOrder(nodePath, agvInfo, topo, mapIdShort, { allowedDeviationXY: 0.5, allowedDeviationTheta: 0.5 }); try { const lastIdx = (order.nodes || []).length - 1; if (lastIdx >= 0) { const paramsList = []; if (actionParams && typeof actionParams === 'object') { for (const k of Object.keys(actionParams)) { paramsList.push({ key: String(k), value: actionParams[k] }); } } const actionObj = { actionType: String(actionTitle || ''), actionId: 'act-' + String(Date.now()), blockingType: 'HARD', actionDescription: String(actionTitle || ''), actionParameters: paramsList }; if (!Array.isArray(order.nodes[lastIdx].actions)) order.nodes[lastIdx].actions = []; order.nodes[lastIdx].actions.push(actionObj); } const pubResp = await fetch(`${API_BASE_URL}/agv/${encodeURIComponent(selectedRobotId)}/order`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(order) }); if (!pubResp.ok) throw new Error(`HTTP ${pubResp.status}: ${pubResp.statusText}`); await pubResp.json(); const stationNameById = new Map((topo.stations || []).map(s => [String(s.id), s.name || String(s.id)])); const displayPath = nodePath.map(id => stationNameById.get(String(id)) || String(id)); document.getElementById('status').textContent = `订单已发布，路径: ${displayPath.join(' -> ')}，动作: ${String(actionTitle)}`; } catch (e) { console.error('订单发布失败:', e); try { window.printErrorToStatus(e, '订单发布失败'); } catch (_) { } } }
function resolveMapNameForNav(robot, point) { const fname = floorNames[currentFloorIndex]; if (fname && typeof fname === 'string' && fname.trim() !== '') { return `VehicleMap/${fname}.scene`; } if (robot && typeof robot.currentMap === 'string' && /\.scene$/.test(robot.currentMap)) { return robot.currentMap; } return null; }
function distanceXY(a, b) { const dx = Number(a.x) - Number(b.x); const dy = Number(a.y) - Number(b.y); return Math.hypot(dx, dy); }
async function getSceneStationsForMap(mapName) { try { const path = String(mapName || '').trim(); if (!path) return []; const resp = await fetch('/maps/' + path); if (!resp.ok) return []; const raw = await resp.json(); const root = Array.isArray(raw) ? raw[0] : raw; const points = (root && Array.isArray(root.points)) ? root.points : []; const allowedPrefixes = ['AP', 'CP', 'PP', 'LM', 'WP']; const startsAllowed = (txt) => allowedPrefixes.some(pref => String(txt || '').trim().toUpperCase().startsWith(pref)); const out = []; for (const p of points) { const nm = String(p.name || p.id || '').trim(); if (!nm || !startsAllowed(nm)) continue; out.push({ id: String(p.id || nm), instanceName: nm, pointName: nm, className: deriveClassFromName(nm), pos: { x: Number(p.x), y: Number(p.y) } }); } return out; } catch (err) { console.error('getSceneStationsForMap error:', err); return []; } }
function findNearestSceneStation(stations, worldPos) { const allowedPrefixes = ['AP', 'CP', 'PP', 'LM', 'WP']; const allowedClasses = new Set(['ActionPoint', 'LocationMark', 'ChargingPoint', 'ParkingPoint', 'WayPoint', 'Waypoint']); let best = null; let bestD = Infinity; (stations || []).forEach(s => { const id = String(s.id || '').trim(); const iName = String(s.instanceName || '').trim(); const pName = String(s.pointName || '').trim(); const cls = String(s.className || '').trim(); const startsAllowed = (txt) => allowedPrefixes.some(pref => txt.startsWith(pref)); const isAllowed = allowedClasses.has(cls) || startsAllowed(id) || startsAllowed(iName) || startsAllowed(pName); if (!isAllowed) return; const sx = (s && s.pos && typeof s.pos.x !== 'undefined') ? Number(s.pos.x) : Number(s.x); const sy = (s && s.pos && typeof s.pos.y !== 'undefined') ? Number(s.pos.y) : Number(s.y); const d = Math.hypot(Number(worldPos.x) - sx, Number(worldPos.y) - sy); if (d < bestD) { bestD = d; best = s; } }); return best; }
function findStationIdForPoint(stations, pt) { const key1 = (pt?.name || '').trim(); const key2 = (pt?.id || '').trim(); const allowedPrefixes = ['AP', 'CP', 'PP', 'LM', 'WP']; const allowedClasses = new Set(['ActionPoint', 'LocationMark', 'ChargingPoint', 'ChargePoint', 'ParkingPoint', 'ParkPoint', 'WayPoint', 'Waypoint']); const startsAllowed = (txt) => allowedPrefixes.some(pref => String(txt || '').trim().startsWith(pref)); const isAllowedStation = (s) => { const id = String(s.id || '').trim(); const iName = String(s.instanceName || '').trim(); const pName = String(s.pointName || '').trim(); const cls = String(s.className || '').trim(); return allowedClasses.has(cls) || startsAllowed(id) || startsAllowed(iName) || startsAllowed(pName); }; for (const s of (stations || [])) { const iName = (s.instanceName || '').trim(); const pName = (s.pointName || '').trim(); if (!isAllowedStation(s)) continue; if (key1 && (iName === key1 || pName === key1)) return s.instanceName || s.id || s.pointName; if (key2 && (iName === key2 || pName === key2)) return s.instanceName || s.id || s.pointName; } const nearest = findNearestSceneStation(stations, pt.pos || { x: 0, y: 0 }); return nearest ? (nearest.instanceName || nearest.id || nearest.pointName) : null; }
async function callNavToStation(robotId, stationId, mapName) { const url = `${API_BASE_URL}/sim/agv/${encodeURIComponent(robotId)}/nav/station?station_id=${encodeURIComponent(stationId)}&map_name=${encodeURIComponent(mapName)}`; const resp = await fetch(url, { method: 'POST' }); if (!resp.ok) throw new Error(`HTTP ${resp.status}: ${resp.statusText}`); return await resp.json(); }
async function pollNavUntilDone(robotId, timeoutMs = 60000) { const start = Date.now(); while (Date.now() - start < timeoutMs) { try { const resp = await fetch(`${API_BASE_URL}/agv/${encodeURIComponent(robotId)}/nav/status`); if (resp.ok) { const st = await resp.json(); if (!st.running) return true; } } catch (e) { } await new Promise(r => setTimeout(r, window.FRONTEND_POLL_INTERVAL_MS || 100)); } return false; }
function loadPallet(id) { const robot = registeredRobots.find(r => r.robot_name === id); if (!robot) return; if (robot.hasPallet) return; robot._palletAnimLoading = true; robot._palletAnimStart = performance.now(); robot._palletAnimProgress = 0; try { const target = (isFinite(Number(robot.forkHeight)) ? Number(robot.forkHeight) : 0.1); robot._forkBarAnimLoading = true; robot._forkBarAnimUnloading = false; robot._forkBarAnimStart = performance.now(); robot._forkBarAnimProgress = 0; robot._forkBarAnimStartHeight = (isFinite(Number(robot._forkBarDisplayHeight)) ? Number(robot._forkBarDisplayHeight) : (isFinite(Number(robot.forkHeight)) ? Number(robot.forkHeight) : 0)); robot._forkBarAnimTargetHeight = target; } catch (_) { } startPalletAnimationLoop(); }
function unloadPallet(id) { const robot = registeredRobots.find(r => r.robot_name === id); if (!robot) return; robot._palletAnimLoading = false; robot._palletAnimUnloading = true; robot._palletAnimStart = performance.now(); robot._palletAnimProgress = 0; try { const target = (isFinite(Number(robot.forkHeight)) ? Number(robot.forkHeight) : 0.0); robot._forkBarAnimLoading = false; robot._forkBarAnimUnloading = true; robot._forkBarAnimStart = performance.now(); robot._forkBarAnimProgress = 0; robot._forkBarAnimStartHeight = (isFinite(Number(robot._forkBarDisplayHeight)) ? Number(robot._forkBarDisplayHeight) : (isFinite(Number(robot.forkHeight)) ? Number(robot.forkHeight) : 0)); robot._forkBarAnimTargetHeight = target; } catch (_) { } startPalletAnimationLoop(); }
let palletAnimTimer = null; function startPalletAnimationLoop() { if (palletAnimTimer) return; palletAnimTimer = setInterval(() => { const now = performance.now(); let any = false; registeredRobots.forEach(r => { if (r._palletAnimLoading) { const dur = 3000; const p = Math.max(0, Math.min(1, (now - (r._palletAnimStart || now)) / dur)); r._palletAnimProgress = p; if (p >= 1) { r._palletAnimLoading = false; r.hasPallet = true; } else { any = true; } } else if (r._palletAnimUnloading) { const dur = 3000; const p = Math.max(0, Math.min(1, (now - (r._palletAnimStart || now)) / dur)); r._palletAnimProgress = p; if (p >= 1) { r._palletAnimUnloading = false; r.hasPallet = false; r.shelfModel = null; } else { any = true; } } try { if (r._forkBarAnimLoading) { const dur = 3000; const p = Math.max(0, Math.min(1, (now - (r._forkBarAnimStart || now)) / dur)); r._forkBarAnimProgress = p; const startH = (isFinite(Number(r._forkBarAnimStartHeight)) ? Number(r._forkBarAnimStartHeight) : 0); const liveTarget = (isFinite(Number(r.forkHeight)) ? Number(r.forkHeight) : undefined); const targetH = (typeof liveTarget !== 'undefined') ? liveTarget : (isFinite(Number(r._forkBarAnimTargetHeight)) ? Number(r._forkBarAnimTargetHeight) : 0.1); r._forkBarDisplayHeight = startH + (targetH - startH) * p; if (p >= 1) { r._forkBarAnimLoading = false; r._forkBarDisplayHeight = (isFinite(Number(r.forkHeight)) ? Number(r.forkHeight) : targetH); } else { any = true; } } else if (r._forkBarAnimUnloading) { const dur = 3000; const p = Math.max(0, Math.min(1, (now - (r._forkBarAnimStart || now)) / dur)); r._forkBarAnimProgress = p; const startH = (isFinite(Number(r._forkBarAnimStartHeight)) ? Number(r._forkBarAnimStartHeight) : 0); const liveTarget = (isFinite(Number(r.forkHeight)) ? Number(r.forkHeight) : undefined); const targetH = (typeof liveTarget !== 'undefined') ? liveTarget : 0.0; r._forkBarDisplayHeight = startH + (targetH - startH) * p; if (p >= 1) { r._forkBarAnimUnloading = false; r._forkBarDisplayHeight = (isFinite(Number(r.forkHeight)) ? Number(r.forkHeight) : targetH); } else { any = true; } } else { const live = Number(r.forkHeight); if (isFinite(live)) r._forkBarDisplayHeight = live; } } catch (_) { } }); drawMap(); if (!any) { clearInterval(palletAnimTimer); palletAnimTimer = null; } }, 16); }

function getRouteDirection(route) { let d = route.direction; if (d === undefined && Array.isArray(route.properties)) { const p = route.properties.find(pr => (pr.name === 'direction' || pr.key === 'direction')); if (p) d = Number(p.value); } if (typeof d !== 'number' || isNaN(d)) return 1; if (d === 0) return 0; return d > 0 ? 1 : -1; }
function drawArrowAt(x, y, angle) { const arrowLength = 10; const arrowAngle = Math.PI / 6; ctx.save(); ctx.fillStyle = ctx.strokeStyle; ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(x - arrowLength * Math.cos(angle - arrowAngle), y - arrowLength * Math.sin(angle - arrowAngle)); ctx.lineTo(x - arrowLength * Math.cos(angle + arrowAngle), y - arrowLength * Math.sin(angle + arrowAngle)); ctx.closePath(); ctx.fill(); ctx.restore(); }
function drawArrow(start, end) { const angle = Math.atan2(end.y - start.y, end.x - start.x); drawArrowAt(end.x, end.y, angle); }
function bezierPoint(p0, p1, p2, p3, t) { const u = 1 - t; const tt = t * t; const uu = u * u; const uuu = uu * u; const ttt = tt * t; return { x: uuu * p0.x + 3 * uu * t * p1.x + 3 * u * tt * p2.x + ttt * p3.x, y: uuu * p0.y + 3 * uu * t * p1.y + 3 * u * tt * p2.y + ttt * p3.y }; }
function bezierTangent(p0, p1, p2, p3, t) { const u = 1 - t; return { x: 3 * u * u * (p1.x - p0.x) + 6 * u * t * (p2.x - p1.x) + 3 * t * t * (p3.x - p2.x), y: 3 * u * u * (p1.y - p0.y) + 6 * u * t * (p2.y - p1.y) + 3 * t * t * (p3.y - p2.y) }; }

function buildBinLocationIndex(layers) { const byFloor = []; function buildIndexForLayer(layer) { const byPointName = new Map(); function recordEntry(pointName, instanceName, binTaskString) { if (!pointName) return; const key = String(pointName).trim().toUpperCase(); let entry = byPointName.get(key); if (!entry) { entry = { locationNames: [], binTaskStrings: [], binTaskObjects: [] }; byPointName.set(key, entry); } if (instanceName) entry.locationNames.push(String(instanceName).trim()); if (typeof binTaskString === 'string' && binTaskString.trim() !== '') { entry.binTaskStrings.push(binTaskString); try { const parsed = JSON.parse(binTaskString); entry.binTaskObjects.push(parsed); } catch (_) { } } } function traverse(obj) { if (!obj) return; if (Array.isArray(obj)) { obj.forEach(traverse); return; } if (typeof obj === 'object') { if (Array.isArray(obj.binLocationList)) { for (const loc of obj.binLocationList) { const pName = String(loc?.pointName || '').trim(); const iName = String(loc?.instanceName || '').trim(); const props = Array.isArray(loc?.property) ? loc.property : (Array.isArray(loc?.properties) ? loc.properties : []); let taskStrs = []; for (const prop of (props || [])) { if (prop && String(prop.key || '').trim() === 'binTask' && typeof prop.stringValue === 'string') { taskStrs.push(prop.stringValue); } } if (taskStrs.length === 0) { recordEntry(pName, iName, undefined); } else { for (const s of taskStrs) recordEntry(pName, iName, s); } } } for (const k in obj) { if (!Object.prototype.hasOwnProperty.call(obj, k)) continue; const v = obj[k]; if (v && (typeof v === 'object' || Array.isArray(v))) traverse(v); } } } try { traverse(layer); } catch (_) { } return byPointName; } try { for (const layer of (layers || [])) { byFloor.push(buildIndexForLayer(layer)); } } catch (_) { } window.binLocationIndex = { byFloor }; }
function lookupBinLocationInfo(pointName) { const key = String(pointName || '').trim().toUpperCase(); const idx = (typeof currentFloorIndex === 'number') ? currentFloorIndex : 0; const byFloor = window.binLocationIndex?.byFloor; const map = Array.isArray(byFloor) ? byFloor[idx] : null; return (map && map.get(key)) || null; }
function formatBinTaskDetails(entry) { try { const objs = Array.isArray(entry?.binTaskObjects) ? entry.binTaskObjects : []; const sections = []; for (const obj of objs) { const arr = Array.isArray(obj) ? obj : [obj]; for (const item of arr) { if (item && typeof item === 'object') { for (const actionName of Object.keys(item)) { const params = item[actionName]; const lines = []; lines.push(`${actionName}：`); if (params && typeof params === 'object') { for (const k of Object.keys(params)) { const v = params[k]; const vs = (typeof v === 'string') ? `"${v}"` : String(v); lines.push(` "${k}": ${vs}`); } } else { lines.push(` ${String(params)}`); } sections.push(lines.join('\n')); } } else if (typeof item === 'string') { sections.push(item); } else { sections.push(String(item)); } } } if (sections.length > 0) return sections.join('\n\n'); const raw = Array.isArray(entry?.binTaskStrings) ? entry.binTaskStrings : []; return raw.join('\n'); } catch (_) { const raw = Array.isArray(entry?.binTaskStrings) ? entry.binTaskStrings : []; return raw.join('\n'); } }
function renderBinTaskDetails(entry) { const container = document.getElementById('stStorageDetails'); if (!container) return false; container.innerHTML = ''; const objs = Array.isArray(entry?.binTaskObjects) ? entry.binTaskObjects : []; let made = false; function makeCard(title, kv) { const card = document.createElement('div'); card.className = 'bin-card'; const t = document.createElement('div'); t.className = 'bin-card-title'; t.textContent = title || 'Detail'; card.appendChild(t); for (const [k, v] of kv) { const row = document.createElement('div'); row.className = 'bin-kv'; const kEl = document.createElement('div'); kEl.className = 'key'; kEl.textContent = String(k); const vEl = document.createElement('div'); vEl.className = 'val'; vEl.textContent = (typeof v === 'string') ? v : String(v); row.appendChild(kEl); row.appendChild(vEl); card.appendChild(row); } container.appendChild(card); } for (const obj of objs) { const list = Array.isArray(obj) ? obj : [obj]; for (const item of list) { if (item && typeof item === 'object' && Object.keys(item).length > 0) { const actionName = Object.keys(item)[0]; const params = item[actionName]; const kv = []; if (params && typeof params === 'object') { for (const k of Object.keys(params)) kv.push([k, params[k]]); } makeCard(actionName, kv); made = true; } else if (typeof item === 'string') { makeCard('Raw', [['string', item]]); made = true; } } } if (!made) { const raws = Array.isArray(entry?.binTaskStrings) ? entry.binTaskStrings : []; for (const r of raws) { makeCard('Raw', [['string', r]]); made = true; } } return made; }

async function loadMapData() { try { document.getElementById('loading').style.display = 'block'; document.getElementById('status').textContent = '正在加载地图数据...'; const resp = await fetch('/maps/' + CURRENT_MAP_ID); if (!resp.ok) throw new Error(`HTTP ${resp.status}: ${resp.statusText}`); const raw = await resp.json(); mapLayers = Array.isArray(raw) ? raw : (raw ? [raw] : []); buildBinLocationIndex(mapLayers); floorNames = mapLayers.map(extractFloorNameFromLayer); if (!Array.isArray(floorNames) || floorNames.filter(v => !!v).length === 0) { const root = mapLayers.length > 0 ? mapLayers[0] : null; const unique = new Set(); const pts = (root && Array.isArray(root.points)) ? root.points : []; pts.forEach(p => { const nm = extractFloorNameFromLayer(p.layer || ''); if (nm) unique.add(nm); }); if (unique.size > 0) { floorNames = Array.from(unique); } } currentFloorIndex = 0; mapData = mapLayers.length > 0 ? normalizeScene(mapLayers[currentFloorIndex]) : null; await loadSceneStations(); populateFloorSelect(); updateMapInfo(); fitMapToView(); drawMap(); document.getElementById('status').textContent = '地图加载完成'; } catch (err) { console.error('加载地图数据失败:', err); document.getElementById('status').textContent = '加载失败: ' + err.message; } finally { document.getElementById('loading').style.display = 'none'; } }
function normalizeScene(scene) { if (!scene) return null; return JSON.parse(JSON.stringify(scene)); }
function populateFloorSelect() { const sel = document.getElementById('floorSelect'); if (!sel) return; sel.innerHTML = ''; const availableFloorCount = (Array.isArray(floorNames) && floorNames.length > 0) ? floorNames.length : mapLayers.length; if (!Array.isArray(mapLayers) || mapLayers.length === 0 || availableFloorCount === 0) { const opt = document.createElement('option'); opt.value = ''; opt.textContent = '无楼层'; sel.appendChild(opt); sel.disabled = true; return; } sel.disabled = false; for (let i = 0; i < availableFloorCount; i++) { const opt = document.createElement('option'); opt.value = String(i); const fname = floorNames[i]; opt.textContent = fname ? `${fname}` : `${i + 1}层`; sel.appendChild(opt); } sel.value = String(currentFloorIndex); }
function switchFloor(idx) { const i = parseInt(idx, 10); const availableFloorCount = (Array.isArray(floorNames) && floorNames.length > 0) ? floorNames.length : mapLayers.length; if (isNaN(i) || i < 0 || i >= availableFloorCount) return; currentFloorIndex = i; const layerIndex = Math.min(currentFloorIndex, Math.max(0, mapLayers.length - 1)); mapData = normalizeScene(mapLayers[layerIndex]); loadSceneStations(); updateMapInfo(); fitMapToView(); drawMap(); const fname = floorNames[currentFloorIndex]; document.getElementById('status').textContent = fname ? `已切换到楼层: ${fname}` : `已切换到${i + 1}层`; }
function cycleFloor() { const availableFloorCount = (Array.isArray(floorNames) && floorNames.length > 0) ? floorNames.length : mapLayers.length; if (availableFloorCount === 0) return; const next = (currentFloorIndex + 1) % availableFloorCount; switchFloor(next); const sel = document.getElementById('floorSelect'); if (sel) sel.value = String(next); }
function updateMapInfo() { const pc = mapData?.points?.length || 0; const rc = mapData?.routes?.length || 0; document.getElementById('pointCount').textContent = pc; document.getElementById('routeCount').textContent = rc; updateInitialPositionOptions(); }
function updateInitialPositionOptions() { const regMapSel = document.getElementById('registerMapSelect'); const chosen = regMapSel ? regMapSel.value : ''; if (regMapSel && /(^|\/)VehicleMap\/[^\/]+\.scene$/.test(chosen)) { updateRegisterInitialPositionOptions(); return; } const sel = document.getElementById('initialPosition'); sel.innerHTML = '<option value="">选择初始位置</option>'; (mapData?.points || []).forEach(p => { if (p.name) { const opt = document.createElement('option'); opt.value = p.id; opt.textContent = `${p.name} (${p.x.toFixed(2)}, ${p.y.toFixed(2)})`; sel.appendChild(opt); } }); sel.disabled = false; }
function fitMapToView() { if (!mapData || !mapData.points || mapData.points.length === 0) return; let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity; mapData.points.forEach(p => { const sx = p.x * 20, sy = p.y * 20; minX = Math.min(minX, sx); minY = Math.min(minY, sy); maxX = Math.max(maxX, sx); maxY = Math.max(maxY, sy); }); const mapW = maxX - minX, mapH = maxY - minY, cx = (minX + maxX) / 2, cy = (minY + maxY) / 2; const pad = 50; const sX = (canvas.width - pad * 2) / mapW; const sY = (canvas.height - pad * 2) / mapH; viewTransform.scale = Math.min(sX, sY); viewTransform.x = canvas.width / 2 - cx * viewTransform.scale; viewTransform.y = canvas.height / 2 + cy * viewTransform.scale; updateZoomDisplay(); }
function updateZoomDisplay() { document.getElementById('zoomLevel').textContent = Math.round(viewTransform.scale * 100) + '%'; }
function drawMap() { if (!mapData) return; ctx.clearRect(0, 0, canvas.width, canvas.height); if (showGrid) drawGrid(); if (mapData.routes) drawRoutes(); if (mapData.points) drawPoints(); if (registeredRobots.length > 0) drawRobots(); try { updateDoorOverlayPositions(); } catch (e) { } }
function drawGrid() { ctx.save(); ctx.strokeStyle = '#34495e'; ctx.lineWidth = 1; const g = 50 * viewTransform.scale; const ox = viewTransform.x % g, oy = viewTransform.y % g; for (let x = ox; x < canvas.width; x += g) { ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); ctx.stroke(); } for (let y = oy; y < canvas.height; y += g) { ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(canvas.width, y); ctx.stroke(); } ctx.restore(); }
function drawPoints() { (mapData.points || []).forEach(point => { const currentFloorName = floorNames[currentFloorIndex] || null; const pfloor = extractFloorNameFromLayer(point.layer || ''); if (currentFloorName && pfloor && String(pfloor).trim().toLowerCase() !== String(currentFloorName).trim().toLowerCase()) { return; } const sp = worldToScreen(point.x, point.y); if (sp.x < -20 || sp.x > canvas.width + 20 || sp.y < -20 || sp.y > canvas.height + 20) return; ctx.save(); let color = '#95a5a6'; let size = pointDrawSize(); const t = Number(point.type); if (!Number.isNaN(t) && POINT_TYPE_INFO[t]) { color = POINT_TYPE_INFO[t].color; } else { const nm = point.name || ''; if (nm.startsWith('AP')) { color = '#e74c3c'; } else if (nm.startsWith('LM')) { color = '#f39c12'; } else if (nm.startsWith('CP')) { color = '#27ae60'; } } ctx.fillStyle = color; ctx.beginPath(); ctx.arc(sp.x, sp.y, size, 0, 2 * Math.PI); ctx.fill(); ctx.strokeStyle = '#2c3e50'; ctx.lineWidth = 2; ctx.stroke(); const name = point.name || ''; const key = name || point.id; let isSelected = !!selectedStationId && key === selectedStationId; if (!isSelected && selectedNavStation && selectedNavStation.pos) { const hitRadius = pointDrawSize() + 2; const spSel = worldToScreen(selectedNavStation.pos.x, selectedNavStation.pos.y); const dxs = sp.x - spSel.x, dys = sp.y - spSel.y; if (dxs * dxs + dys * dys <= (hitRadius + 4) * (hitRadius + 4)) { isSelected = true; } } if (isSelected) { ctx.strokeStyle = '#f1c40f'; ctx.lineWidth = 3; ctx.beginPath(); ctx.arc(sp.x, sp.y, size + 4, 0, 2 * Math.PI); ctx.stroke(); } if (viewTransform.scale > 0.5 && name) { ctx.fillStyle = '#ecf0f1'; ctx.font = '12px Arial'; ctx.textAlign = 'center'; ctx.fillText(name, sp.x, sp.y - size - 6); } ctx.restore(); }); }
function drawRoutes() { if (!mapData || !mapData.points) return; const pmap = {}; mapData.points.forEach(p => pmap[p.id] = p); (mapData.routes || []).forEach(route => { const fp = pmap[route.from], tp = pmap[route.to]; if (!fp || !tp) return; const dir = getRouteDirection(route); const currentFloorName = floorNames[currentFloorIndex] || null; if (currentFloorName) { const nf = String(currentFloorName).trim().toLowerCase(); const ff = extractFloorNameFromLayer(fp.layer || ''); const tf = extractFloorNameFromLayer(tp.layer || ''); const ffn = ff ? String(ff).trim().toLowerCase() : ''; const tfn = tf ? String(tf).trim().toLowerCase() : ''; if (ffn && ffn !== nf) return; if (tfn && tfn !== nf) return; } ctx.save(); const passCode = (route.pass !== undefined) ? Number(route.pass) : 0; const baseColor = getRouteColorByPass(passCode); ctx.strokeStyle = baseColor; ctx.lineWidth = 2; ctx.lineCap = 'round'; if (passCode === 10) { ctx.setLineDash([6, 4]); } else { ctx.setLineDash([]); } const rid = String(route.id ?? (`${route.from}->${route.to}`)); const isSelected = !!selectedRouteId && String(selectedRouteId) === rid; if (isSelected) { ctx.lineWidth = 3; } if (route.type === 'bezier3' && route.c1 && route.c2) { const p0 = { x: fp.x, y: fp.y }; const p1 = { x: route.c1.x, y: route.c1.y }; const p2 = { x: route.c2.x, y: route.c2.y }; const p3 = { x: tp.x, y: tp.y }; const fromScreen = worldToScreen(p0.x, p0.y); const c1Screen = worldToScreen(p1.x, p1.y); const c2Screen = worldToScreen(p2.x, p2.y); const toScreen = worldToScreen(p3.x, p3.y); ctx.beginPath(); ctx.moveTo(fromScreen.x, fromScreen.y); ctx.bezierCurveTo(c1Screen.x, c1Screen.y, c2Screen.x, c2Screen.y, toScreen.x, toScreen.y); ctx.stroke(); if (viewTransform.scale > 0.3) { if (dir !== 0) { const t = 0.7; const q0 = dir > 0 ? p0 : p3; const q1 = dir > 0 ? p1 : p2; const q2 = dir > 0 ? p2 : p1; const q3 = dir > 0 ? p3 : p0; const pt = bezierPoint(q0, q1, q2, q3, t); const tg = bezierTangent(q0, q1, q2, q3, t); const ptScreen = worldToScreen(pt.x, pt.y); const tgScreen = { x: worldToScreen(q0.x + tg.x, q0.y + tg.y).x - worldToScreen(q0.x, q0.y).x, y: worldToScreen(q0.x + tg.y, q0.y + tg.y).y - worldToScreen(q0.x, q0.y).y }; const angle = Math.atan2(tgScreen.y, tgScreen.x); drawArrowAt(ptScreen.x, ptScreen.y, angle); } else { const t1 = 0.3; const pt1 = bezierPoint(p0, p1, p2, p3, t1); const tg1 = bezierTangent(p0, p1, p2, p3, t1); const pt1Screen = worldToScreen(pt1.x, pt1.y); const tg1Screen = { x: worldToScreen(p0.x + tg1.x, p0.y + tg1.y).x - worldToScreen(p0.x, p0.y).x, y: worldToScreen(p0.x + tg1.y, p0.y + tg1.y).y - worldToScreen(p0.x, p0.y).y }; drawArrowAt(pt1Screen.x, pt1Screen.y, Math.atan2(tg1Screen.y, tg1Screen.x)); const r0 = p3, r1 = p2, r2 = p1, r3 = p0; const pt2 = bezierPoint(r0, r1, r2, r3, t1); const tg2 = bezierTangent(r0, r1, r2, r3, t1); const pt2Screen = worldToScreen(pt2.x, pt2.y); const tg2Screen = { x: worldToScreen(r0.x + tg2.x, r0.y + tg2.y).x - worldToScreen(r0.x, r0.y).x, y: worldToScreen(r0.x + tg2.y, r0.y + tg2.y).y - worldToScreen(r0.x, r0.y).y }; drawArrowAt(pt2Screen.x, pt2Screen.y, Math.atan2(tg2Screen.y, tg2Screen.x)); } } } else { const fromScreen = worldToScreen(fp.x, fp.y); const toScreen = worldToScreen(tp.x, tp.y); ctx.beginPath(); ctx.moveTo(fromScreen.x, fromScreen.y); ctx.lineTo(toScreen.x, toScreen.y); ctx.stroke(); if (viewTransform.scale > 0.3) { if (dir === 0) { drawArrow(fromScreen, toScreen); drawArrow(toScreen, fromScreen); } else { const start = dir > 0 ? fromScreen : toScreen; const end = dir > 0 ? toScreen : fromScreen; drawArrow(start, end); } } } ctx.restore(); }); }
function drawRobots() { registeredRobots.forEach(robot => { if (robot.currentMap) { const robotFloor = extractFloorFromMapId(robot.currentMap); const currentFloorName = floorNames[currentFloorIndex] || null; if (robotFloor && currentFloorName && String(robotFloor).trim().toLowerCase() !== String(currentFloorName).trim().toLowerCase()) { return; } } let pos = robot.currentPosition || robot.initialPosition || null; if (!pos) return; const sp = worldToScreen(pos.x, pos.y); if (sp.x < -50 || sp.x > canvas.width + 50 || sp.y < -50 || sp.y > canvas.height + 50) return; try { drawCollisionOverlay(sp.x, sp.y, ((pos.theta ?? pos.orientation) || 0), robot); } catch (_) { } drawRobotIcon(sp.x, sp.y, ((pos.theta ?? pos.orientation) || 0), robot); }); }
function extractFloorNameFromLayer(layer) { try { if (typeof layer === 'string') { const v = layer.trim(); if (v) return v; } if (layer && Array.isArray(layer.list)) { for (const item of layer.list) { if (item && typeof item.name === 'string') { const v = item.name.trim(); if (v) return v; } } } if (layer && typeof layer.name === 'string' && layer.name.trim() !== '') { return layer.name.trim(); } } catch (e) { } return null; }
function extractFloorFromMapId(mapId) { const raw = String(mapId || '').trim(); if (!raw) return null; const mScene = /^VehicleMap\/(.+)\.scene$/i.exec(raw); if (mScene) return mScene[1]; const mViewer = /^ViewerMap\/(.+)\.scene$/i.exec(raw); if (mViewer) return mViewer[1]; const fname = raw.replace(/\\/g, '/').split('/').pop(); return (fname || '').replace(/\.scene$/i, '') || null; }
function drawRobotIcon(x, y, rotationDeg, robot) { ctx.save(); ctx.translate(x, y); ctx.rotate(-rotationDeg - Math.PI / 2); const s = viewTransform.scale; const meterScale = 20; const defaults = { width: 0.745, length: 1.03 }; const w = Number(robot?.collisionParams?.width ?? defaults.width); const l = Number(robot?.collisionParams?.length ?? defaults.length); const wPx = w * meterScale * s; const lRectPx = Math.max(2, (l - (w / 2)) * meterScale * s); ctx.fillStyle = '#4A90E2'; ctx.strokeStyle = '#2E5C8A'; ctx.lineWidth = 1; ctx.fillRect(-wPx / 2, -lRectPx / 2, wPx, lRectPx); ctx.strokeRect(-wPx / 2, -lRectPx / 2, wPx, lRectPx); ctx.fillStyle = '#6BB6FF'; ctx.beginPath(); ctx.arc(0, -lRectPx / 2, Math.max(2, wPx / 2), 0, Math.PI, true); ctx.closePath(); ctx.fill(); ctx.stroke(); ctx.fillStyle = '#FF6B6B'; ctx.strokeStyle = '#D63031'; const arrowLen = Math.max(8, (lRectPx + wPx / 2) * 0.12); const arrowHalf = Math.max(4, wPx * 0.18); ctx.beginPath(); ctx.moveTo(0, -lRectPx / 2 - (wPx / 2) - arrowLen); ctx.lineTo(-arrowHalf, -lRectPx / 2 - (wPx / 2)); ctx.lineTo(arrowHalf, -lRectPx / 2 - (wPx / 2)); ctx.closePath(); ctx.fill(); ctx.stroke(); const fp = robot.shelfModel && robot.shelfModel.footprint; const wm = Number(fp && (fp.width_m ?? fp.width)); const lm = Number(fp && (fp.length_m ?? fp.length)); const palletW = Math.max(2, (isFinite(wm) && wm > 0 ? wm : 1.0) * meterScale * s); const palletL = Math.max(2, (isFinite(lm) && lm > 0 ? lm : 1.2) * meterScale * s); const shouldDrawPallet = !!robot.hasPallet || !!robot._palletAnimLoading || !!robot._palletAnimUnloading; if (shouldDrawPallet) { let offsetX = 0; let offsetY = 0; try { const pos = robot.currentPosition || robot.initialPosition || null; const saf = robot.safety || null; if (pos && saf && saf.center && typeof saf.center.x === 'number' && typeof saf.center.y === 'number') { const dx = Number(saf.center.x) - Number(pos.x); const dy = Number(saf.center.y) - Number(pos.y); const rad = Number(pos.theta || 0); const localX = dx * (-Math.sin(rad)) + dy * (Math.cos(rad)); const localY = dx * (-Math.cos(rad)) + dy * (-Math.sin(rad)); offsetX = localX * meterScale * s; offsetY = localY * meterScale * s; } } catch (_) { } let alpha = 1.0; let slide = 0; if (robot._palletAnimLoading) { const p = Math.max(0, Math.min(1, robot._palletAnimProgress || 0)); alpha = p; slide = (1 - p) * 6; } else if (robot._palletAnimUnloading) { const p = Math.max(0, Math.min(1, robot._palletAnimProgress || 0)); alpha = 1 - p; slide = p * 6; } ctx.save(); ctx.globalAlpha = alpha; ctx.fillStyle = '#8B5E3C'; ctx.strokeStyle = '#5D3A1A'; ctx.lineWidth = 1; ctx.fillRect(-palletW / 2 - offsetX, -palletL / 2 + slide - offsetY, palletW, palletL); ctx.strokeRect(-palletW / 2 - offsetX, -palletL / 2 + slide - offsetY, palletW, palletL); ctx.strokeStyle = '#704A2B'; for (let i = 1; i <= 2; i++) { const y = -palletL / 2 + slide - offsetY + (i * palletL / 3); ctx.beginPath(); ctx.moveTo(-palletW / 2 + 2 - offsetX, y); ctx.lineTo(palletW / 2 - 2 - offsetX, y); ctx.stroke(); } ctx.restore(); } try { const meterScale = 20; const fhDisplay = Number(robot && robot._forkBarDisplayHeight); const fhRaw = Number(robot && robot.forkHeight); const fh = (isFinite(fhDisplay) ? fhDisplay : fhRaw); if (isFinite(fh) && fh >= 0) { const barH = Math.max(2, fh * meterScale * s * 10); ctx.save(); ctx.fillStyle = '#f1c40f'; ctx.strokeStyle = '#f39c12'; ctx.lineWidth = Math.max(1, s); const marginPx = Math.max(3 * s, 4); const barX = (wPx / 2) + marginPx; const barW = Math.max(2, Math.min(6 * s, wPx * 0.08)); const barY = (lRectPx / 2) - barH; ctx.fillRect(barX, barY, barW, barH); ctx.strokeRect(barX, barY, barW, barH); ctx.restore(); } } catch (_) { } ctx.restore(); if (viewTransform.scale > 0.5 && robot.robot_name) { ctx.save(); ctx.fillStyle = '#ecf0f1'; ctx.font = '12px Arial'; ctx.textAlign = 'center'; ctx.strokeStyle = '#2c3e50'; ctx.lineWidth = 3; ctx.strokeText(robot.robot_name, x, y - 5); ctx.fillText(robot.robot_name, x, y - 5); ctx.restore(); } }

function applyWSVisualization(visMsg) { try { const payload = visMsg || {}; const sn = String(payload.serial_number || payload.serialNumber || '').trim(); if (!sn) return; const robot = registeredRobots.find(r => r.robot_name === sn); if (!robot) return; try { const saf = payload.safety || null; if (saf && saf.center && typeof saf.length === 'number' && typeof saf.width === 'number') { robot.safety = { center: { x: Number(saf.center.x), y: Number(saf.center.y) }, length: Number(saf.length), width: Number(saf.width), theta: Number(saf.theta ?? (robot.currentPosition?.theta ?? 0)) }; } } catch (_) { } try { const radar = payload.radar || null; if (radar && radar.origin && typeof radar.radius === 'number') { robot.radar = { origin: { x: Number(radar.origin.x), y: Number(radar.origin.y) }, fovDeg: Number(radar.fovDeg ?? radar.fov_deg ?? 60), radius: Number(radar.radius ?? 0.8), theta: Number(radar.theta ?? (robot.currentPosition?.theta ?? 0)) }; } } catch (_) { } try { const ov = payload.overlaps || null; if (ov && typeof ov === 'object') { const rad = Array.isArray(ov.radar) ? ov.radar : []; const saf = Array.isArray(ov.safety) ? ov.safety : []; robot.overlaps = { radar: rad.map(it => ({ with: String(it.with || ''), points: (Array.isArray(it.points) ? it.points : []).map(p => ({ x: Number(p.x), y: Number(p.y) })) })), safety: saf.map(it => ({ with: String(it.with || ''), points: (Array.isArray(it.points) ? it.points : []).map(p => ({ x: Number(p.x), y: Number(p.y) })) })) }; } else { robot.overlaps = { radar: [], safety: [] }; } } catch (_) { } } catch (e) { } }

function drawCollisionOverlay(cx, cy, thetaRad, robot) { const meterScale = 20; const s = viewTransform.scale; const r = robot || {}; const radar = r && r.radar ? r.radar : null; try { if (robot && robot.safety) { const c = robot.safety.center || { x: cx, y: cy }; const ln = Number(robot.safety.length ?? 0); const wd = Number(robot.safety.width ?? 0); const th = Number(robot.safety.theta ?? thetaRad); const sp = worldToScreen(c.x, c.y); ctx.save(); ctx.translate(sp.x, sp.y); ctx.rotate(-th - Math.PI / 2); const rwPx = wd * meterScale * s; const rlPx = ln * meterScale * s; ctx.globalAlpha = 0.10; ctx.fillStyle = '#9b59b6'; ctx.strokeStyle = '#8e44ad'; ctx.lineWidth = Math.max(1, s); ctx.beginPath(); ctx.moveTo(-rwPx / 2, rlPx / 2); ctx.lineTo(rwPx / 2, rlPx / 2); ctx.lineTo(rwPx / 2, -rlPx / 2); ctx.lineTo(-rwPx / 2, -rlPx / 2); ctx.closePath(); ctx.fill(); ctx.stroke(); ctx.restore(); } } catch (_) { } try { if (radar && radar.origin) { const o = radar.origin; const fov = Number(radar.fovDeg ?? radar.fov_deg ?? 60); const radius = Number(radar.radius ?? 0.8); const th = Number(radar.theta ?? thetaRad); const isBlocked = (() => { try { const errs = (r && r.stateErrors) || []; return errs.some(e => String(e.errorType) === '54231' || String(e.errorName).toLowerCase() === 'robotblocked'); } catch (_) { return false; } })(); const sp = worldToScreen(o.x, o.y); ctx.save(); ctx.translate(sp.x, sp.y); ctx.rotate(-th - Math.PI / 2); const half = (fov * Math.PI / 180) / 2; const radiusPx = radius * meterScale * s; for (let i = 0; i < 3; i++) { const alpha = 0.12 - i * 0.03; const expand = i * (radiusPx * 0.08); ctx.beginPath(); ctx.moveTo(0, 0); ctx.arc(0, 0, radiusPx + expand, -Math.PI / 2 - half, -Math.PI / 2 + half); ctx.closePath(); ctx.globalAlpha = Math.max(0.02, alpha); ctx.fillStyle = isBlocked ? '#e74c3c' : '#1abc9c'; ctx.fill(); ctx.strokeStyle = isBlocked ? '#c0392b' : '#16a085'; ctx.lineWidth = Math.max(1, s * 0.8); ctx.stroke(); } ctx.restore(); } } catch (_) { } try { const ov = (r && r.overlaps) || null; if (ov && Array.isArray(ov.radar)) { for (const item of ov.radar) { const pts = Array.isArray(item.points) ? item.points : []; if (pts.length >= 3) { ctx.save(); ctx.beginPath(); const p0 = worldToScreen(pts[0].x, pts[0].y); ctx.moveTo(p0.x, p0.y); for (let i = 1; i < pts.length; i++) { const pi = worldToScreen(pts[i].x, pts[i].y); ctx.lineTo(pi.x, pi.y); } ctx.closePath(); ctx.globalAlpha = 0.18; ctx.fillStyle = '#f39c12'; ctx.fill(); ctx.strokeStyle = '#d35400'; ctx.lineWidth = Math.max(1, s * 0.8); ctx.stroke(); ctx.restore(); } } } if (ov && Array.isArray(ov.safety)) { for (const item of ov.safety) { const pts = Array.isArray(item.points) ? item.points : []; if (pts.length >= 3) { ctx.save(); ctx.beginPath(); const p0 = worldToScreen(pts[0].x, pts[0].y); ctx.moveTo(p0.x, p0.y); for (let i = 1; i < pts.length; i++) { const pi = worldToScreen(pts[i].x, pts[i].y); ctx.lineTo(pi.x, pi.y); } ctx.closePath(); ctx.globalAlpha = 0.20; ctx.fillStyle = '#e74c3c'; ctx.fill(); ctx.strokeStyle = '#c0392b'; ctx.lineWidth = Math.max(1, s * 0.8); ctx.stroke(); ctx.restore(); } } } } catch (_) { } }

function resetView() { fitMapToView(); drawMap(); } function toggleGrid() { showGrid = !showGrid; drawMap(); }
function toggleSidebar() { const s = document.getElementById('sidebar'), t = document.getElementById('sidebarToggle'), c = document.getElementById('canvasContainer'); sidebarOpen = !sidebarOpen; if (sidebarOpen) { s.classList.add('open'); c.classList.add('sidebar-open'); t.classList.add('open'); t.textContent = '收起'; } else { s.classList.remove('open'); c.classList.remove('sidebar-open'); t.classList.remove('open'); t.textContent = '打开'; } setTimeout(resizeCanvas, 400); }
function switchTab(name) { document.querySelectorAll('.tab-button').forEach(b => b.classList.remove('active')); document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active')); if (name === 'register') { document.querySelector('.tab-button[onclick="switchTab(\'register\')"]').classList.add('active'); document.getElementById('registerTab').classList.add('active'); updateRegisterMapOptions(); } else if (name === 'list') { document.querySelector('.tab-button[onclick="switchTab(\'list\')"]').classList.add('active'); document.getElementById('listTab').classList.add('active'); } else { document.querySelector('.tab-button[onclick="switchTab(\'equip\')"]').classList.add('active'); document.getElementById('equipTab').classList.add('active'); loadEquipmentList(); } }
async function loadRobotList() { try { const resp = await fetch(`${API_BASE_URL}/agvs`); if (!resp.ok) throw new Error(`HTTP ${resp.status}: ${resp.statusText}`); const agvs = await resp.json(); registeredRobots = (agvs || []).map(info => ({ robot_name: info.serial_number, type: info.type, ip: info.IP, manufacturer: info.manufacturer, vda_version: info.vda_version, battery: 100, initialPosition: null, currentPosition: null, currentMap: null, commConnected: false, instanceStatus: '停止', lastUpdateTs: 0, hasPallet: false, forkHeight: 0 })); updateRobotList(); drawMap(); } catch (err) { console.error('加载机器人列表失败:', err); document.getElementById('status').textContent = '加载机器人列表失败: ' + err.message; } }
function clearRobotForm() { document.getElementById('robotName').value = ''; document.getElementById('robotType').value = 'AGV'; document.getElementById('robotIP').value = ''; const regMapSel = document.getElementById('registerMapSelect'); if (regMapSel) regMapSel.value = ''; const lbl = document.getElementById('registerMapSelectedLabel'); if (lbl) lbl.textContent = '未设置'; const sel = document.getElementById('initialPosition'); if (sel) { sel.innerHTML = '<option value="">请先选择地图</option>'; sel.disabled = true; } }
let equipments = []; async function loadEquipmentList() { try { const resp = await fetch(`${API_BASE_URL}/equipments`); if (!resp.ok) throw new Error(`HTTP ${resp.status}: ${resp.statusText}`); equipments = await resp.json(); updateEquipmentList(); } catch (err) { console.error('加载设备列表失败:', err); const el = document.getElementById('status'); if (el) el.textContent = '加载设备列表失败: ' + err.message; } }
function updateEquipmentList() { const c = document.getElementById('equipListContainer'); if (!c) return; const list = Array.isArray(equipments) ? equipments : []; if (list.length === 0) { c.innerHTML = '<p style="color:#bdc3c7;font-style:italic;">暂无设备</p>'; try { ensureDoorOverlays(); updateDoorOverlayPositions(); ensureElevatorOverlays(); updateElevatorOverlayPositions(); } catch (_) { } return; } c.innerHTML = list.map(eq => { const mqtt = eq.mqtt || {}; const title = (eq.serial_number || eq.dir_name || '设备'); const eqType = getEquipmentType(eq); const siteStr = Array.isArray(eq.site) ? eq.site.join(',') : (eq.site || '-'); const line1 = `类型: ${eqType} | IP: ${eq.ip || '-'} | 厂商: ${eq.manufacturer || '-'}`; const line2 = `站点: ${siteStr} | 地图: ${eq.map_id || '-'}`; const line3 = `动作时长: ${typeof eq.action_time !== 'undefined' && eq.action_time !== null ? String(eq.action_time) : '-'} | 触发模式: ${eq.trigger_mode || '-'}`; const line4 = `MQTT: ${mqtt.host || '-'}:${mqtt.port || '-'} (${mqtt.vda_interface || '-'}) | 版本: ${eq.vda_full_version || eq.vda_version || '-'}`; const dir = String(eq.dir_name || eq.dirName || eq.serial_number || '').trim(); const controlsHtml = (eqType === 'door' && dir) ? `<div class="equip-door-controls"><button class="btn" onclick="equipPostInstant('${dir}', buildEquipAction('cmd:open'))">开门</button><button class="btn" onclick="equipPostInstant('${dir}', buildEquipAction('cmd:close'))">关门</button></div>` : ''; return `<div class=\"robot-item\"><div class=\"robot-header\"><div class=\"robot-name\">${title}</div></div><div class=\"robot-info\" style=\"word-break:break-all;\">${line1}<br>${line2}<br>${line3}<br>${line4}</div>${controlsHtml}</div>`; }).join(''); try { ensureDoorOverlays(); updateDoorOverlayPositions(); ensureElevatorOverlays(); updateElevatorOverlayPositions(); } catch (_) { } }
function getEquipmentType(eq) { const t = String(eq?.type || '').toLowerCase(); if (t) return t; const nm = String(eq?.name || eq?.dir_name || '').toLowerCase(); if (nm.includes('door')) return 'door'; if (nm.includes('elevator')) return 'elevator'; if (nm.includes('light')) return 'light'; if (nm.includes('caller')) return 'caller'; return 'device'; }
const doorOverlayMap = new Map(); function ensureDoorOverlays() { const layer = document.getElementById('equipOverlayLayer'); if (!layer) return; const list = Array.isArray(equipments) ? equipments : []; for (const eq of list) { if (getEquipmentType(eq) !== 'door') continue; const serial = String(eq.serial_number || eq.serialNumber || '').trim(); const dir = String(eq.dir_name || eq.dirName || serial || '').trim(); if (!serial) continue; if (doorOverlayMap.has(serial)) continue; const wrap = document.createElement('div'); wrap.className = 'equip-item equip-door'; wrap.style.position = 'absolute'; wrap.style.width = '90px'; wrap.style.pointerEvents = 'none'; wrap.dataset.serial = serial; wrap.dataset.dir = dir; const icon = document.createElement('div'); icon.className = 'double-door'; icon.id = 'doubleDoor_' + serial; const left = document.createElement('div'); left.className = 'door-left'; const lp = document.createElement('div'); lp.className = 'door-panel'; const lh = document.createElement('div'); lh.className = 'door-handle'; left.appendChild(lp); left.appendChild(lh); const right = document.createElement('div'); right.className = 'door-right'; const rp = document.createElement('div'); rp.className = 'door-panel'; const rh = document.createElement('div'); rh.className = 'door-handle'; right.appendChild(rp); right.appendChild(rh); icon.appendChild(left); icon.appendChild(right); wrap.appendChild(icon); layer.appendChild(wrap); doorOverlayMap.set(serial, { element: wrap, icon: icon, eq: eq }); } } function updateDoorOverlayPositions() { const layer = document.getElementById('equipOverlayLayer'); if (!layer) return; doorOverlayMap.forEach((entry, serial) => { const eq = entry.eq; const posInfo = computeDoorOverlayPos(eq); if (!posInfo || !posInfo.visible) { entry.element.style.display = 'none'; return; } entry.element.style.display = 'block'; entry.element.style.left = (posInfo.screen.x - 45) + 'px'; entry.element.style.top = (posInfo.screen.y - 45) + 'px'; entry.element.style.transform = 'rotate(' + posInfo.angleRad + 'rad)'; }); } function computeDoorOverlayPos(eq) { if (!mapData || !mapData.points) return null; let site = eq.site; if (typeof site === 'string') site = [site]; site = Array.isArray(site) ? site : []; const ids = site.map(s => String(s)).filter(s => s); const pmap = {}; (mapData.points || []).forEach(p => { pmap[String(p.id || p.name)] = p; }); const routes = Array.isArray(mapData.routes) ? mapData.routes : []; const routeById = {}; const routeByDesc = {}; routes.forEach(r => { routeById[String(r.id)] = r; if (r.desc) routeByDesc[String(r.desc)] = r; }); const matchedRoutes = []; ids.forEach(s => { const r1 = routeById[s]; if (r1) matchedRoutes.push(r1); else { const r2 = routeByDesc[s]; if (r2) matchedRoutes.push(r2); } }); const pts = ids.map(id => pmap[id]).filter(Boolean); if (matchedRoutes.length < 2) { pts.forEach(pt => { if (!pt) return; const candidates = routes.filter(r => String(r.from) === String(pt.id || pt.name) || String(r.to) === String(pt.id || pt.name)); if (candidates.length > 0) matchedRoutes.push(candidates.sort((a, b) => { const pa = pmap[String(a.from)], qa = pmap[String(a.to)]; const pb = pmap[String(b.from)], qb = pmap[String(b.to)]; const la = (pa && qa) ? Math.hypot(qa.x - pa.x, qa.y - pa.y) : Infinity; const lb = (pb && qb) ? Math.hypot(qb.x - pb.x, pb.y - pb.y) : Infinity; return la - lb; })[0]); }); } if (matchedRoutes.length < 2 && routes.length >= 2) { matchedRoutes.push(routes[0], routes[1]); } const currentFloorName = floorNames[currentFloorIndex] || null; let anyPoint = pts[0] || (matchedRoutes[0] ? pmap[String(matchedRoutes[0].from)] : null); if (anyPoint) { const pfloor = extractFloorNameFromLayer(anyPoint.layer || ''); if (currentFloorName && pfloor && String(pfloor).trim().toLowerCase() !== String(currentFloorName).trim().toLowerCase()) return { visible: false }; } const midpoints = []; for (let i = 0; i < Math.min(2, matchedRoutes.length); i++) { const r = matchedRoutes[i]; if (!r) continue; const p0 = pmap[String(r.from)], p1 = pmap[String(r.to)]; if (!p0 || !p1) continue; let mx = (p0.x + p1.x) / 2, my = (p0.y + p1.y) / 2; try { if (r.type === 'bezier3' && r.c1 && r.c2) { const bt = bezierPoint({ x: p0.x, y: p0.y }, { x: r.c1.x, y: r.c1.y }, { x: r.c2.x, y: r.c2.y }, { x: p1.x, y: p1.y }, 0.5); mx = bt.x; my = bt.y; } } catch (_) { } midpoints.push({ x: mx, y: my }); } let center = null; let ang = 0; if (midpoints.length >= 2) { const m0 = midpoints[0], m1 = midpoints[1]; center = { x: (m0.x + m1.x) / 2, y: (m0.y + m1.y) / 2 }; ang = Math.atan2((m1.y - m0.y), (m1.x - m0.x)) - Math.PI / 2; } else if (pts.length >= 2) { const a = pts[0], b = pts[1]; center = { x: (a.x + b.x) / 2, y: (a.y + b.y) / 2 }; ang = Math.atan2((b.y - a.y), (b.x - a.x)) - Math.PI / 2; } else if (pts.length === 1) { const a = pts[0]; center = { x: a.x, y: a.y }; ang = 0; } if (!center) return null; const sp = worldToScreen(center.x, center.y); return { screen: { x: sp.x, y: sp.y }, angleRad: ang, visible: true }; }
async function equipPostInstant(dirName, payload) { try { await fetch(`${API_BASE_URL}/equipments/${encodeURIComponent(dirName)}/instant`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) }); } catch (_) { } } function buildEquipAction(cmd) { return { "actions": [{ "actionType": "writeValue", "actionId": String(Math.random()), "blockingType": "HARD", "actionParameters": [{ "key": "command", "value": cmd }] }], "headerId": 0, "timeStamp": "", "version": "v1", "manufacturer": "", "serialNumber": "" }; }
function applyEquipmentWSState(p) { try { const sn = String(p.serial_number || p.serialNumber || '').trim(); const info = Array.isArray(p.information) ? p.information : []; const doorInfo = info.find(i => String(i.infoType || i.info_type || '').toUpperCase() === 'DOORSTATE'); if (!sn || !doorInfo) return; const refs = Array.isArray(doorInfo.infoReferences || doorInfo.info_references) ? (doorInfo.infoReferences || doorInfo.info_references) : []; const vals = refs.filter(r => String(r.referenceKey || r.reference_key || '') === 'value').map(r => String(r.referenceValue || r.reference_value || '')); const open = vals.includes('state:open'); const reg = doorOverlayMap.get(sn); if (reg && reg.icon) { if (open) { reg.icon.classList.add('door-open'); } else { reg.icon.classList.remove('door-open'); } } } catch (_) { } }
function applyEquipmentElevatorWSState(p) { try { const sn = String(p.serial_number || p.serialNumber || '').trim(); const info = Array.isArray(p.information) ? p.information : []; if (!sn) return; const elevInfo = info.find(i => String(i.infoType || i.info_type || '').toUpperCase() === 'ELEVATORSTATE'); if (!elevInfo) return; const refs = Array.isArray(elevInfo.infoReferences || elevInfo.info_references) ? (elevInfo.infoReferences || elevInfo.info_references) : []; const vals = refs.filter(r => String(r.referenceKey || r.reference_key || '') === 'value').map(r => String(r.referenceValue || r.reference_value || '')); const doorOpen = vals.includes('state:open'); const isUp = vals.includes('state:up'); const isDown = vals.includes('state:down'); let floorVal = 1; const f = vals.find(v => v.startsWith('state:floor:')); if (f) { const n = Number(f.split(':').pop()); if (Number.isFinite(n)) floorVal = n; } const reg2 = elevatorOverlayMap.get(sn); if (reg2) { if (doorOpen) reg2.door.classList.add('door-open'); else reg2.door.classList.remove('door-open'); if (reg2.floor) reg2.floor.textContent = String(floorVal); if (reg2.up) reg2.up.classList.toggle('active', !!isUp); if (reg2.down) reg2.down.classList.toggle('active', !!isDown); } } catch (_) { } }
async function updateRegisterMapOptions() { const sel = document.getElementById('registerMapSelect'); if (!sel) return; sel.innerHTML = '<option value="">请选择地图</option>'; try { const resp = await fetch(`${API_BASE_URL}/maps`); if (!resp.ok) throw new Error(`HTTP ${resp.status}: ${resp.statusText}`); const files = await resp.json(); (files || []).forEach(name => { const opt = document.createElement('option'); opt.value = name; opt.textContent = name; sel.appendChild(opt); }); if (CURRENT_MAP_ID && CURRENT_MAP_ID.startsWith('VehicleMap/')) { sel.value = CURRENT_MAP_ID; } } catch (err) { console.error('加载地图列表失败:', err); const opt = document.createElement('option'); opt.value = CURRENT_MAP_ID; opt.textContent = `已加载地图 (${CURRENT_MAP_ID})`; sel.appendChild(opt); sel.value = CURRENT_MAP_ID; } const mapLabel = document.getElementById('registerMapSelectedLabel'); if (mapLabel) mapLabel.textContent = sel.value || '未设置'; updateRegisterInitialPositionOptions(); }
async function updateRegisterInitialPositionOptions() { const sel = document.getElementById('initialPosition'); const selMap = document.getElementById('registerMapSelect'); const chosen = selMap ? selMap.value : ''; sel.innerHTML = ''; const placeholder = document.createElement('option'); placeholder.value = ''; placeholder.textContent = (typeof chosen === 'string' && /(^|\/)VehicleMap\/[^\/]+\.scene$/.test(chosen)) ? '站点加载中...' : '请先选择地图'; sel.appendChild(placeholder); sel.disabled = true; if (!chosen || !(/(^|\/)VehicleMap\/[^\/]+\.scene$/.test(chosen))) { return; } const fname = String(chosen).split('/').pop(); window.registerSceneStationsCache = window.registerSceneStationsCache || {}; let stations = window.registerSceneStationsCache[fname]; if (!stations) { try { const resp = await fetch(`/maps/VehicleMap/${encodeURIComponent(fname)}`); if (!resp.ok) throw new Error(`站点获取失败: ${resp.status}`); const data = await resp.json(); const allowedPrefixes = ['AP', 'CP', 'PP', 'LM', 'WP']; const startsAllowed = (txt) => allowedPrefixes.some(pref => String(txt || '').trim().startsWith(pref)); const root = Array.isArray(data) ? data[0] : data; const points = (root && Array.isArray(root.points)) ? root.points : []; stations = points.filter(p => { const nm = String(p.name || p.id || '').trim(); return nm && startsAllowed(nm); }).map(p => ({ id: String(p.id || p.name), instanceName: String(p.name || p.id), pointName: String(p.name || p.id), pos: { x: Number(p.x), y: Number(p.y) } })); window.registerSceneStationsCache[fname] = stations; } catch (e) { stations = []; } } sel.innerHTML = '<option value="">选择初始位置</option>'; stations.forEach(s => { const id = String(s.id || s.instanceName || s.pointName); const name = String(s.instanceName || s.pointName || id); const px = (s && s.pos && typeof s.pos.x !== 'undefined') ? Number(s.pos.x) : Number(s.x); const py = (s && s.pos && typeof s.pos.y !== 'undefined') ? Number(s.pos.y) : Number(s.y); const opt = document.createElement('option'); opt.value = id; opt.textContent = `${name} (${isFinite(px) ? px.toFixed(2) : 'NaN'}, ${isFinite(py) ? py.toFixed(2) : 'NaN'})`; sel.appendChild(opt); }); sel.disabled = false; }
async function registerRobot() { const name = document.getElementById('robotName').value.trim(); const type = document.getElementById('robotType').value; const ip = document.getElementById('robotIP').value.trim(); const manu = document.getElementById('robotManufacturer').value.trim() || 'SEER'; const ver = document.getElementById('robotVersion').value.trim() || 'v2'; const initId = document.getElementById('initialPosition').value; const mapVal = document.getElementById('registerMapSelect').value; if (!name) { try { window.printErrorToStatus('请输入机器人名称', '注册'); } catch (_) { } return; } if (!ip) { try { window.printErrorToStatus('请输入机器人IP地址', '注册'); } catch (_) { } return; } if (!initId) { try { window.printErrorToStatus('请选择初始位置', '注册'); } catch (_) { } return; } const ipRegex = /^(\d{1,3}\.){3}\d{1,3}$/; if (!ipRegex.test(ip)) { try { window.printErrorToStatus('请输入有效的IP地址格式', '注册'); } catch (_) { } return; } const payload = [{ serial_number: name, manufacturer: manu, type: type, vda_version: ver, IP: ip }]; try { const resp = await fetch(`${API_BASE_URL}/agvs/register`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) }); if (!resp.ok) throw new Error(`HTTP ${resp.status}: ${resp.statusText}`); const result = await resp.json(); if ((result.registered || []).includes(name)) { await loadRobotList(); const robot = registeredRobots.find(r => r.robot_name === name); let pos = null; if (mapVal && /(^|\/)VehicleMap\/[^\/]+\.scene$/.test(mapVal)) { const fname = String(mapVal).split('/').pop(); window.registerSceneStationsCache = window.registerSceneStationsCache || {}; let stations = window.registerSceneStationsCache[fname]; if (!stations) { try { const sresp = await fetch(`/maps/VehicleMap/${encodeURIComponent(fname)}`); if (sresp.ok) { const data = await sresp.json(); const root = Array.isArray(data) ? data[0] : data; const points = (root && Array.isArray(root.points)) ? root.points : []; const allowedPrefixes = ['AP', 'CP', 'PP']; const startsAllowed = (txt) => allowedPrefixes.some(pref => String(txt || '').trim().toUpperCase().startsWith(pref)); stations = points.filter(p => startsAllowed(String(p.name || p.id || ''))).map(p => ({ id: String(p.id || p.name), instanceName: String(p.name || p.id), pointName: String(p.name || p.id), pos: { x: Number(p.x), y: Number(p.y) } })); } } catch (e) { } } } if (mapVal && /(^|\/)(VehicleMap|ViewerMap)\/[^\/]+\.scene$/.test(mapVal)) { const swBody = { map: mapVal }; if (initId) swBody.switch_point = initId; if (pos && isFinite(pos.x) && isFinite(pos.y)) { swBody.center_x = pos.x; swBody.center_y = pos.y; } try { const swResp = await fetch(`${API_BASE_URL}/agv/${encodeURIComponent(name)}/instant/switch-map`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(swBody) }); if (!swResp.ok) console.warn('注册后 switchMap 失败:', swResp.status); } catch (e) { console.warn('注册后 switchMap 异常:', e); } } if (robot && pos) { robot.initialPosition = pos; } clearRobotForm(); document.getElementById('status').textContent = `机器人 ${name} 注册成功`; setTimeout(() => document.getElementById('status').textContent = '准备就绪', 3000); } else { try { window.printErrorToStatus('注册失败: ' + JSON.stringify(result), '注册'); } catch (_) { } } } catch (err) { console.error('注册机器人失败:', err); try { window.printErrorToStatus('注册机器人失败: ' + (err && err.message ? err.message : String(err)), '注册'); } catch (_) { } document.getElementById('status').textContent = '注册失败: ' + (err && err.message ? err.message : String(err)); } }
async function removeRobot(serial) { if (!confirm('确定要删除这个机器人吗？')) return; try { const resp = await fetch(`${API_BASE_URL}/agvs/${serial}`, { method: 'DELETE' }); if (!resp.ok) throw new Error(`HTTP ${resp.status}: ${resp.statusText}`); await loadRobotList(); document.getElementById('status').textContent = '机器人已删除'; setTimeout(() => document.getElementById('status').textContent = '准备就绪', 2000); } catch (err) { console.error('删除机器人失败:', err); try { window.printErrorToStatus('删除机器人失败: ' + (err && err.message ? err.message : String(err)), '删除'); } catch (_) { } } }
function updateRobotList() { const c = document.getElementById('robotListContainer'); if (registeredRobots.length === 0) { c.innerHTML = '<p style="color:#bdc3c7;font-style:italic;">暂无注册的机器人</p>'; return; } c.innerHTML = registeredRobots.map(robot => { const battery = robot.battery || 0; const batteryText = truncateToOneDecimal(Number(battery)).toFixed(1); const pos = robot.currentPosition || robot.initialPosition; const posText = pos ? `当前位置: (${pos.x.toFixed(2)}, ${pos.y.toFixed(2)}) | 方向: ${(pos.theta || 0).toFixed(2)}` : '位置未知'; const selectedStyle = (selectedRobotId === robot.robot_name) ? 'border-left:4px solid #2ecc71;background:#3b4f63;' : ''; const commText = robot.commConnected ? '连接' : '断开'; const commColor = robot.commConnected ? '#00ff00' : '#ff0000'; const instStatus = robot.instanceStatus || '停止'; const instText = instStatus; const instColor = instStatus === '启动' ? '#00ff00' : '#ff0000'; const mapText = robot.currentMap ? robot.currentMap : '未设置'; const fhText = (typeof robot.forkHeight !== 'undefined' && robot.forkHeight !== null) ? `${truncateToOneDecimal(Number(robot.forkHeight)).toFixed(1)} m` : '-'; return `<div class=\"robot-item\" style=\"${selectedStyle}\" onclick=\"selectRobot('${robot.robot_name}')\"><div class=\"robot-header\"><div class=\"robot-name\">${robot.robot_name}</div></div><div class=\"robot-info\" style=\"word-break:break-all;\">类型: ${robot.type} | IP: ${robot.ip} | 厂商: ${robot.manufacturer || '未知'} | 地图: ${mapText}<br>${posText} | 叉高: ${fhText}<br><span style=\"color:${commColor}\">电量: ${batteryText}%</span> | <span style=\"color:${commColor}\">通信状态: ${commText}</span> | <span style=\"color:${instColor}\">实例状态: ${instText}</span></div><div class=\"robot-actions\"><button class=\"btn-small btn-danger\" onclick=\"removeRobot('${robot.robot_name}')\">删除</button><button class=\"btn-small btn-config-small\" onclick=\"openRobotConfig('${robot.robot_name}')\">配置</button></div></div>`; }).join(''); }

let currentConfigRobotId = null; async function openRobotConfig(id) { currentConfigRobotId = id; const robot = registeredRobots.find(r => r.robot_name === id); if (!robot) return; document.getElementById('configRobotName').value = robot.robot_name || ''; const t = robot.type || 'AGV'; document.getElementById('configRobotType').value = (t === 'Forklift' ? 'Fork' : (t === 'AMR' ? 'Load' : t)); await updateConfigMapOptions(); const selMap = document.getElementById('configMapSelect'); if (selMap) { selMap.addEventListener('change', () => { updateConfigInitialPositionOptions(); }); } if (robot.currentMap && robot.currentMap.startsWith('VehicleMap/')) { const exists = Array.from(selMap.options).some(o => o.value === robot.currentMap); if (exists) selMap.value = robot.currentMap; } const mapLabel = document.getElementById('configMapSelectedLabel'); if (mapLabel) mapLabel.textContent = robot.currentMap || '未设置'; document.getElementById('configRobotIP').value = robot.ip || ''; document.getElementById('configRobotManufacturer').value = robot.manufacturer || ''; document.getElementById('configRobotVersion').value = 'v2'; if (selMap && !selMap.value && robot.currentMap && /(^|\/)VehicleMap\/[^\/]+\.scene$/.test(robot.currentMap)) { selMap.value = robot.currentMap; } updateConfigInitialPositionOptions(); const pos = robot.currentPosition || robot.initialPosition || { x: 0, y: 0, theta: 0 }; document.getElementById('configBattery').value = robot.battery ?? 100; document.getElementById('configOrientation').value = pos.theta ?? 0; try { await prefillFactsheetPhysicalParams(robot); } catch (e) { } switchConfigTab('basic'); const modal = document.getElementById('configModal'); modal.style.display = 'flex'; }
function closeConfigModal() { const modal = document.getElementById('configModal'); modal.style.display = 'none'; currentConfigRobotId = null; }

async function updateConfigInitialPositionOptions() { const sel = document.getElementById('configInitialPosition'); const selMap = document.getElementById('configMapSelect'); const chosen = selMap ? selMap.value : ''; sel.innerHTML = ''; const placeholder = document.createElement('option'); placeholder.value = ''; placeholder.textContent = (typeof chosen === 'string' && /(^|\/)VehicleMap\/[^\/]+\.scene$/.test(chosen)) ? '站点加载中...' : '请先选择地图'; sel.appendChild(placeholder); sel.disabled = true; if (!chosen || !(/(^|\/)VehicleMap\/[^\/]+\.scene$/.test(chosen))) { return; } const fname = String(chosen).split('/').pop(); window.configSceneStationsCache = window.configSceneStationsCache || {}; let stations = window.configSceneStationsCache[fname]; if (!stations) { try { const resp = await fetch(`/maps/VehicleMap/${encodeURIComponent(fname)}`); if (!resp.ok) throw new Error(`站点获取失败: ${resp.status}`); const data = await resp.json(); const allowedPrefixes = ['AP', 'CP', 'PP', 'LM', 'WP']; const allowedClasses = new Set(['ActionPoint', 'LocationMark', 'ChargingPoint', 'ChargePoint', 'ParkingPoint', 'ParkPoint', 'WayPoint', 'Waypoint']); const startsAllowed = (txt) => allowedPrefixes.some(pref => String(txt || '').trim().startsWith(pref)); const root = Array.isArray(data) ? data[0] : data; const points = (root && Array.isArray(root.points)) ? root.points : []; stations = points.filter(p => { const nm = String(p.name || p.id || '').trim(); return nm && startsAllowed(nm); }).map(p => ({ id: String(p.id || p.name), instanceName: String(p.name || p.id), pointName: String(p.name || p.id), pos: { x: Number(p.x), y: Number(p.y) } })); window.configSceneStationsCache[fname] = stations; } catch (e) { stations = []; } } sel.innerHTML = '<option value="">选择初始位置</option>'; stations.forEach(s => { const id = String(s.id || s.instanceName || s.pointName); const name = String(s.instanceName || s.pointName || id); const px = (s && s.pos && typeof s.pos.x !== 'undefined') ? Number(s.pos.x) : Number(s.x); const py = (s && s.pos && typeof s.pos.y !== 'undefined') ? Number(s.pos.y) : Number(s.y); const opt = document.createElement('option'); opt.value = id; opt.textContent = `${name} (${isFinite(px) ? px.toFixed(2) : 'NaN'}, ${isFinite(py) ? py.toFixed(2) : 'NaN'})`; sel.appendChild(opt); }); sel.disabled = false; }

async function updateConfigMapOptions() { const sel = document.getElementById('configMapSelect'); if (!sel) return; sel.innerHTML = '<option value="">不变</option>'; try { const resp = await fetch(`${API_BASE_URL}/maps`); if (!resp.ok) throw new Error(`HTTP ${resp.status}: ${resp.statusText}`); const files = await resp.json(); (files || []).forEach(name => { const opt = document.createElement('option'); opt.value = name; opt.textContent = name; sel.appendChild(opt); }); const robot = registeredRobots.find(r => r.robot_name === currentConfigRobotId); if (robot && robot.currentMap && robot.currentMap.startsWith('VehicleMap/')) { const exists = Array.from(sel.options).some(o => o.value === robot.currentMap); if (exists) sel.value = robot.currentMap; } } catch (err) { const opt = document.createElement('option'); opt.value = CURRENT_MAP_ID; opt.textContent = `已加载地图 (${CURRENT_MAP_ID})`; sel.appendChild(opt); sel.value = CURRENT_MAP_ID; } const mapLabel = document.getElementById('configMapSelectedLabel'); if (mapLabel) { const robot = registeredRobots.find(r => r.robot_name === currentConfigRobotId); mapLabel.textContent = (robot && robot.currentMap) ? robot.currentMap : '未设置'; } }

async function saveConfig() { const id = currentConfigRobotId; if (!id) { closeConfigModal(); return; } const robot = registeredRobots.find(r => r.robot_name === id); if (!robot) { closeConfigModal(); return; } const newName = document.getElementById('configRobotName').value.trim(); const newType = document.getElementById('configRobotType').value; const newIP = document.getElementById('configRobotIP').value.trim(); const newManu = document.getElementById('configRobotManufacturer').value.trim(); const newVer = document.getElementById('configRobotVersion').value.trim() || 'v2'; const battery = parseInt(document.getElementById('configBattery').value, 10); const orientation = parseFloat(document.getElementById('configOrientation').value); const initId = document.getElementById('configInitialPosition').value; const mapVal = document.getElementById('configMapSelect').value; const n = (v) => { const x = Number(v); return isFinite(x) ? x : undefined; }; const phys = { speedMin: n(document.getElementById('factsheetSpeedMin').value), speedMax: n(document.getElementById('factsheetSpeedMax').value), accelerationMax: n(document.getElementById('factsheetAccelMax').value), decelerationMax: n(document.getElementById('factsheetDecelMax').value), heightMin: n(document.getElementById('factsheetHeightMin').value), heightMax: n(document.getElementById('factsheetHeightMax').value), width: n(document.getElementById('factsheetWidth').value), length: n(document.getElementById('factsheetLength').value) }; let pos = robot.currentPosition || robot.initialPosition || { x: 0, y: 0, theta: 0 }; if (initId) { if (mapVal && /(^|\/)VehicleMap\/[^\/]+\.scene$/.test(mapVal)) { const fname = String(mapVal).split('/').pop(); window.configSceneStationsCache = window.configSceneStationsCache || {}; let stations = window.configSceneStationsCache[fname]; if (!stations) { try { const resp = await fetch(`/maps/VehicleMap/${encodeURIComponent(fname)}`); if (resp.ok) { const data = await resp.json(); const root = Array.isArray(data) ? data[0] : data; const points = (root && Array.isArray(root.points)) ? root.points : []; const allowedPrefixes = ['AP', 'CP', 'PP', 'LM', 'WP']; const startsAllowed = (txt) => allowedPrefixes.some(pref => String(txt || '').trim().toUpperCase().startsWith(pref)); stations = points.filter(p => startsAllowed(String(p.name || p.id || ''))).map(p => ({ id: String(p.id || p.name), instanceName: String(p.name || p.id), pointName: String(p.name || p.id), pos: { x: Number(p.x), y: Number(p.y) } })); } } catch (e) { } } const s = (stations || []).find(x => String(x.id || x.instanceName || x.pointName) === initId); if (s) { const px = (s && s.pos && typeof s.pos.x !== 'undefined') ? Number(s.pos.x) : Number(s.x); const py = (s && s.pos && typeof s.pos.y !== 'undefined') ? Number(s.pos.y) : Number(s.y); if (!isFinite(px) || !isFinite(py)) { try { window.printErrorToStatus('站点坐标无效，无法保存配置', '配置'); } catch (_) { } return; } pos = { x: px, y: py, theta: isNaN(orientation) ? 0 : orientation }; } } else { const point = (mapData?.points || []).find(p => p.id === initId); if (point) { pos = { x: point.x, y: point.y, theta: isNaN(orientation) ? 0 : orientation }; } } } else { pos = { x: pos.x, y: pos.y, theta: isNaN(orientation) ? (pos.theta || 0) : orientation }; } try { if (newIP && newIP !== robot.ip) { const sResp = await fetch(`${API_BASE_URL}/agv/${id}/config/static`, { method: 'PATCH', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ IP: newIP }) }); if (!sResp.ok) throw new Error(`静态配置更新失败: HTTP ${sResp.status}`); robot.ip = newIP; } if (mapVal && /(^|\/)(VehicleMap|ViewerMap)\/[^\/]+\.scene$/.test(mapVal)) { const swBody = { map: mapVal }; if (initId) swBody.switch_point = initId; if (isFinite(pos?.x) && isFinite(pos?.y)) { swBody.center_x = pos.x; swBody.center_y = pos.y; } if (!isNaN(orientation)) swBody.initiate_angle = orientation; const swResp = await fetch(`${API_BASE_URL}/agv/${id}/instant/switch-map`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(swBody) }); if (!swResp.ok) throw new Error(`发布 switchMap 失败: HTTP ${swResp.status}`); } if (newType) robot.type = newType; if (newManu) robot.manufacturer = newManu; if (newVer) robot.version = newVer; try { await applyPhysicalParamsToMotionControl(id, phys); robot.motionParams = phys; } catch (e) { } try { await updateCollisionParameters(id, phys); robot.collisionParams = { width: phys.width, length: phys.length, heightMin: phys.heightMin, heightMax: phys.heightMax }; } catch (e) { } updateRobotList(); drawMap(); document.getElementById('status').textContent = `机器人 ${id} 已发送 switchMap 即时动作`; setTimeout(() => document.getElementById('status').textContent = '准备就绪', 2000); } catch (err) { console.error('更新配置失败:', err); try { window.printErrorToStatus('更新配置失败: ' + (err && err.message ? err.message : String(err)), '配置'); } catch (_) { } } finally { closeConfigModal(); } }
function switchConfigTab(tab) { const btnBasic = document.getElementById('configTabBtnBasic'); const btnPhysical = document.getElementById('configTabBtnPhysical'); const vBasic = document.getElementById('configTabBasic'); const vPhysical = document.getElementById('configTabPhysical'); const isBasic = tab === 'basic'; vBasic.style.display = isBasic ? 'block' : 'none'; vPhysical.style.display = isBasic ? 'none' : 'block'; btnBasic.style.background = isBasic ? '#34495e' : '#2b3b4b'; btnPhysical.style.background = isBasic ? '#2b3b4b' : '#34495e'; }
async function prefillFactsheetPhysicalParams(robot) { const setVal = (id, v) => { const el = document.getElementById(id); if (el && typeof v !== 'undefined' && v !== null) el.value = String(v); }; const defaults = { speedMin: 0.01, speedMax: 2, accelerationMax: 2, decelerationMax: 2, heightMin: 0.01, heightMax: 0.10, width: 0.745, length: 1.03 }; let cfg = null; try { const id = (robot && robot.robot_name) || selectedRobotId || (((registeredRobots || [])[0] && (registeredRobots || [])[0].robot_name) || ''); if (id) { const resp = await fetch(`${API_BASE_URL}/agv/${encodeURIComponent(id)}/sim/settings`); if (resp && resp.ok) { const s = await resp.json(); cfg = { speedMin: Number(s.speed_min ?? defaults.speedMin), speedMax: Number(s.speed_max ?? (typeof s.speed === 'number' ? s.speed : defaults.speedMax)), accelerationMax: Number(s.acceleration_max ?? defaults.accelerationMax), decelerationMax: Number(s.deceleration_max ?? defaults.decelerationMax), heightMin: Number(s.height_min ?? defaults.heightMin), heightMax: Number(s.height_max ?? defaults.heightMax), width: Number(s.width ?? defaults.width), length: Number(s.length ?? defaults.length) }; } } } catch (e) { } if (!cfg && robot && robot.motionParams) { cfg = Object.assign({}, defaults, robot.motionParams); } if (!cfg) { try { let resp = await fetch('/factsheet.json'); if (!resp || !resp.ok) resp = await fetch('../factsheet.json'); if (resp && resp.ok) { const data = await resp.json(); const p = (data && data.physicalParameters) ? data.physicalParameters : {}; cfg = { speedMin: Number(p.speedMin ?? defaults.speedMin), speedMax: Number(p.speedMax ?? defaults.speedMax), accelerationMax: Number(p.accelerationMax ?? defaults.accelerationMax), decelerationMax: Number(p.decelerationMax ?? defaults.decelerationMax), heightMin: Number(p.heightMin ?? defaults.heightMin), heightMax: Number(p.heightMax ?? defaults.heightMax), width: Number(p.width ?? defaults.width), length: Number(p.length ?? defaults.length) }; } } catch (e) { } } cfg = cfg || defaults; setVal('factsheetSpeedMin', cfg.speedMin); setVal('factsheetSpeedMax', cfg.speedMax); setVal('factsheetAccelMax', cfg.accelerationMax); setVal('factsheetDecelMax', cfg.decelerationMax); setVal('factsheetHeightMin', cfg.heightMin); setVal('factsheetHeightMax', cfg.heightMax); setVal('factsheetWidth', cfg.width); setVal('factsheetLength', cfg.length); }
async function applyPhysicalParamsToMotionControl(id, params) { const patch = {}; const n = (v) => { const x = Number(v); return isFinite(x) ? x : undefined; }; const sMin = n(params.speedMin), sMax = n(params.speedMax), aMax = n(params.accelerationMax), dMax = n(params.decelerationMax); if (typeof sMax !== 'undefined') { const candidate = Number(sMax); if (isFinite(candidate) && candidate >= 0 && candidate <= 2) { patch.speed = candidate; } } if (typeof sMin !== 'undefined') patch.speed_min = sMin; if (typeof sMax !== 'undefined') patch.speed_max = sMax; if (typeof aMax !== 'undefined') patch.acceleration_max = aMax; if (typeof dMax !== 'undefined') patch.deceleration_max = dMax; const hMin = n(params.heightMin), hMax = n(params.heightMax), w = n(params.width), l = n(params.length); if (typeof hMin !== 'undefined') patch.height_min = hMin; if (typeof hMax !== 'undefined') patch.height_max = hMax; if (typeof w !== 'undefined') patch.width = w; if (typeof l !== 'undefined') patch.length = l; const errs = []; if (typeof sMin !== 'undefined' && typeof sMax !== 'undefined' && sMin > sMax) errs.push('最小速度不能大于最大速度'); if (typeof patch.speed !== 'undefined') { if (!(patch.speed >= 0 && patch.speed <= 2)) errs.push('运行速度需在[0,2]范围内'); if (typeof sMin !== 'undefined' && patch.speed < sMin) errs.push('运行速度应不低于最小速度'); } if (errs.length) { try { window.printErrorToStatus('参数无效: ' + errs.join('; '), '配置'); } catch (_) { } return; } window.MOTION_LIMITS = { speedMin: sMin, speedMax: sMax, accelerationMax: aMax, decelerationMax: dMax }; if (Object.keys(patch).length > 0) { const resp = await fetch(`${API_BASE_URL}/agv/${encodeURIComponent(id)}/sim/settings`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(patch) }); if (!resp.ok) throw new Error(`HTTP ${resp.status}: ${resp.statusText}`); } }
async function updateCollisionParameters(id, params) { try { const robot = registeredRobots.find(r => r.robot_name === id); if (robot) { robot.collisionParams = { width: params.width, length: params.length, heightMin: params.heightMin, heightMax: params.heightMax }; } } catch (e) { } }

function initWebSocket() { try { const url = (location.protocol === 'https:' ? 'wss' : 'ws') + '://' + location.host + '/ws'; ws = new WebSocket(url); ws.onopen = () => { document.getElementById('status').textContent = 'WS已连接'; setTimeout(() => document.getElementById('status').textContent = '准备就绪', 2000); }; ws.onmessage = (ev) => { try { const msg = JSON.parse(ev.data); if (msg && msg.type === 'mqtt_state' && msg.payload) { applyWSState(msg.payload); try { applyEquipmentWSState(msg.payload); } catch (_) { } } else if (msg && msg.type === 'mqtt_visualization' && msg.payload) { applyWSVisualization(msg.payload); } else if (msg && msg.type === 'mqtt_instantActions' && msg.payload) { try { handleWSInstantActions(msg.payload); } catch (e) { } } else if (msg && msg.type === 'pallet_action') { const serial = String(msg.serial || msg.serial_number || '').trim(); const op = String(msg.operation || '').trim(); const recfile = String(msg.recfile || '').trim(); if (serial && op) handlePalletAction(serial, op, recfile); } } catch (e) { } }; ws.onclose = () => { document.getElementById('status').textContent = 'WS断开，重连中...'; try { registeredRobots.forEach(r => { r.commConnected = false; r.instanceStatus = '断开'; }); updateRobotList(); } catch (e) { } setTimeout(initWebSocket, 1000); }; ws.onerror = () => { try { ws.close(); } catch (e) { } }; } catch (err) { } }
function handleWSInstantActions(payload) { try { const serial = String((payload && (payload.serial_number || payload.serialNumber)) || '').trim(); if (!serial) return; const robot = registeredRobots.find(r => r.robot_name === serial); if (!robot) return; const actions = Array.isArray(payload.actions) ? payload.actions : []; for (const a of actions) { const type = String((a && (a.action_type || a.actionType)) || '').trim(); const aid = String((a && (a.action_id || a.actionId)) || '').trim(); if (type.toLowerCase() === 'stoppause' && /^collision_stop_/i.test(aid)) { robot._collisionActive = true; } else if (type.toLowerCase() === 'startpause' && /^collision_start_/i.test(aid)) { robot._collisionActive = false; } } } catch (e) { } }
function truncateToOneDecimal(v) { const num = Number(v); if (!isFinite(num)) return 0; const t = Math.floor(num * 10) / 10; return Math.max(0, Math.min(100, t)); }
function applyWSState(stateMsg) { try { const payload = stateMsg || {}; const sn = String(payload.serial_number || payload.serialNumber || '').trim(); if (!sn) return; const robot = registeredRobots.find(r => r.robot_name === sn); if (!robot) return; const agvPos = payload.agv_position || payload.agvPosition || {}; const batt = payload.battery_state || payload.batteryState || {}; const fork = payload.fork_state || payload.forkState || {}; const mapId = (agvPos && (agvPos.map_id || agvPos.mapId)) || null; const px = Number(agvPos && agvPos.x); const py = Number(agvPos && agvPos.y); const th = Number(agvPos && (agvPos.theta ?? agvPos.orientation)); const bc = Number(batt && (batt.battery_charge || batt.batteryCharge)); if (isFinite(bc)) robot.battery = truncateToOneDecimal(bc); if (mapId) robot.currentMap = String(mapId); if (isFinite(px) && isFinite(py)) { robot.currentPosition = { x: px, y: py, theta: isFinite(th) ? th : (robot.currentPosition?.theta || 0) }; } const fh = Number(fork && (fork.fork_height ?? fork.forkHeight)); if (isFinite(fh)) robot.forkHeight = fh; robot.instanceStatus = '启动'; robot.commConnected = true; robot.lastUpdateTs = Date.now(); try { const errs = Array.isArray(payload.errors) ? payload.errors : []; let collision = false; for (const e of errs) { const et = String((e && (e.errorType ?? e.error_type ?? e.code)) || '').trim(); const en = String((e && (e.errorName ?? e.error_name)) || '').trim().toLowerCase(); const ds = String((e && (e.errorDescription ?? e.message ?? e.reason)) || '').trim().toLowerCase(); if (et === '54231' || en === 'robotblocked' || ds.includes('robot is blocked')) { collision = true; break; } } robot._collisionActive = collision; robot.stateErrors = errs.map(e => ({ errorType: String(e.errorType ?? e.code ?? ''), errorName: String(e.errorName ?? e.type ?? '') })); } catch (_) { } try { const loads = Array.isArray(payload.loads) ? payload.loads : []; const has = loads.length > 0; let model = null; if (has) { const l0 = loads[0] || {}; const dim = l0.loadDimensions || l0.load_dimensions || {}; const w = Number(dim && (dim.width_m ?? dim.width)); const l = Number(dim && (dim.length_m ?? dim.length)); const h = Number(dim && (dim.height_m ?? dim.height)); if (isFinite(w) && isFinite(l)) { model = { footprint: { width_m: w, length_m: l, height_m: (isFinite(h) ? h : undefined) } }; } } const curId = has ? String((loads[0] && (loads[0].loadId ?? loads[0].load_id)) || '') : ''; const lastId = String(robot._lastLoadId || ''); robot._lastLoadId = curId; const prevHas = !!robot._lastHasLoad; robot._lastHasLoad = has; if (has) { if (model) robot.shelfModel = model; if (!robot.hasPallet && !robot._palletAnimLoading && !robot._palletAnimUnloading) { loadPallet(sn); } else if (!prevHas && !robot._palletAnimLoading) { loadPallet(sn); } } else { if ((robot.hasPallet || robot._palletAnimLoading || prevHas) && !robot._palletAnimUnloading) { unloadPallet(sn); } } } catch (_) { } } catch (e) { } }
async function fetchShelfModel(recfile) { try { let path = String(recfile || '').trim(); if (!path) return null; path = path.replace(/\\/g, '/'); let url = ''; if (/^\/shelf\//i.test(path)) { url = path; } else if (/\/shelf\//i.test(path)) { url = path.substring(path.toLowerCase().indexOf('/shelf/')); } else if (/\.shelf$/i.test(path)) { const name = path.split('/').pop(); url = '/shelf/' + name; } else { const base = path.split('/').pop(); url = '/shelf/' + base; } if (!url.startsWith('/')) url = '/' + url; const resp = await fetch(url); if (!resp.ok) return null; return await resp.json(); } catch (_) { return null; } }
async function handlePalletAction(serial, operation, recfile) { const robot = registeredRobots.find(r => r.robot_name === serial); if (!robot) return; const key = String(operation || '') + '|' + String(recfile || ''); if (robot._lastPalletOpKey === key) return; robot._lastPalletOpKey = key; if (String(operation).toLowerCase() === 'pick') { const model = await fetchShelfModel(recfile); robot.shelfModel = model || null; loadPallet(serial); } else if (String(operation).toLowerCase() === 'drop') { unloadPallet(serial); } }
let renderTimer = null; let lastListUpdate = 0; function startRenderLoop() { if (renderTimer) return; renderTimer = setInterval(() => { try { drawMap(); } catch (e) { } const now = Date.now(); if (now - lastListUpdate > 250) { lastListUpdate = now; try { updateRobotList(); } catch (e) { } } }, 10); }
function applyStatusUpdates(list) { (list || []).forEach(st => { const robot = registeredRobots.find(r => r.robot_name === st.serial_number); if (robot) { if (st.battery_level !== undefined && st.battery_level !== null) { const bc = Number(st.battery_level); if (isFinite(bc)) robot.battery = truncateToOneDecimal(bc); } robot.currentPosition = st.position || robot.currentPosition; robot.currentMap = st.current_map || robot.currentMap; robot.instanceStatus = (st.status === 'running') ? '启动' : '停止'; robot.commConnected = true; robot.lastUpdateTs = Date.now(); } }); }
async function fetchRobotStatus(id) { try { const resp = await fetch(`${API_BASE_URL}/agv/${encodeURIComponent(id)}/status`); if (!resp.ok) return; const st = await resp.json(); const robot = registeredRobots.find(r => r.robot_name === (st.serial_number || id)); if (!robot) return; if (st.battery_level !== undefined && st.battery_level !== null) { const bc = Number(st.battery_level); if (isFinite(bc)) robot.battery = truncateToOneDecimal(bc); } if (st.current_map) { robot.currentMap = st.current_map; } if (st.position && typeof st.position.x !== 'undefined' && typeof st.position.y !== 'undefined') { const px = Number(st.position.x); const py = Number(st.position.y); const th = Number(st.position.theta ?? 0); if (isFinite(px) && isFinite(py)) { robot.currentPosition = { x: px, y: py, theta: isFinite(th) ? th : (robot.currentPosition?.theta || 0) }; } } robot.instanceStatus = (st.status === 'running') ? '启动' : '停止'; robot.commConnected = true; robot.lastUpdateTs = Date.now(); } catch (_) { } }
async function pollAllRobotStatus() { const ids = registeredRobots.map(r => r.robot_name); if (ids.length === 0) return; await Promise.all(ids.map(id => fetchRobotStatus(id))); updateRobotList(); drawMap(); }
async function selectRobot(id) { selectedRobotId = id; updateRobotList(); }
function setupKeyboardControl() { window.addEventListener('keydown', function (e) { const tag = document.activeElement && document.activeElement.tagName; if (tag && ['INPUT', 'TEXTAREA', 'SELECT'].includes(tag)) return; if (!selectedRobotId) return; const key = e.key.toLowerCase(); if (key === 'w') { moveForward(selectedRobotId); } else if (key === 's') { moveBackward(selectedRobotId); } else if (key === 'a') { rotateLeft(selectedRobotId); } else if (key === 'd') { rotateRight(selectedRobotId); } }); }
async function moveBackward(id) { const step = 0.1; const robot = registeredRobots.find(r => r.robot_name === id); const pos = robot?.currentPosition || robot?.initialPosition || { x: 0, y: 0, theta: 0 }; const heading = (pos.theta ?? pos.orientation ?? 0); const dx = step * Math.cos(heading); const dy = step * Math.sin(heading); try { const resp = await fetch(`${API_BASE_URL}/agv/${id}/move/translate`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ dx, dy, movement_state: 'backward' }) }); if (!resp.ok) throw new Error(`HTTP ${resp.status}: ${resp.statusText}`); } catch (err) { } }
async function moveForward(id) { const step = 0.1; const robot = registeredRobots.find(r => r.robot_name === id); const pos = robot?.currentPosition || robot?.initialPosition || { x: 0, y: 0, theta: 0 }; const heading = (pos.theta ?? pos.orientation ?? 0); const dx = -step * Math.cos(heading); const dy = -step * Math.sin(heading); try { const resp = await fetch(`${API_BASE_URL}/agv/${id}/move/translate`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ dx, dy, movement_state: 'forward' }) }); if (!resp.ok) throw new Error(`HTTP ${resp.status}: ${resp.statusText}`); } catch (err) { } }
async function rotateLeft(id) { const dtheta = 0.15; try { const resp = await fetch(`${API_BASE_URL}/agv/${id}/move/rotate`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ dtheta }) }); if (!resp.ok) throw new Error(`HTTP ${resp.status}: ${resp.statusText}`); } catch (err) { } }
async function rotateRight(id) { const dtheta = -0.15; try { const resp = await fetch(`${API_BASE_URL}/agv/${id}/move/rotate`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ dtheta }) }); if (!resp.ok) throw new Error(`HTTP ${resp.status}: ${resp.statusText}`); } catch (err) { } }

let commGuardTimer = null; function startCommStatusGuard() { if (commGuardTimer) return; commGuardTimer = setInterval(() => { const now = Date.now(); let changed = false; registeredRobots.forEach(r => { if (!r.lastUpdateTs || (now - r.lastUpdateTs > 5000)) { if (r.commConnected || r.instanceStatus === '启动') { r.commConnected = false; r.instanceStatus = '断开'; changed = true; } } }); if (changed) { updateRobotList(); drawMap(); } }, 1000); }

async function openSettingsModal() { const modal = document.getElementById('settingsModal'); modal.style.display = 'flex'; requestAnimationFrame(() => { const content = modal.querySelector('.modal-content'); if (content && !content.dataset.fixedHeight) { const rect = content.getBoundingClientRect(); content.style.height = rect.height + 'px'; content.style.maxHeight = rect.height + 'px'; content.dataset.fixedHeight = '1'; } }); try { const resp = await fetch(`${API_BASE_URL}/sim/settings`); if (resp && resp.ok) { const data = await resp.json(); prefillSimSettings(data); } } catch (e) { try { window.printErrorToStatus('读取当前仿真设置失败: ' + (e && e.message ? e.message : String(e)), '设置'); } catch (_) { } } }
function closeSettingsModal() { document.getElementById('settingsModal').style.display = 'none'; }
function prefillSimSettings(s) { const setVal = (id, v) => { const el = document.getElementById(id); if (el && typeof v !== 'undefined' && v !== null) el.value = String(v); }; setVal('settingsSpeed', s.speed); setVal('settingsTimeScale', s.sim_time_scale); setVal('settingsStateFreq', s.state_frequency); setVal('settingsVisFreq', s.visualization_frequency); setVal('settingsActionTime', s.action_time); setVal('settingsFrontendPoll', s.frontend_poll_interval_ms); setVal('settingsBatteryDefault', s.battery_default); setVal('settingsBatteryIdle', s.battery_idle_drain_per_min); setVal('settingsBatteryEmptyMult', s.battery_move_empty_multiplier); setVal('settingsBatteryLoadedMult', s.battery_move_loaded_multiplier); setVal('settingsBatteryCharge', s.battery_charge_per_min); }
async function saveSimSettings() { try { const patch = {}; const n = (v) => { const x = Number(v); return isFinite(x) ? x : undefined; }; const intIn = (x, a, b) => Number.isInteger(x) && x >= a && x <= b; const numIn = (x, a, b, openLeft = false, openRight = false) => { if (typeof x !== 'number' || !isFinite(x)) return false; const leftOk = openLeft ? (x > a) : (x >= a); const rightOk = openRight ? (x < b) : (x <= b); return leftOk && rightOk; }; const speed = n(document.getElementById('settingsSpeed').value); const ts = n(document.getElementById('settingsTimeScale').value); const sf = n(document.getElementById('settingsStateFreq').value); const vf = n(document.getElementById('settingsVisFreq').value); const at = n(document.getElementById('settingsActionTime').value); const fp = n(document.getElementById('settingsFrontendPoll').value); const bd = n(document.getElementById('settingsBatteryDefault').value); const bi = n(document.getElementById('settingsBatteryIdle').value); const be = n(document.getElementById('settingsBatteryEmptyMult').value); const bl = n(document.getElementById('settingsBatteryLoadedMult').value); const bc = n(document.getElementById('settingsBatteryCharge').value); const errs = []; if (typeof speed !== 'undefined') { if (!numIn(speed, 0, 2)) errs.push('速度需在[0,2]内'); else patch.speed = speed; } if (typeof ts !== 'undefined') { if (!numIn(ts, 0, 10)) errs.push('时间缩放需在(0,10)内'); else patch.sim_time_scale = ts; } if (typeof sf !== 'undefined') { if (!intIn(sf, 1, 10)) errs.push('状态频率需为[1,10]的正整数'); else patch.state_frequency = parseInt(sf, 10); } if (typeof vf !== 'undefined') { if (!intIn(vf, 1, 10)) errs.push('可视化频率需为[1,10]的正整数'); else patch.visualization_frequency = parseInt(vf, 10); } if (typeof at !== 'undefined') { if (!numIn(at, 1, 10)) errs.push('动作时长需在[1,10]内'); else patch.action_time = at; } if (typeof fp !== 'undefined') { if (!intIn(fp, 10, 1000)) errs.push('前端轮询间隔需为[10,1000]的正整数'); else patch.frontend_poll_interval_ms = parseInt(fp, 10); } if (typeof bd !== 'undefined') { if (!numIn(bd, 0, 100, true, false)) errs.push('默认电量需在(0,100]内'); else patch.battery_default = bd; } if (typeof bi !== 'undefined') { if (!numIn(bi, 1, 100)) errs.push('空闲耗电需在[1,100]内'); else patch.battery_idle_drain_per_min = bi; } if (typeof be !== 'undefined') { if (!numIn(be, 1, 100)) errs.push('空载耗电系数需在[1,100]内'); else patch.battery_move_empty_multiplier = be; } if (typeof bl !== 'undefined') { if (!numIn(bl, 1, 100)) errs.push('载重耗电系数需在[1,100]内'); else patch.battery_move_loaded_multiplier = bl; } if (typeof bc !== 'undefined') { if (!numIn(bc, 1, 100)) errs.push('充电速度需在[1,100]内'); else patch.battery_charge_per_min = bc; } if (errs.length) { try { window.printErrorToStatus('参数无效: ' + errs.join('; '), '设置'); } catch (_) { } return; } const resp = await fetch(`${API_BASE_URL}/sim/settings`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(patch) }); if (!resp.ok) throw new Error(`HTTP ${resp.status}: ${resp.statusText}`); if (patch.frontend_poll_interval_ms) { window.FRONTEND_POLL_INTERVAL_MS = patch.frontend_poll_interval_ms; } document.getElementById('status').textContent = '仿真设置已更新'; setTimeout(() => document.getElementById('status').textContent = '准备就绪', 2000); } catch (err) { try { window.printErrorToStatus('更新仿真设置失败: ' + (err && err.message ? err.message : String(err)), '设置'); } catch (_) { } return; } closeSettingsModal(); }

function computeDoorOverlayPosOverride(eq) { if (!mapData) return null; let site = eq.site; if (typeof site === 'string') site = [site]; site = Array.isArray(site) ? site : []; const ids = site.map(s => String(s)).filter(Boolean); const currentFloorName = floorNames[currentFloorIndex] || null; const equipFloor = extractFloorFromMapId(eq.map_id || ''); if (equipFloor && currentFloorName && String(equipFloor).trim().toLowerCase() !== String(currentFloorName).trim().toLowerCase()) return { visible: false }; const pmap = {}; (mapData.points || []).forEach(p => { pmap[String(p.id || p.name)] = p; }); const routes = Array.isArray(mapData.routes) ? mapData.routes : []; let route = null; for (const id of ids) { const r = routes.find(rt => String(rt.id || '') === id); if (r) { route = r; break; } } if (route) { const fp = pmap[String(route.from)]; const tp = pmap[String(route.to)]; if (!fp || !tp) return null; const nf = currentFloorName ? String(currentFloorName).trim().toLowerCase() : null; const ff = extractFloorNameFromLayer(fp.layer || ''); const tf = extractFloorNameFromLayer(tp.layer || ''); const ffn = ff ? String(ff).trim().toLowerCase() : ''; const tfn = tf ? String(tf).trim().toLowerCase() : ''; if (nf) { if (ffn && ffn !== nf) return { visible: false }; if (tfn && tfn !== nf) return { visible: false }; } let mid, ang; if (route.type === 'bezier3' && route.c1 && route.c2) { const t = 0.5; const p0 = { x: fp.x, y: fp.y }; const p1 = { x: route.c1.x, y: route.c1.y }; const p2 = { x: route.c2.x, y: route.c2.y }; const p3 = { x: tp.x, y: tp.y }; const bt = bezierPoint(p0, p1, p2, p3, t); const tg = bezierTangent(p0, p1, p2, p3, t); mid = { x: bt.x, y: bt.y }; const s0 = worldToScreen(p0.x, p0.y); const s1 = worldToScreen(p0.x + tg.x, p0.y + tg.y); ang = Math.atan2(s1.y - s0.y, s1.x - s0.x); } else { mid = { x: (fp.x + tp.x) / 2, y: (fp.y + tp.y) / 2 }; const s0 = worldToScreen(fp.x, fp.y); const s1 = worldToScreen(tp.x, tp.y); ang = Math.atan2(s1.y - s0.y, s1.x - s0.x); } const sp = worldToScreen(mid.x, mid.y); return { screen: { x: sp.x, y: sp.y }, angleRad: ang, visible: true }; } const pts = ids.map(id => pmap[id]).filter(Boolean); if (pts.length === 0) return null; const p0 = pts[0]; const pfloor = extractFloorNameFromLayer(p0.layer || ''); if (currentFloorName && pfloor && String(pfloor).trim().toLowerCase() !== String(currentFloorName).trim().toLowerCase()) return { visible: false }; let mid = { x: p0.x, y: p0.y }; let ang = 0; try { if (pts.length >= 2) { const p1 = pts[1]; mid = { x: (p0.x + p1.x) / 2, y: (p0.y + p1.y) / 2 }; const s0 = worldToScreen(p0.x, p0.y); const s1 = worldToScreen(p1.x, p1.y); ang = Math.atan2(s1.y - s0.y, s1.x - s0.x); } } catch (_) { } const sp = worldToScreen(mid.x, mid.y); return { screen: { x: sp.x, y: sp.y }, angleRad: ang, visible: true }; }
function computeDoorOverlayPosOverride2(eq) { if (!mapData || !mapData.points) return null; let site = eq.site; if (typeof site === 'string') site = [site]; site = Array.isArray(site) ? site : []; const ids = site.map(s => String(s)).filter(Boolean); const currentFloorName = floorNames[currentFloorIndex] || null; const equipFloor = extractFloorFromMapId(eq.map_id || ''); if (equipFloor && currentFloorName && String(equipFloor).trim().toLowerCase() !== String(currentFloorName).trim().toLowerCase()) return { visible: false }; const pmap = {}; (mapData.points || []).forEach(p => { pmap[String(p.id || p.name)] = p; }); const routes = Array.isArray(mapData.routes) ? mapData.routes : []; const routeById = {}; const routeByDesc = {}; routes.forEach(r => { routeById[String(r.id)] = r; if (r.desc) routeByDesc[String(r.desc)] = r; }); const matched = []; ids.forEach(s => { const r1 = routeById[s]; if (r1) matched.push(r1); else { const r2 = routeByDesc[s]; if (r2) matched.push(r2); } }); if (matched.length < 2) { const pts = ids.map(id => pmap[id]).filter(Boolean); pts.forEach(pt => { if (!pt) return; const candidates = routes.filter(r => String(r.from) === String(pt.id || pt.name) || String(r.to) === String(pt.id || pt.name)); if (candidates.length > 0) matched.push(candidates.sort((a, b) => { const pa = pmap[String(a.from)], qa = pmap[String(a.to)]; const pb = pmap[String(b.from)], qb = pmap[String(b.to)]; const la = (pa && qa) ? Math.hypot(qa.x - pa.x, qa.y - pa.y) : Infinity; const lb = (pb && qb) ? Math.hypot(qb.x - pb.x, qb.y - pb.y) : Infinity; return la - lb; })[0]); }); } if (matched.length < 2 && routes.length >= 2) { matched.push(routes[0], routes[1]); } let anyRoutePoint = null; if (matched[0]) { const rp = pmap[String(matched[0].from)]; const tp = pmap[String(matched[0].to)]; anyRoutePoint = rp || tp; } if (anyRoutePoint) { const pfloor = extractFloorNameFromLayer(anyRoutePoint.layer || ''); if (currentFloorName && pfloor && String(pfloor).trim().toLowerCase() !== String(currentFloorName).trim().toLowerCase()) return { visible: false }; } const mids = []; for (let i = 0; i < Math.min(2, matched.length); i++) { const r = matched[i]; if (!r) continue; const fp = pmap[String(r.from)]; const tp = pmap[String(r.to)]; if (!fp || !tp) continue; const mx = (fp.x + tp.x) / 2; const my = (fp.y + tp.y) / 2; mids.push({ x: mx, y: my }); } let center = null; let ang = 0; if (mids.length >= 2) { const m0 = mids[0], m1 = mids[1]; center = { x: (m0.x + m1.x) / 2, y: (m0.y + m1.y) / 2 }; const s0 = worldToScreen(m0.x, m0.y); const s1 = worldToScreen(m1.x, m1.y); const screenAngle = Math.atan2(s1.y - s0.y, s1.x - s0.x); ang = screenAngle; } else if (mids.length === 1) { const a = mids[0]; center = { x: a.x, y: a.y }; ang = 0; } else { const pts = ids.map(id => pmap[id]).filter(Boolean); if (pts.length >= 2) { const a = pts[0], b = pts[1]; center = { x: (a.x + b.x) / 2, y: (a.y + b.y) / 2 }; const sa = worldToScreen(a.x, a.y); const sb = worldToScreen(b.x, b.y); const screenAngle = Math.atan2(sb.y - sa.y, sb.x - sa.x); ang = screenAngle + Math.PI / 2; } else if (pts.length === 1) { const a = pts[0]; center = { x: a.x, y: a.y }; ang = 0; } } if (!center) return null; const sp = worldToScreen(center.x, center.y); return { screen: { x: sp.x, y: sp.y }, angleRad: ang, visible: true, worldCenter: center }; }
function updateDoorOverlayPositionsOverride() { const layer = document.getElementById('equipOverlayLayer'); if (!layer) return; const scaleFactor = Math.max(0.01, viewTransform.scale * 0.2); doorOverlayMap.forEach((entry) => { const eq = entry.eq; const posInfo = computeDoorOverlayPos(eq); if (!posInfo || !posInfo.visible) { entry.element.style.display = 'none'; return; } entry.element.style.display = 'block'; entry.element.style.left = posInfo.screen.x + 'px'; entry.element.style.top = posInfo.screen.y + 'px'; entry.element.style.transform = 'translate(-50%, -50%) rotate(' + posInfo.angleRad + 'rad) scale(' + scaleFactor + ')'; }); }
computeDoorOverlayPos = computeDoorOverlayPosOverride2;
updateDoorOverlayPositions = updateDoorOverlayPositionsOverride;
document.addEventListener('contextmenu', function (e) { e.preventDefault(); }, { capture: true });
const elevatorOverlayMap = new Map();
function ensureElevatorOverlays() {
  const layer = document.getElementById('equipOverlayLayer');
  if (!layer) return;
  const list = Array.isArray(equipments) ? equipments : [];
  for (const eq of list) {
    if (getEquipmentType(eq) !== 'elevator') continue;
    const serial = String(eq.serial_number || eq.serialNumber || '').trim();
    const dir = String(eq.dir_name || eq.dirName || serial || '').trim();
    if (!serial) continue;
    if (elevatorOverlayMap.has(serial)) continue;
    const wrap = document.createElement('div');
    wrap.className = 'equip-item equip-elevator';
    wrap.style.position = 'absolute';
    wrap.style.width = '90px';
    wrap.style.pointerEvents = 'none';
    wrap.dataset.serial = serial;
    wrap.dataset.dir = dir;
    const icon = document.createElement('div');
    icon.className = 'elevator';
    const door = document.createElement('div');
    door.className = 'elevator-door';
    door.id = 'elevatorDoor_' + serial;
    const dl = document.createElement('div');
    dl.className = 'door-left';
    const dr = document.createElement('div');
    dr.className = 'door-right';
    const gap = document.createElement('div');
    gap.className = 'door-gap';
    door.appendChild(dl);
    door.appendChild(dr);
    door.appendChild(gap);
    const interior = document.createElement('div');
    interior.className = 'elevator-interior';
    const pattern = document.createElement('div');
    pattern.className = 'interior-pattern';
    interior.appendChild(pattern);
    const panel = document.createElement('div');
    panel.className = 'control-panel';
    const floor = document.createElement('div');
    floor.className = 'floor-display';
    floor.id = 'floorDisplay_' + serial;
    floor.textContent = '1';
    const di = document.createElement('div');
    di.className = 'direction-indicator';
    const up = document.createElement('div');
    up.className = 'direction';
    up.id = 'up_' + serial;
    up.textContent = '↑';
    const down = document.createElement('div');
    down.className = 'direction';
    down.id = 'down_' + serial;
    down.textContent = '↓';
    di.appendChild(up);
    di.appendChild(down);
    panel.appendChild(floor);
    panel.appendChild(di);
    icon.appendChild(door);
    icon.appendChild(interior);
    icon.appendChild(panel);
    wrap.appendChild(icon);
    layer.appendChild(wrap);
    elevatorOverlayMap.set(serial, { element: wrap, icon, door, floor, up, down, eq });
  }
}
function updateElevatorOverlayPositions() {
  const layer = document.getElementById('equipOverlayLayer');
  if (!layer) return;
  const scaleFactor = Math.max(0.01, viewTransform.scale * 0.2);
  elevatorOverlayMap.forEach((entry) => {
    const posInfo = computeElevatorOverlayPos(entry.eq);
    if (!posInfo || !posInfo.visible) {
      entry.element.style.display = 'none';
      return;
    }
    entry.element.style.display = 'block';
    entry.element.style.left = posInfo.screen.x + 'px';
    entry.element.style.top = posInfo.screen.y + 'px';
    entry.element.style.transform = 'translate(-50%, -50%) rotate(' + posInfo.angleRad + 'rad) scale(' + scaleFactor + ')';
  });
}
function computeElevatorOverlayPos(eq) {
  if (!mapData || !mapData.points) return null;
  let site = eq.site;
  if (typeof site === 'string') site = [site];
  site = Array.isArray(site) ? site : [];
  const ids = site.map(s => String(s)).filter(Boolean);
  const currentFloorName = floorNames[currentFloorIndex] || null;
  const equipFloor = extractFloorFromMapId(eq.map_id || '');
  if (equipFloor && currentFloorName && String(equipFloor).trim().toLowerCase() !== String(currentFloorName).trim().toLowerCase()) return { visible: false };
  const pmap = {};
  (mapData.points || []).forEach(p => { pmap[String(p.id || p.name)] = p; });
  let point = null;
  for (const id of ids) { const p = pmap[id]; if (p) { point = p; break; } }
  if (!point) return null;
  const pfloor = extractFloorNameFromLayer(point.layer || '');
  if (currentFloorName && pfloor && String(pfloor).trim().toLowerCase() !== String(currentFloorName).trim().toLowerCase()) return { visible: false };
  const sp = worldToScreen(point.x, point.y);
  return { screen: { x: sp.x, y: sp.y }, angleRad: 0, visible: true };
}
(function(){
  const _origDrawMap = drawMap;
  drawMap = function(){
    try { _origDrawMap(); } catch (_) {}
    try { ensureElevatorOverlays(); updateElevatorOverlayPositions(); } catch (_) {}
  };
  const _origEqWS = applyEquipmentWSState;
  applyEquipmentWSState = function(p){
    try { _origEqWS(p); } catch (_) {}
    try {
      const sn = String(p.serial_number || p.serialNumber || '').trim();
      const info = Array.isArray(p.information) ? p.information : [];
      if (!sn) return;
      const elevInfo = info.find(i => String(i.infoType || i.info_type || '').toUpperCase() === 'ELEVATORSTATE');
      if (!elevInfo) return;
      const refs = Array.isArray(elevInfo.infoReferences || elevInfo.info_references) ? (elevInfo.infoReferences || elevInfo.info_references) : [];
      const vals = refs.filter(r => String(r.referenceKey || r.reference_key || '') === 'value').map(r => String(r.referenceValue || r.reference_value || ''));
      const doorOpen = vals.includes('state:open');
      const isUp = vals.includes('state:up');
      const isDown = vals.includes('state:down');
      let floorVal = 1;
      const f = vals.find(v => v.startsWith('state:floor:'));
      if (f) { const n = Number(f.split(':').pop()); if (Number.isFinite(n)) floorVal = n; }
      const reg2 = elevatorOverlayMap.get(sn);
      if (reg2) {
        if (doorOpen) reg2.door.classList.add('door-open'); else reg2.door.classList.remove('door-open');
        if (reg2.floor) reg2.floor.textContent = String(floorVal);
        if (reg2.up) reg2.up.classList.toggle('active', !!isUp);
        if (reg2.down) reg2.down.classList.toggle('active', !!isDown);
      }
    } catch (_) {}
  };
})();
