<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>AGV地图查看器</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      font-family: Arial, Helvetica, sans-serif;
      background: #f0f0f0;
      overflow: hidden
    }

    /* Settings Modal: 固定初始尺寸，内部滚动且隐藏滚动条 */
    #settingsModal .modal-content {
      display: flex;
      flex-direction: column;
      /* 宽度仍由原有 inline 样式控制，这里保证布局 */
      max-height: 72vh; /* 作为回退，JS 将在首次打开时锁定实际高度 */
    }
    #settingsModal .modal-header { flex: 0 0 auto; }
    #settingsModal .modal-body {
      flex: 1 1 auto;
      overflow: auto;
      overscroll-behavior: contain;
      box-sizing: border-box;
      /* 隐藏滚动条（仍可滚动） */
      scrollbar-width: none; /* Firefox */
      -ms-overflow-style: none; /* IE/Edge */
    }
    #settingsModal .modal-body::-webkit-scrollbar { width: 0; height: 0; }

    .header {
      background: #2c3e50;
      color: #fff;
      padding: 10px 20px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      box-shadow: 0 2px 4px rgba(0, 0, 0, .1)
    }

    .title {
      font-size: 20px;
      font-weight: bold
    }

    .controls {
      display: flex;
      gap: 10px;
      align-items: center
    }

    .btn {
      background: #3498db;
      color: #fff;
      border: none;
      padding: 8px 16px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px
    }

    .btn:hover {
      background: #2980b9
    }

    .status {
      font-size: 14px;
      color: #ecf0f1;
      max-width: 900px;
      overflow-x: auto;
      white-space: nowrap;
      scrollbar-width: none;
      -ms-overflow-style: none
    }
    .status::-webkit-scrollbar {
      display: none
    }

    .canvas-container {
      position: relative;
      width: 120vw;
      height: calc(100vh - 60px);
      overflow: hidden;
      background: #34495e;
      transition: margin-left .4s cubic-bezier(.25, .8, .25, 1)
    }

    .canvas-container.sidebar-open {
      margin-left: 300px
    }

    .sidebar {
      position: fixed;
      left: -400px;
      top: 0;
      width: 320px;
      height: 100vh;
      background: #2c3e50;
      color: #fff;
      padding: 20px;
      box-shadow: 2px 0 10px rgba(0, 0, 0, .3);
      transition: left .4s cubic-bezier(.25, .8, .25, 1);
      z-index: 1000;
      overflow-y: auto;
      display: flex;
      flex-direction: column
    }

    .sidebar.open {
      left: 0
    }

    .sidebar-header {
      padding: 0 0 20px 0;
      border-bottom: 1px solid #34495e;
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px
    }

    .sidebar-title {
      font-size: 18px;
      font-weight: bold
    }

    .sidebar-close {
      background: none;
      border: none;
      color: #fff;
      font-size: 20px;
      cursor: pointer;
      padding: 5px
    }

    .sidebar-tabs {
      display: flex;
      border-bottom: 1px solid #34495e;
      margin-bottom: 20px
    }

    .tab-button {
      flex: 1;
      background: none;
      border: none;
      color: #bdc3c7;
      padding: 12px 16px;
      cursor: pointer;
      font-size: 14px;
      transition: .3s;
      border-bottom: 2px solid transparent
    }

    .tab-button:hover {
      color: #ecf0f1;
      background: rgba(52, 73, 94, .5)
    }

    .tab-button.active {
      color: #3498db;
      border-bottom-color: #3498db;
      background: rgba(52, 152, 219, .1)
    }

    .tab-content {
      display: none
    }

    .tab-content.active {
      display: block
    }

    .form-group {
      margin-bottom: 12px
    }

    .form-label {
      display: block;
      margin-bottom: 6px;
      font-size: 13px;
      color: #ecf0f1
    }

    .form-input,
    .form-select {
      width: 100%;
      padding: 8px 10px;
      border: 1px solid #34495e;
      border-radius: 4px;
      background: #34495e;
      color: #fff;
      font-size: 14px;
      box-sizing: border-box
    }

    .btn-primary {
      background: #3498db;
      color: #fff;
      border: none;
      padding: 10px 10px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      width: 100%
    }

    .btn-primary:hover {
      background: #2980b9
    }

    .btn-saveconfig {
      background: #3498db;
      color: #fff;
      border: none;
      padding: 10px 10px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      width: 70%
    }

    .btn-saveconfig:hover {
      background: #2980b9
    }

    .robot-list {
      margin-top: 10px
    }

    .robot-item {
      background: #34495e;
      padding: 12px;
      margin-bottom: 10px;
      border-radius: 4px;
      border-left: 4px solid #3498db
    }

    .robot-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 6px
    }

    .robot-name {
      font-weight: bold;
      font-size: 16px;
      color: #ecf0f1
    }

    .robot-info {
      font-size: 12px;
      color: #bdc3c7
    }

    .robot-actions {
      margin-top: 8px;
      display: flex;
      gap: 8px
    }

    .btn-delete-small {
      padding: 5px 5px;
      font-size: 12px;
      border: none;
      border-radius: 3px;
      cursor: pointer
    }

    .btn-danger {
      background: #e74c3c;
      color: #fff;
      border: none;
      padding: 5px 5px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      width: 30%
    }

    .btn-danger:hover {
      background: #c0392b
    }

    .btn-config-small {
      background: #f39c12;
      color: #fff;
      border: none;
      padding: 5px 5px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      width: 30%
    }

    .btn-config-small:hover {
      background: #e67e22
    }

    .btn-cancel-small {
      background: #f39c12;
      color: #fff;
      border: none;
      padding: 10px 10px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      width: 30%
    }

    .btn-cancel-small:hover {
      background: #e67e22
    }


    .sidebar-toggle {
      position: fixed;
      left: 0;
      top: 50%;
      transform: translateY(-50%);
      background: linear-gradient(135deg, #3498db, #2980b9);
      color: #fff;
      border: none;
      padding: 15px 8px;
      border-radius: 0 8px 8px 0;
      cursor: pointer;
      font-size: 14px;
      z-index: 1001;
      box-shadow: 2px 0 8px rgba(0, 0, 0, .2);
      writing-mode: vertical-rl;
      text-orientation: mixed;
      min-height: 80px; transition: left .4s cubic-bezier(.25, .8, .25, 1)
    }

    .sidebar-toggle:hover {
      background: linear-gradient(135deg, #2980b9, #1f5f8b);
      transform: translateY(-50%) translateX(3px);
      box-shadow: 3px 0 12px rgba(0, 0, 0, .3)
    }

    .sidebar-toggle.open {
      left: 360px
    }

    #mapCanvas {
      display: block;
      cursor: grab;
      background: #2c3e50
    }

    #mapCanvas:active {
      cursor: grabbing
    }

    .info-panel {
      position: fixed;
      top: 70px;
      right: 10px;
      background: rgba(52, 73, 94, .9);
      color: #fff;
      padding: 12px;
      border-radius: 8px;
      font-size: 12px;
      min-width: 190px;
      backdrop-filter: blur(5px);
      z-index: 999
    }
    .loading {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #fff;
      font-size: 16px
    }
    /* Bin task detail cards */
    .bin-cards { margin-top: 6px; }
    .bin-card { border: 1px solid #3b4a5a; background: #2b3b4b; border-radius: 4px; padding: 8px; margin-bottom: 6px; }
    .bin-card-title { font-weight: bold; color: #ecf0f1; margin-bottom: 6px; font-size: 12px; }
    .bin-kv { display: flex; gap: 8px; font-size: 12px; color: #bdc3c7; }
    .bin-kv .key { width: 50%; color: #95a5a6; }
    .bin-kv .val { width: 50%; color: #ecf0f1; word-break: break-all; }
  </style>
</head>

<body>
  <div class="header">
    <div class="title">AGV地图查看器</div>
    <div class="controls">
      <div class="status" id="status">准备就绪</div>
      <select id="floorSelect" class="form-select" style="width:auto;" onchange="switchFloor(this.value)">
        <option value="">加载中...</option>
      </select>
      <button class="btn" onclick="cycleFloor()">切换楼层</button>
      <button class="btn" onclick="resetView()">重置视图</button>
      <button class="btn" onclick="toggleGrid()">网格</button>
      <button class="btn" onclick="toggleSafetyRange()">安全范围</button>
      <button class="btn" onclick="openSettingsModal()">设置</button>
    </div>
  </div>

  <button class="sidebar-toggle" id="sidebarToggle" onclick="toggleSidebar()">打开</button>

  <div class="sidebar" id="sidebar">
    <div class="sidebar-header">
      <div class="sidebar-title">仿真机器人管理</div>
      <button class="sidebar-close" onclick="toggleSidebar()">×</button>
    </div>
    <div class="sidebar-tabs">
      <button class="tab-button active" onclick="switchTab('register')">注册机器人</button>
      <button class="tab-button" onclick="switchTab('list')">机器人列表</button>
      <button class="tab-button" onclick="switchTab('equip')">设备列表</button>
    </div>
    <div class="sidebar-content">
      <div class="tab-content active" id="registerTab">
        <div class="robot-form">
          <div class="form-group"><label class="form-label">机器人名称</label><input type="text" class="form-input"
              id="robotName" placeholder=""></div>
          <div class="form-group"><label class="form-label">机器人类型</label><select class="form-select" id="robotType">
              <option value="AGV">AGV</option>
              <option value="AMR">AMR</option>
              <option value="Forklift">叉车</option>
            </select></div>
          <div class="form-group"><label class="form-label">机器人IP地址</label><input type="text" class="form-input"
              id="robotIP" placeholder=""></div>
          <div class="form-group"><label class="form-label">厂商</label><input type="text" class="form-input"
              id="robotManufacturer" placeholder="厂商名称" value="SEER"></div>
          <div class="form-group"><label class="form-label">版本</label><input type="text" class="form-input"
              id="robotVersion" placeholder="版本号" value="v2"></div>
          <div class="form-group"><label class="form-label">加载地图</label><select class="form-select" id="registerMapSelect" style="width:100%"><option value="">请选择地图</option></select><div id="registerMapSelectedText" class="form-hint" style="font-size:12px;color:#bdc3c7;word-break:break-all;margin-top:4px;">当前: <span id="registerMapSelectedLabel"></span></div></div>
          <div class="form-group"><label class="form-label">初始位置</label><select class="form-select"
              id="initialPosition" disabled>
              <option value="">请先选择地图</option>
            </select></div>
          <div class="form-group"><button class="btn-primary" onclick="registerRobot()">注册机器人</button></div>
        </div>
      </div>
      <div class="tab-content" id="listTab">
        <div class="robot-list">
          <div id="robotListContainer"></div>
        </div>
      </div>
      <div class="tab-content" id="equipTab">
        <div class="robot-list">
          <div id="equipListContainer"></div>
        </div>
      </div>
    </div>
  </div>

  <div class="canvas-container" id="canvasContainer">
    <canvas id="mapCanvas"></canvas>
    <div class="loading" id="loading" style="display:none;">正在加载地图数据...</div>
    <div class="info-panel">
      <div id="mapInfoSection">
        <div id="mapInfoHeader"><strong>地图信息</strong></div>
        <div id="mapInfoPanel">
          <div>站点数量: <span id="pointCount">0</span></div>
          <div>路段数量: <span id="routeCount">0</span></div>
          <div>缩放: <span id="zoomLevel">100%</span></div>
          <div>坐标: <span id="mousePos">0, 0</span></div>
        </div>
      </div>
      <div id="routeHeader" style="margin-top:8px; display:none;"><strong>路段详情</strong></div>
      <div id="routeDetails" style="font-size:12px;color:#bdc3c7;line-height:1.6; display:none;">
        <div>路段ID: <span id="rtId">-</span></div>
        <div>名称: <span id="rtDesc">-</span></div>
        <div>曲线类型: <span id="rtType">-</span></div>
        <div>路段类型: <span id="rtPass">-</span></div>
      </div>
      <div id="stationHeader" style="margin-top:8px; display:none;"><strong>站点详情</strong></div>
      <div id="stationDetails" style="font-size:12px;color:#bdc3c7;line-height:1.6; display:none;">
        <div>类型: <span id="stType">-</span></div>
        <div>ID: <span id="stId">-</span></div>
        <div>名称: <span id="stName">-</span></div>
        <div>坐标: <span id="stPos">-</span></div>
        <div>朝向: <span id="stDir">-</span></div>
        <div>随动点: <span id="stSpin">-</span></div>
        <div id="stStorageRow">库位: <span id="stStorage">-</span></div>
        <div id="stStorageDetailsRow">库位详情:</div>
        <div id="stStorageDetails" class="bin-cards">-</div>
      </div>
    </div>
    <!-- 机器人右键菜单 -->
    <div id="robotContextMenu" style="display:none; position:absolute; z-index:1000; background:#2c3e50; color:#ecf0f1; border:1px solid #34495e; border-radius:4px; box-shadow:0 6px 18px rgba(0,0,0,0.35); min-width:140px;">
      <!-- 动态填充菜单项 -->
    </div>
    <!-- 站点右键菜单 -->
    <div id="stationContextMenu" style="display:none; position:absolute; z-index:1000; background:#2c3e50; color:#ecf0f1; border:1px solid #34495e; border-radius:4px; box-shadow:0 6px 18px rgba(0,0,0,0.35); min-width:160px;">
      <!-- 动态填充菜单项 -->
    </div>
  </div>
  
    <script src="/static/src/services/pathfinding.js?v=20251104"></script>
  <script>
    // 全局错误拦截：将所有请求错误打印到状态框（#status）
    (function () {
      // 隐藏滚动条后，使用自动滚动展示完整信息
      let _statusRafId = null;
      function _stopStatusAutoScroll() {
        try { if (_statusRafId) cancelAnimationFrame(_statusRafId); } catch (_) {}
        _statusRafId = null;
      }
      function startStatusAutoScroll() {
        const el = document.getElementById('status');
        if (!el) return;
        _stopStatusAutoScroll();
        const max = el.scrollWidth - el.clientWidth;
        if (max <= 0) return; // 不溢出则不滚动
        let pos = el.scrollLeft || 0;
        let dir = 1; // 1 右移，-1 左移（来回滚动）
        const step = 1; // 每帧滚动像素
        function tick() {
          const node = document.getElementById('status');
          if (!node) return;
          pos += dir * step;
          if (pos >= max) { pos = max; dir = -1; }
          else if (pos <= 0) { pos = 0; dir = 1; }
          node.scrollLeft = pos;
          _statusRafId = requestAnimationFrame(tick);
        }
        _statusRafId = requestAnimationFrame(tick);
      }
      function setStatusMessage(msg) {
        try {
          const el = document.getElementById('status');
          if (el) {
            el.textContent = String(msg);
            // 文本渲染后启动滚动
            setTimeout(startStatusAutoScroll, 0);
          }
        } catch (e) {}
      }
      // 暴露辅助函数，供业务代码在 catch 中打印详细错误
      window.printErrorToStatus = function (err, context) {
        const msg = (err && err.message) ? err.message : String(err);
        const prefix = context ? '[' + String(context) + '] ' : '';
        setStatusMessage(prefix + msg);
      };
      const originalFetch = window.fetch;
      window.fetch = async function (input, init) {
        const url = (typeof input === 'string') ? input : (input && input.url ? input.url : '');
        const method = (init && init.method) || (typeof input === 'object' && input && input.method) || 'GET';
        try {
          const res = await originalFetch(input, init);
          if (!res.ok) {
            let detail = '';
            try {
              const txt = await res.clone().text();
              try {
                const obj = JSON.parse(txt);
                detail = obj && (obj.detail || obj.message) ? (obj.detail || obj.message) : txt;
              } catch (_) {
                detail = txt;
              }
            } catch (_) {
              detail = res.statusText || '未知错误';
            }
            setStatusMessage(`错误 ${res.status} ${method} ${url}: ${String(detail).trim()}`);
          }
          return res;
        } catch (err) {
          setStatusMessage(`网络错误 ${method} ${url}: ${err && err.message ? err.message : String(err)}`);
          throw err;
        }
      };
      // 捕获未处理的 promise 异常与脚本错误
      window.addEventListener('unhandledrejection', function (ev) {
        const reason = ev && ev.reason ? (ev.reason.message || String(ev.reason)) : '未知异常';
        setStatusMessage(`未捕获错误: ${reason}`);
      });
      window.addEventListener('error', function (ev) {
        setStatusMessage(`脚本错误: ${ev.message} @ ${ev.filename}:${ev.lineno}`);
      });
      // 页面初次加载也尝试启动滚动（如果初始文案超出）
      try { setTimeout(startStatusAutoScroll, 0); } catch (_) {}
    })();
    // 配置
    const API_BASE_URL = window.location.origin + '/api';
    // 可配置的前端轮询间隔（毫秒），从后端 /api/config 读取
    window.FRONTEND_POLL_INTERVAL_MS = 1000;
    // 安全范围中心前移偏移量（米），用于将旋转矩形中心沿车头方向平移
    window.CENTER_FORWARD_OFFSET_M = 0.1;
    async function loadFrontendConfig() {
      try {
        const resp = await fetch(`${API_BASE_URL}/config`);
        if (resp && resp.ok) {
          const data = await resp.json();
          const v = Number(data && data.polling_interval_ms);
          if (isFinite(v) && v > 0) {
            window.FRONTEND_POLL_INTERVAL_MS = v;
          }
          const off = Number(data && (data.center_forward_offset_m ?? data.centerForwardOffsetM));
          if (isFinite(off)) {
            window.CENTER_FORWARD_OFFSET_M = Math.max(0, Math.min(5, off));
          }
        }
      } catch (_) { /* ignore */ }
    }
  const CURRENT_MAP_ID = 'ViewerMap/testmap.scene';
    const POINT_TYPE_INFO = {
      1: { label: '普通点', color: '#f39c12' },
      2: { label: '等待点', color: '#2980b9' },
      3: { label: '避让点', color: '#8e44ad' },
      4: { label: '临时避让点', color: '#9b59b6' },
      5: { label: '库区点', color: '#16a085' },
      7: { label: '不可避让点', color: '#c0392b' },
      11: { label: '电梯点', color: '#e91e63' },
      12: { label: '自动门点', color: '#00bcd4' },
      13: { label: '充电点', color: '#4caf50' },
      14: { label: '停靠点', color: '#7f8c8d' },
      15: { label: '动作点', color: '#e74c3c' },
      16: { label: '禁行点', color: '#ff3860' }
    };

    // 路段 pass 类型映射
    const PASS_TYPE_INFO = {
      0: { label: '普通路段', color: '#3498db' },
      1: { label: '仅空载可通行', color: '#f1c40f' },
      2: { label: '仅载货可通行', color: '#e67e22' },
      10: { label: '禁行路段', color: '#e74c3c' }
    };

    // 画布与视图态
    let canvas, ctx, mapData = null;
    let viewTransform = { x: 0, y: 0, scale: 1 };
    let isDragging = false; let lastMousePos = { x: 0, y: 0 }; let showGrid = true; let sidebarOpen = false;
    let registeredRobots = [];
    let ws = null;
    let selectedRobotId = null;
    let selectedStationId = null;
    let selectedRouteId = null;
    let selectedNavStation = null;
    // 路段切换记忆：用于在重叠路段之间循环选择
    let lastRouteCandidates = [];
    let lastRouteCandidateIndex = 0;
    // 已移除 SMAP 站点/拓扑缓存；使用 scene 点信息
    let mapLayers = [];
    let floorNames = [];
    let currentFloorIndex = 0;

  window.onload = function () { initCanvas(); loadMapData(); setupEventListeners(); updateRegisterMapOptions(); Promise.all([loadFrontendConfig(), loadRobotList(), loadEquipmentList()]).catch(() => {}); initWebSocket(); startRenderLoop(); setupKeyboardControl(); startCommStatusGuard(); };

    function initCanvas() { canvas = document.getElementById('mapCanvas'); ctx = canvas.getContext('2d'); resizeCanvas(); window.addEventListener('resize', resizeCanvas); }
    function resizeCanvas() { const c = document.querySelector('.canvas-container'); canvas.width = c.clientWidth; canvas.height = c.clientHeight; if (mapData) { drawMap(); } }
    function setupEventListeners() {
      canvas.addEventListener('mousedown', onMouseDown);
      canvas.addEventListener('mousemove', onMouseMove);
      canvas.addEventListener('mouseup', onMouseUp);
      canvas.addEventListener('wheel', onWheel);
      canvas.addEventListener('contextmenu', e => e.preventDefault());
      document.addEventListener('click', (ev) => {
        const robotMenu = document.getElementById('robotContextMenu');
        const stationMenu = document.getElementById('stationContextMenu');
        const tgt = ev.target;
        if (robotMenu && robotMenu.style.display === 'block' && !robotMenu.contains(tgt)) {
          hideRobotContextMenu();
        }
        if (stationMenu && stationMenu.style.display === 'block' && !stationMenu.contains(tgt)) {
          hideStationContextMenu();
        }
      });
      const regMapSel = document.getElementById('registerMapSelect');
      if (regMapSel) {
        regMapSel.addEventListener('change', () => {
          const lbl = document.getElementById('registerMapSelectedLabel');
          if (lbl) lbl.textContent = regMapSel.value || '未设置';
          updateRegisterInitialPositionOptions();
        });
      }
    }
    async function onMouseDown(e) {
      const p = getMousePos(e);
      // 右键：优先命中小车，其次站点
      if (e.button === 2) {
        const robot = findRobotAtScreenPoint(p.x, p.y);
        if (robot) {
          selectedRobotId = robot.robot_name;
          showRobotContextMenu(p.x, p.y, robot);
        } else {
          const hitPoint = findPointAtScreenPos(p.x, p.y);
          if (hitPoint) {
            showStationContextMenu(p.x, p.y, hitPoint);
          } else {
            hideRobotContextMenu();
            hideStationContextMenu();
          }
        }
        return; // 右键不进入拖拽
      }
      // 左键：优先命中站点（scene points）
      const hitPoint = findPointAtScreenPos(p.x, p.y);
      if (hitPoint) {
        selectedStationId = hitPoint.id;
        const info = getStationDetails(hitPoint);
        updateStationInfoPanel(info);
        selectedRouteId = null;
        lastRouteCandidates = [];
        lastRouteCandidateIndex = 0;
        updateRouteInfoPanel(null);
        drawMap();
        hideRobotContextMenu();
        return;
      }
      // 次优命中路段：支持在重叠的双向路段之间循环切换
      const routeCandidates = findRoutesAtScreenPos(p.x, p.y);
      if (routeCandidates.length > 0) {
        const candidateIds = routeCandidates.map(rt => String(rt.id ?? (`${rt.from}->${rt.to}`)));
        const sameSet = (lastRouteCandidates.length === candidateIds.length) && lastRouteCandidates.every((id, idx) => id === candidateIds[idx]);
        if (!sameSet) {
          lastRouteCandidates = candidateIds;
          lastRouteCandidateIndex = 0; // 第一次点击选择上面的（绘制顺序更靠后的）
        } else {
          lastRouteCandidateIndex = (lastRouteCandidateIndex + 1) % lastRouteCandidates.length; // 再次点击在同一组内轮换
        }
        const targetRoute = routeCandidates[lastRouteCandidateIndex];
        selectedRouteId = lastRouteCandidates[lastRouteCandidateIndex];
        const rinfo = getRouteDetails(targetRoute);
        updateRouteInfoPanel(rinfo);
        selectedStationId = null;
        updateStationInfoPanel(null);
        drawMap();
        hideRobotContextMenu();
        return;
      }
      // 否则开始拖拽
      isDragging = true;
      lastMousePos = p;
      canvas.style.cursor = 'grabbing';
      // 点击空白区域：显示地图信息、隐藏路段与站点详情
      const mi = document.getElementById('mapInfoSection'); if (mi) mi.style.display = 'block';
      const rh = document.getElementById('routeHeader'); if (rh) rh.style.display = 'none';
      const sh = document.getElementById('stationHeader'); if (sh) sh.style.display = 'none';
      const rd = document.getElementById('routeDetails'); if (rd) rd.style.display = 'none';
      const sd = document.getElementById('stationDetails'); if (sd) sd.style.display = 'none';
      hideRobotContextMenu();
      hideStationContextMenu();
    }
    function onMouseMove(e) { const p = getMousePos(e); const wp = screenToWorld(p.x, p.y); document.getElementById('mousePos').textContent = `${wp.x.toFixed(2)}, ${wp.y.toFixed(2)}`; if (isDragging) { viewTransform.x += p.x - lastMousePos.x; viewTransform.y += p.y - lastMousePos.y; drawMap(); lastMousePos = p; } }
    function onMouseUp() { isDragging = false; canvas.style.cursor = 'grab'; }
    function onWheel(e) { e.preventDefault(); const p = getMousePos(e); const wp = screenToWorld(p.x, p.y); const sf = e.deltaY > 0 ? 0.9 : 1.1; const ns = Math.max(0.1, Math.min(5, viewTransform.scale * sf)); if (ns !== viewTransform.scale) { viewTransform.scale = ns; const nwp = screenToWorld(p.x, p.y); viewTransform.x += (wp.x - nwp.x) * viewTransform.scale; viewTransform.y += (wp.y - nwp.y) * viewTransform.scale; updateZoomDisplay(); drawMap(); } }
    function getMousePos(e) { const r = canvas.getBoundingClientRect(); return { x: e.clientX - r.left, y: e.clientY - r.top }; }
    // 坐标系约定：世界坐标采用数学坐标（x 向右为正、y 向上为正）。
    // 屏幕坐标 y 向下为正，因此在坐标换算中对 y 做一次性取反。
    function screenToWorld(sx, sy) { return { x: (sx - viewTransform.x) / viewTransform.scale / 20, y: -((sy - viewTransform.y) / viewTransform.scale / 20) }; }
    function worldToScreen(wx, wy) { return { x: (wx * 20) * viewTransform.scale + viewTransform.x, y: (-wy * 20) * viewTransform.scale + viewTransform.y }; }

    // 站点类型推导（根据名称前缀常见约定，如: CP/DP等）
    function deriveClassFromName(name) {
      if (!name) return 'Station';
      if (/^CP/i.test(name)) return 'CP';
      if (/^DP/i.test(name)) return 'DP';
      if (/^WP/i.test(name)) return 'WP';
      if (/^Pallet/i.test(name)) return 'Pallet';
      return 'Station';
    }

    // 根据缩放动态设置站点绘制半径，便于命中
    function pointDrawSize() {
      const base = 3; // 基础像素半径
      const s = Math.max(4, Math.min(24, base * viewTransform.scale));
      return s;
    }

    // 命中检测：在屏幕坐标系判断是否点击到站点（点）
    function findPointAtScreenPos(sx, sy) {
      if (!mapData || !mapData.points) return null;
      const radius = pointDrawSize() + 2; // 扩大一点命中范围
      const currentFloorName = floorNames[currentFloorIndex] || null;
      for (const p of mapData.points) {
        // 楼层过滤
        const pfloor = extractFloorNameFromLayer(p.layer || '');
        if (currentFloorName && pfloor && String(pfloor).trim().toLowerCase() !== String(currentFloorName).trim().toLowerCase()) continue;
        const sp = worldToScreen(p.x, p.y);
        const dx = sx - sp.x, dy = sy - sp.y;
        if (dx * dx + dy * dy <= radius * radius) {
          return {
            id: String(p.id || p.name || `${p.x},${p.y}`),
            name: p.name || p.id || '未知',
            type: p.type,
            properties: (Array.isArray(p.properties) ? p.properties : (Array.isArray(p.property) ? p.property : [])),
            associatedStorageLocations: (Array.isArray(p.associatedStorageLocations) ? p.associatedStorageLocations : []),
            layer: p.layer || '',
            pos: { x: p.x, y: p.y },
            dir: p.dir || 0
          };
        }
      }
      return null;
    }

    // 兼容占位：项目不再使用 SMAP 站点缓存；scene 点信息直接来自当前楼层的 points
    async function loadSceneStations() { /* no-op */ }

    // 合并基础点信息（scene），得到展示数据
    function getStationDetails(pt) {
      const id = String(pt.id || pt.name || '');
      const name = String(pt.name || pt.id || '');
      const typeCode = (pt.type !== undefined) ? Number(pt.type) : NaN;
      const className = (POINT_TYPE_INFO[typeCode]?.label) || '未知类型';
      const dir = (typeof pt.dir === 'number') ? pt.dir : undefined;
      const ignoreDir = false;
      let spin = false;
      const props = Array.isArray(pt.properties) ? pt.properties : (Array.isArray(pt.property) ? pt.property : []);
      for (const prop of props) {
        if (prop && prop.key === 'spin' && prop.boolValue === true) { spin = true; break; }
      }
      const stor = Array.isArray(pt.associatedStorageLocations) ? pt.associatedStorageLocations : [];
      return { id, className, instanceName: name, pos: pt.pos, dir, ignoreDir, spin, associatedStorageLocations: stor };
    }

    function updateStationInfoPanel(info) {
      if (!info) {
        document.getElementById('stId').textContent = '-';
        document.getElementById('stType').textContent = '-';
        document.getElementById('stName').textContent = '-';
        document.getElementById('stPos').textContent = '-';
        document.getElementById('stDir').textContent = '-';
        document.getElementById('stSpin').textContent = '-';
        document.getElementById('stStorage').textContent = '-';
        const sr = document.getElementById('stStorageRow'); if (sr) sr.style.display = 'none';
        const sdr = document.getElementById('stStorageDetailsRow'); if (sdr) sdr.style.display = 'none';
        const sdt = document.getElementById('stStorageDetails'); if (sdt) sdt.textContent = '-';
        const sd = document.getElementById('stationDetails');
        if (sd) sd.style.display = 'none';
        const sh = document.getElementById('stationHeader'); if (sh) sh.style.display = 'none';
        return;
      }
      document.getElementById('stId').textContent = info.id || '-';
      document.getElementById('stType').textContent = info.className || '-';
      document.getElementById('stName').textContent = info.instanceName || '-';
      const posStr = info.pos ? `(${Number(info.pos.x).toFixed(2)}, ${Number(info.pos.y).toFixed(2)})` : '-';
      document.getElementById('stPos').textContent = posStr;
      const orientationText = (info.ignoreDir === true)
        ? '任意'
        : (typeof info.dir === 'number' ? `${Number(info.dir * 180 / Math.PI).toFixed(2)}°` : '-');
      document.getElementById('stDir').textContent = orientationText;
      document.getElementById('stSpin').textContent = (info.spin === true) ? 'true' : 'false';
      // 通过 binLocationsList 解析库位及库位详情，按可读格式展示
      const bin = lookupBinLocationInfo(info.instanceName || info.id);
      const storNames = Array.isArray(bin?.locationNames) ? bin.locationNames : [];
      const hasDetails = renderBinTaskDetails(bin);
      const sr = document.getElementById('stStorageRow');
      const sdr = document.getElementById('stStorageDetailsRow');
      if (sr) sr.style.display = (storNames.length > 0) ? 'block' : 'none';
      if (sdr) sdr.style.display = hasDetails ? 'block' : 'none';
      const storEl = document.getElementById('stStorage');
      if (storEl) storEl.textContent = (storNames.length > 0) ? storNames.join(', ') : '-';
      const sdt = document.getElementById('stStorageDetails');
      if (sdt) sdt.style.display = hasDetails ? 'block' : 'none';
      // 显示站点详情，仅显示该面板
      const sd = document.getElementById('stationDetails');
      if (sd) sd.style.display = 'block';
      const sh = document.getElementById('stationHeader'); if (sh) sh.style.display = 'block';
      const rh = document.getElementById('routeHeader'); if (rh) rh.style.display = 'none';
      const rd = document.getElementById('routeDetails'); if (rd) rd.style.display = 'none';
      const mi = document.getElementById('mapInfoSection'); if (mi) mi.style.display = 'none';
    }

    function getRoutePassLabel(passCode) {
      const code = Number(passCode);
      const info = Object.prototype.hasOwnProperty.call(PASS_TYPE_INFO, code) ? PASS_TYPE_INFO[code] : PASS_TYPE_INFO[0];
      return info.label;
    }

    function getRouteColorByPass(passCode) {
      const code = Number(passCode);
      const info = Object.prototype.hasOwnProperty.call(PASS_TYPE_INFO, code) ? PASS_TYPE_INFO[code] : PASS_TYPE_INFO[0];
      return info.color;
    }

    function getRouteDetails(route) {
      if (!route) return null;
      const id = String(route.id ?? (`${route.from}->${route.to}`));
      const desc = String(route.desc || route.name || '-');
      const type = String(route.type || '-');
      const pass = (route.pass !== undefined) ? Number(route.pass) : 0;
      return { id, desc, type, passLabel: getRoutePassLabel(pass), passCode: pass };
    }

    function updateRouteInfoPanel(info) {
      const panel = document.getElementById('routeDetails');
      if (!panel) return;
      if (!info) {
        document.getElementById('rtId').textContent = '-';
        document.getElementById('rtDesc').textContent = '-';
        document.getElementById('rtType').textContent = '-';
        document.getElementById('rtPass').textContent = '-';
        panel.style.display = 'none';
        const rh = document.getElementById('routeHeader'); if (rh) rh.style.display = 'none';
        return;
      }
      document.getElementById('rtId').textContent = info.id || '-';
      document.getElementById('rtDesc').textContent = info.desc || '-';
      document.getElementById('rtType').textContent = info.type || '-';
      document.getElementById('rtPass').textContent = info.passLabel || '-';
      panel.style.display = 'block';
      const rh = document.getElementById('routeHeader'); if (rh) rh.style.display = 'block';
      const sd = document.getElementById('stationDetails'); if (sd) sd.style.display = 'none';
      const sh = document.getElementById('stationHeader'); if (sh) sh.style.display = 'none';
      const mi = document.getElementById('mapInfoSection'); if (mi) mi.style.display = 'none';
    }

    function pointToSegmentDistance(px, py, x1, y1, x2, y2) {
      const dx = x2 - x1, dy = y2 - y1;
      if (dx === 0 && dy === 0) return Math.hypot(px - x1, py - y1);
      const t = ((px - x1) * dx + (py - y1) * dy) / (dx * dx + dy * dy);
      const tt = Math.max(0, Math.min(1, t));
      const cx = x1 + tt * dx, cy = y1 + tt * dy;
      return Math.hypot(px - cx, py - cy);
    }

    function findRoutesAtScreenPos(sx, sy) {
      if (!mapData || !Array.isArray(mapData.routes)) return [];
      const pmap = {};
      (mapData.points || []).forEach(p => { pmap[p.id] = p; });
      const threshold = Math.max(6, 8 * (viewTransform.scale));
      const candidates = [];
      // 倒序遍历，保证绘制顺序靠后的（更“上面”的）先进入列表
      for (let i = (mapData.routes.length - 1); i >= 0; i--) {
        const route = mapData.routes[i];
        const fp = pmap[route.from], tp = pmap[route.to];
        if (!fp || !tp) continue;
        if (route.type === 'bezier3' && route.c1 && route.c2) {
          const N = 24;
          let minD = Infinity;
          let prev = worldToScreen(fp.x, fp.y);
          for (let j = 1; j <= N; j++) {
            const t = j / N;
            const bt = bezierPoint({ x: fp.x, y: fp.y }, { x: route.c1.x, y: route.c1.y }, { x: route.c2.x, y: route.c2.y }, { x: tp.x, y: tp.y }, t);
            const cur = worldToScreen(bt.x, bt.y);
            const d = pointToSegmentDistance(sx, sy, prev.x, prev.y, cur.x, cur.y);
            if (d < minD) minD = d;
            prev = cur;
          }
          if (minD <= threshold) candidates.push(route);
        } else {
          const s1 = worldToScreen(fp.x, fp.y);
          const s2 = worldToScreen(tp.x, tp.y);
          const d = pointToSegmentDistance(sx, sy, s1.x, s1.y, s2.x, s2.y);
          if (d <= threshold) candidates.push(route);
        }
      }
      return candidates;
    }

    // 命中检测：在屏幕坐标系根据当前位置与朝向判断鼠标是否位于机器人图形内
    function findRobotAtScreenPoint(sx, sy) {
      for (const robot of registeredRobots) {
        // 楼层过滤
        if (robot.currentMap) {
          const robotFloor = extractFloorFromMapId(robot.currentMap);
          const currentFloorName = floorNames[currentFloorIndex] || null;
          if (robotFloor && currentFloorName && robotFloor !== currentFloorName) continue;
        }
        const pos = robot.currentPosition || robot.initialPosition || null;
        if (!pos) continue;
        const sp = worldToScreen(pos.x, pos.y);
        // 转到机器人局部坐标系
        const dx = sx - sp.x;
        const dy = sy - sp.y;
        const ang = (pos.theta ?? pos.orientation ?? 0);
        const cosA = Math.cos(-ang), sinA = Math.sin(-ang);
        const lx = dx * cosA - dy * sinA;
        const ly = dx * sinA + dy * cosA;
        const s = Math.max(0.5, Math.min(2, viewTransform.scale));
        // 身体的包围盒（随缩放）
        const half = 12 * s;
        if (lx >= -half && lx <= half && ly >= -half && ly <= half) {
          return robot;
        }
      }
      return null;
    }

    // 右键菜单展示/隐藏
    function showRobotContextMenu(sx, sy, robot) {
      const menu = document.getElementById('robotContextMenu');
      if (!menu) return;
      // 填充菜单项
      const hasPallet = !!robot.hasPallet;
      menu.innerHTML = '';
      const item = document.createElement('div');
      item.style.padding = '8px 12px';
      item.style.cursor = 'pointer';
      item.textContent = hasPallet ? '卸载托盘' : '加载托盘';
      item.onclick = function () {
        if (hasPallet) unloadPallet(robot.robot_name); else loadPallet(robot.robot_name);
        hideRobotContextMenu();
      };
      menu.appendChild(item);
      // 位置与显示
      const container = document.getElementById('canvasContainer');
      const rect = container.getBoundingClientRect();
      menu.style.left = (sx + rect.left - rect.left) + 'px';
      menu.style.top = (sy + rect.top - rect.top) + 'px';
      menu.style.display = 'block';
    }
    function hideRobotContextMenu() {
      const menu = document.getElementById('robotContextMenu');
      if (menu) menu.style.display = 'none';
    }

    // 站点右键菜单
    function isWorkStationPoint(point) {
      const nm = String(point?.name || point?.id || '').trim();
      return /^AP/i.test(nm);
    }
    function isChargingStationPoint(point) {
      const nm = String(point?.name || point?.id || '').trim();
      const typeCode = (point && typeof point.type !== 'undefined') ? Number(point.type) : NaN;
      // 同时支持名称前缀与类型码识别：type=13 为充电点
      if (typeCode === 13) return true;
      return /^CP/i.test(nm);
    }
    function showStationContextMenu(sx, sy, point) {
      const menu = document.getElementById('stationContextMenu');
      if (!menu) return;
      menu.innerHTML = '';
      const itemNav = document.createElement('div');
      itemNav.style.padding = '8px 12px';
      itemNav.style.cursor = 'pointer';
      itemNav.textContent = '导航至该站点';
      itemNav.onclick = async function (ev) {
        if (ev && ev.stopPropagation) ev.stopPropagation();
        try {
          await navigateRobotToStation(point);
        } catch (err) {
          console.error('导航失败:', err);
          try { window.printErrorToStatus(err, '导航失败'); } catch (_) {}
          
        } finally {
          hideStationContextMenu();
        }
      };
      // 如果未选中机器人，则禁用提示
      if (!selectedRobotId) {
        itemNav.style.opacity = '0.6';
        itemNav.style.pointerEvents = 'none';
        const tip = document.createElement('div');
        tip.style.padding = '6px 12px';
        tip.style.fontSize = '12px';
        tip.style.color = '#bdc3c7';
        tip.textContent = '请先在列表中选中机器人';
        menu.appendChild(tip);
      }
      menu.appendChild(itemNav);

      // CP 充电站：提供“执行充电任务”
      const isCharge = isChargingStationPoint(point);
      if (isCharge) {
        const itemCharge = document.createElement('div');
        itemCharge.style.padding = '8px 12px';
        itemCharge.style.cursor = 'pointer';
        itemCharge.textContent = '执行充电任务';
        itemCharge.onclick = async function (ev) {
          if (ev && ev.stopPropagation) ev.stopPropagation();
          try {
            await navigateRobotToStationWithAction(point, 'StartCharging', { source: 'CPMenu' });
          } catch (err) {
            console.error('充电任务发布失败:', err);
            try { window.printErrorToStatus(err, '充电任务发布失败'); } catch (_) {}
          } finally {
            hideStationContextMenu();
          }
        };
        if (!selectedRobotId) {
          itemCharge.style.opacity = '0.6';
          itemCharge.style.pointerEvents = 'none';
        }
        menu.appendChild(itemCharge);
      }

      // 新增：至站点执行动作（子菜单）仅在 AP 且存在 binTask 时显示
      const options = extractBinTaskOptionsForPoint(point);
      const isWork = isWorkStationPoint(point);
      if (isWork && options.length > 0) {
        const actionItem = document.createElement('div');
        actionItem.style.padding = '8px 12px';
        actionItem.style.cursor = 'pointer';
        actionItem.textContent = '至站点执行动作';
        const sub = document.createElement('div');
        sub.style.display = 'none';
        sub.style.borderTop = '1px solid #34495e';
        sub.style.marginTop = '6px';
        sub.style.paddingTop = '6px';
        for (const opt of options) {
          const btn = document.createElement('div');
          btn.style.padding = '6px 12px';
          btn.style.cursor = 'pointer';
          btn.textContent = opt.title;
          btn.onclick = async function (ev) {
            if (ev && ev.stopPropagation) ev.stopPropagation();
            try {
              await navigateRobotToStationWithAction(point, opt.title, opt.params);
            } catch (err) {
              console.error('执行动作失败:', err);
              try { window.printErrorToStatus(err, '执行动作失败'); } catch (_) {}
            } finally {
              hideStationContextMenu();
            }
          };
          if (!selectedRobotId) {
            btn.style.opacity = '0.6';
            btn.style.pointerEvents = 'none';
          }
          sub.appendChild(btn);
        }
        actionItem.onclick = function (ev) {
          if (ev && ev.stopPropagation) ev.stopPropagation();
          sub.style.display = (sub.style.display === 'none') ? 'block' : 'none';
        };
        menu.appendChild(actionItem);
        menu.appendChild(sub);
      }
      const container = document.getElementById('canvasContainer');
      const rect = container.getBoundingClientRect();
      menu.style.left = (sx + rect.left - rect.left) + 'px';
      menu.style.top = (sy + rect.top - rect.top) + 'px';
      menu.style.display = 'block';
    }
    function hideStationContextMenu() {
      const menu = document.getElementById('stationContextMenu');
      if (menu) menu.style.display = 'none';
    }

    // 从库位索引中提取可执行的 binTask 选项（对象型），返回 { title, params }
    function extractBinTaskOptionsForPoint(point) {
      try {
        const key = String(point?.name || point?.id || '').trim();
        if (!key) return [];
        const entry = lookupBinLocationInfo(key);
        const objs = Array.isArray(entry?.binTaskObjects) ? entry.binTaskObjects : [];
        const options = [];
        for (const obj of objs) {
          const list = Array.isArray(obj) ? obj : [obj];
          for (const item of list) {
            if (item && typeof item === 'object' && Object.keys(item).length > 0) {
              const actionName = Object.keys(item)[0];
              const params = item[actionName];
              options.push({ title: String(actionName), params: (params && typeof params === 'object') ? params : {} });
            }
          }
        }
        // 兜底：仅当未解析出结构化动作时，才加入原始字符串选项
        if (options.length === 0) {
          const raws = Array.isArray(entry?.binTaskStrings) ? entry.binTaskStrings : [];
          for (const s of raws) {
            let title = String(s).trim();
            // 若是多行 JSON（第一行为 "[" 或 "{"），取前 50 个非空字符用于标题
            title = title.replace(/\s+/g, ' ').slice(0, 50) || 'RawAction';
            options.push({ title, params: { content: s } });
          }
        }
        return options;
      } catch (e) { return []; }
    }

    // 导航逻辑：基于 VehicleMap .scene，规划路径并发布 VDA 订单到后端
    async function navigateRobotToStation(point) {
      if (!selectedRobotId) { try { window.printErrorToStatus('请先在机器人列表中选中机器人', '导航'); } catch (_) {} return; }
      const robot = registeredRobots.find(r => r.robot_name === selectedRobotId);
      if (!robot) { try { window.printErrorToStatus('未找到选中机器人', '导航'); } catch (_) {} return; }
      const pos = robot.currentPosition || robot.initialPosition;
      if (!pos) { try { window.printErrorToStatus('机器人没有当前位置或初始位置', '导航'); } catch (_) {} return; }

      const mapName = resolveMapNameForNav(robot, point);
      if (!mapName) { try { window.printErrorToStatus('无法解析地图文件名', '导航'); } catch (_) {} return; }

      document.getElementById('status').textContent = '正在读取地图并规划路径...';
      // 读取 scene 地图、构建拓扑
      const resp = await fetch('/maps/' + mapName);
      if (!resp.ok) { try { window.printErrorToStatus(`读取地图失败: HTTP ${resp.status}`, '导航'); } catch (_) {} return; }
      const sceneData = await resp.json();
      const topo = parseSceneTopology(sceneData);
      if (!Array.isArray(topo.stations) || topo.stations.length === 0 || !Array.isArray(topo.paths) || topo.paths.length === 0) {
        try { window.printErrorToStatus('地图缺少站点或路段（routes），无法规划', '导航'); } catch (_) {}
        return;
      }

      // 站点匹配：找到目标站点及其位置
      const stations = await getSceneStationsForMap(mapName);
      const targetId = findStationIdForPoint(stations, point);
      if (!targetId) { try { window.printErrorToStatus('无法匹配到对应的站点', '导航'); } catch (_) {} return; }
      const targetStation = (stations || []).find(s => String(s.instanceName || s.id || s.pointName) === String(targetId));
      if (!targetStation || !targetStation.pos) { try { window.printErrorToStatus('无法获取目标站点坐标', '导航'); } catch (_) {} return; }

      // 选取起止站点（最近点）
      const startStationId = findNearestStation({ x: Number(pos.x), y: Number(pos.y) }, topo.stations);
      const endStationId = findNearestStation({ x: Number(targetStation.pos.x), y: Number(targetStation.pos.y) }, topo.stations);
      if (!startStationId || !endStationId) { try { window.printErrorToStatus('无法选取起止站点', '导航'); } catch (_) {} return; }

      // A* 规划（站点）
      const nodePath = aStar(String(startStationId), String(endStationId), topo.stations, topo.paths);
      if (!nodePath || nodePath.length < 2) { try { window.printErrorToStatus('未找到可达路径，请检查地图 routes', '导航'); } catch (_) {} return; }

      // 构造并发布 VDA 订单
      const agvInfo = { serial_number: selectedRobotId, manufacturer: robot.manufacturer || 'SEER', version: (robot.version || '2.0.0') };
      const mapIdShort = extractFloorFromMapId(mapName);
      const order = generateVdaOrder(nodePath, agvInfo, topo, mapIdShort, { allowedDeviationXY: 0.5, allowedDeviationTheta: 0.5 });
      try {
        const pubResp = await fetch(`${API_BASE_URL}/agv/${encodeURIComponent(selectedRobotId)}/order`, {
          method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(order)
        });
        if (!pubResp.ok) throw new Error(`HTTP ${pubResp.status}: ${pubResp.statusText}`);
        const resJson = await pubResp.json();
        // 使用站点名称（stations.name）替换站点ID进行路径提示展示
        const stationNameById = new Map((topo.stations || []).map(s => [String(s.id), s.name || String(s.id)]));
        const displayPath = nodePath.map(id => stationNameById.get(String(id)) || String(id));
        document.getElementById('status').textContent = `订单已发布，路径: ${displayPath.join(' -> ')}`;
      } catch (e) {
        console.error('订单发布失败:', e);
        try { window.printErrorToStatus(e, '订单发布失败'); } catch (_) {}
      }
    }

    // 导航并在目标站点执行选中动作：在订单最后一个节点追加 actions
    async function navigateRobotToStationWithAction(point, actionTitle, actionParams) {
      if (!selectedRobotId) { try { window.printErrorToStatus('请先在机器人列表中选中机器人', '执行动作'); } catch (_) {} return; }
      const robot = registeredRobots.find(r => r.robot_name === selectedRobotId);
      if (!robot) { try { window.printErrorToStatus('未找到选中机器人', '执行动作'); } catch (_) {} return; }
      const pos = robot.currentPosition || robot.initialPosition;
      if (!pos) { try { window.printErrorToStatus('机器人没有当前位置或初始位置', '执行动作'); } catch (_) {} return; }

      const mapName = resolveMapNameForNav(robot, point);
      if (!mapName) { try { window.printErrorToStatus('无法解析地图文件名', '执行动作'); } catch (_) {} return; }

      document.getElementById('status').textContent = '正在读取地图并规划路径...';
      const resp = await fetch('/maps/' + mapName);
      if (!resp.ok) { try { window.printErrorToStatus(`读取地图失败: HTTP ${resp.status}`, '执行动作'); } catch (_) {} return; }
      const sceneData = await resp.json();
      const topo = parseSceneTopology(sceneData);
      if (!Array.isArray(topo.stations) || topo.stations.length === 0 || !Array.isArray(topo.paths) || topo.paths.length === 0) {
        try { window.printErrorToStatus('地图缺少站点或路段（routes），无法规划', '执行动作'); } catch (_) {}
        return;
      }

      const stations = await getSceneStationsForMap(mapName);
      const targetId = findStationIdForPoint(stations, point);
      if (!targetId) { try { window.printErrorToStatus('无法匹配到对应的站点', '执行动作'); } catch (_) {} return; }
      const targetStation = (stations || []).find(s => String(s.instanceName || s.id || s.pointName) === String(targetId));
      if (!targetStation || !targetStation.pos) { try { window.printErrorToStatus('无法获取目标站点坐标', '执行动作'); } catch (_) {} return; }

      const startStationId = findNearestStation({ x: Number(pos.x), y: Number(pos.y) }, topo.stations);
      const endStationId = findNearestStation({ x: Number(targetStation.pos.x), y: Number(targetStation.pos.y) }, topo.stations);
      if (!startStationId || !endStationId) { try { window.printErrorToStatus('无法选取起止站点', '执行动作'); } catch (_) {} return; }

      const nodePath = aStar(String(startStationId), String(endStationId), topo.stations, topo.paths);
      if (!nodePath || nodePath.length < 2) { try { window.printErrorToStatus('未找到可达路径，请检查地图 routes', '执行动作'); } catch (_) {} return; }

      const agvInfo = { serial_number: selectedRobotId, manufacturer: robot.manufacturer || 'SEER', version: (robot.version || '2.0.0') };
      const mapIdShort = extractFloorFromMapId(mapName);
      const order = generateVdaOrder(nodePath, agvInfo, topo, mapIdShort, { allowedDeviationXY: 0.5, allowedDeviationTheta: 0.5 });
      try {
        // 组装动作对象，追加到最后一个节点
        const lastIdx = (order.nodes || []).length - 1;
        if (lastIdx >= 0) {
          const paramsList = [];
          if (actionParams && typeof actionParams === 'object') {
            for (const k of Object.keys(actionParams)) {
              paramsList.push({ key: String(k), value: actionParams[k] });
            }
          }
          const actionObj = {
            actionType: String(actionTitle || ''),
            actionId: 'act-' + String(Date.now()),
            blockingType: 'HARD',
            actionDescription: String(actionTitle || ''),
            actionParameters: paramsList,
          };
          if (!Array.isArray(order.nodes[lastIdx].actions)) order.nodes[lastIdx].actions = [];
          order.nodes[lastIdx].actions.push(actionObj);
        }

        const pubResp = await fetch(`${API_BASE_URL}/agv/${encodeURIComponent(selectedRobotId)}/order`, {
          method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(order)
        });
        if (!pubResp.ok) throw new Error(`HTTP ${pubResp.status}: ${pubResp.statusText}`);
        const resJson = await pubResp.json();
        const stationNameById = new Map((topo.stations || []).map(s => [String(s.id), s.name || String(s.id)]));
        const displayPath = nodePath.map(id => stationNameById.get(String(id)) || String(id));
        document.getElementById('status').textContent = `订单已发布，路径: ${displayPath.join(' -> ')}，动作: ${String(actionTitle)}`;
      } catch (e) {
        console.error('订单发布失败:', e);
        try { window.printErrorToStatus(e, '订单发布失败'); } catch (_) {}
      }
    }

    function resolveMapNameForNav(robot, point) {
      // 优先使用当前楼层的 VehicleMap scene；否则回退机器人当前地图（需为 .scene）
      const fname = floorNames[currentFloorIndex];
      if (fname && typeof fname === 'string' && fname.trim() !== '') {
        return `VehicleMap/${fname}.scene`;
      }
      if (robot && typeof robot.currentMap === 'string' && /\.scene$/.test(robot.currentMap)) {
        return robot.currentMap;
      }
      return null;
    }

    function distanceXY(a, b) {
      const dx = Number(a.x) - Number(b.x);
      const dy = Number(a.y) - Number(b.y);
      return Math.hypot(dx, dy);
    }

    // 已移除：SMAP 拓扑拉取（项目不再支持 .smap）

    async function getSceneStationsForMap(mapName) {
      try {
        const path = String(mapName || '').trim();
        if (!path) return [];
        const resp = await fetch('/maps/' + path);
        if (!resp.ok) return [];
        const raw = await resp.json();
        const root = Array.isArray(raw) ? raw[0] : raw;
        const points = (root && Array.isArray(root.points)) ? root.points : [];
        const allowedPrefixes = ['AP','CP','PP','LM','WP'];
        const startsAllowed = (txt) => allowedPrefixes.some(pref => String(txt || '').trim().toUpperCase().startsWith(pref));
        const out = [];
        for (const p of points) {
          const nm = String(p.name || p.id || '').trim();
          if (!nm || !startsAllowed(nm)) continue;
          out.push({ id: String(p.id || nm), instanceName: nm, pointName: nm, className: deriveClassFromName(nm), pos: { x: Number(p.x), y: Number(p.y) } });
        }
        return out;
      } catch (err) {
        console.error('getSceneStationsForMap error:', err);
        return [];
      }
    }

    function findNearestSceneStation(stations, worldPos) {
      const allowedPrefixes = ['AP','CP','PP','LM','WP'];
      const allowedClasses = new Set(['ActionPoint','LocationMark','ChargingPoint','ParkingPoint','WayPoint','Waypoint']);
      let best = null; let bestD = Infinity;
      (stations || []).forEach(s => {
        const id = String(s.id || '').trim();
        const iName = String(s.instanceName || '').trim();
        const pName = String(s.pointName || '').trim();
        const cls = String(s.className || '').trim();
        const startsAllowed = (txt) => allowedPrefixes.some(pref => txt.startsWith(pref));
        const isAllowed = allowedClasses.has(cls) || startsAllowed(id) || startsAllowed(iName) || startsAllowed(pName);
        if (!isAllowed) return;
        const sx = (s && s.pos && typeof s.pos.x !== 'undefined') ? Number(s.pos.x) : Number(s.x);
        const sy = (s && s.pos && typeof s.pos.y !== 'undefined') ? Number(s.pos.y) : Number(s.y);
        const d = Math.hypot(Number(worldPos.x) - sx, Number(worldPos.y) - sy);
        if (d < bestD) { bestD = d; best = s; }
      });
      return best;
    }

    function findStationIdForPoint(stations, pt) {
      const key1 = (pt?.name || '').trim();
      const key2 = (pt?.id || '').trim();
      const allowedPrefixes = ['AP','CP','PP','LM','WP'];
      const allowedClasses = new Set(['ActionPoint','LocationMark','ChargingPoint','ChargePoint','ParkingPoint','ParkPoint','WayPoint','Waypoint']);
      const startsAllowed = (txt) => allowedPrefixes.some(pref => String(txt || '').trim().startsWith(pref));
      const isAllowedStation = (s) => {
        const id = String(s.id || '').trim();
        const iName = String(s.instanceName || '').trim();
        const pName = String(s.pointName || '').trim();
        const cls = String(s.className || '').trim();
        return allowedClasses.has(cls) || startsAllowed(id) || startsAllowed(iName) || startsAllowed(pName);
      };
      // 先尝试按名称/ID 精确匹配，但仅接受导航相关站点
      for (const s of (stations || [])) {
        const iName = (s.instanceName || '').trim();
        const pName = (s.pointName || '').trim();
        if (!isAllowedStation(s)) continue;
        if (key1 && (iName === key1 || pName === key1)) return s.instanceName || s.id || s.pointName;
        if (key2 && (iName === key2 || pName === key2)) return s.instanceName || s.id || s.pointName;
      }
      // 否则按位置最近匹配（仅限导航相关站点类型）
      const nearest = findNearestSceneStation(stations, pt.pos || { x: 0, y: 0 });
      return nearest ? (nearest.instanceName || nearest.id || nearest.pointName) : null;
    }

    async function callNavToStation(robotId, stationId, mapName) {
      const url = `${API_BASE_URL}/sim/agv/${encodeURIComponent(robotId)}/nav/station?station_id=${encodeURIComponent(stationId)}&map_name=${encodeURIComponent(mapName)}`;
      const resp = await fetch(url, { method: 'POST' });
      if (!resp.ok) throw new Error(`HTTP ${resp.status}: ${resp.statusText}`);
      return await resp.json();
    }

    async function pollNavUntilDone(robotId, timeoutMs = 60000) {
      const start = Date.now();
      while (Date.now() - start < timeoutMs) {
        try {
          const resp = await fetch(`${API_BASE_URL}/agv/${encodeURIComponent(robotId)}/nav/status`);
          if (resp.ok) {
            const st = await resp.json();
            if (!st.running) return true; // 已停止，认为完成一个阶段
          }
        } catch (e) { /* 忽略一次失败重试 */ }
        await new Promise(r => setTimeout(r, window.FRONTEND_POLL_INTERVAL_MS || 100));
      }
      return false;
    }

    // 托盘逻辑：加载/卸载与动画
    function loadPallet(id) {
      const robot = registeredRobots.find(r => r.robot_name === id);
      if (!robot) return;
      if (robot.hasPallet) return; 
      // 初始化动画参数
      robot._palletAnimLoading = true;
      robot._palletAnimStart = performance.now();
      robot._palletAnimProgress = 0;
      // 启动叉高竖条加载动画（3秒），目标为当前状态中的叉高（米）；若未知则使用 0.1m
      try {
        const target = (isFinite(Number(robot.forkHeight)) ? Number(robot.forkHeight) : 0.1);
        robot._forkBarAnimLoading = true;
        robot._forkBarAnimUnloading = false;
        robot._forkBarAnimStart = performance.now();
        robot._forkBarAnimProgress = 0;
        robot._forkBarAnimStartHeight = (isFinite(Number(robot._forkBarDisplayHeight)) ? Number(robot._forkBarDisplayHeight) : (isFinite(Number(robot.forkHeight)) ? Number(robot.forkHeight) : 0));
        robot._forkBarAnimTargetHeight = target;
      } catch (_) { /* 忽略一次错误 */ }
      startPalletAnimationLoop();
    }
    function unloadPallet(id) {
      const robot = registeredRobots.find(r => r.robot_name === id);
      if (!robot) return;
      robot._palletAnimLoading = false;
      robot._palletAnimUnloading = true;
      robot._palletAnimStart = performance.now();
      robot._palletAnimProgress = 0;
      // 启动叉高竖条卸载动画（3秒），目标为状态中的叉高（通常为 0.0m；若未知则 0.0m）
      try {
        const target = (isFinite(Number(robot.forkHeight)) ? Number(robot.forkHeight) : 0.0);
        robot._forkBarAnimLoading = false;
        robot._forkBarAnimUnloading = true;
        robot._forkBarAnimStart = performance.now();
        robot._forkBarAnimProgress = 0;
        robot._forkBarAnimStartHeight = (isFinite(Number(robot._forkBarDisplayHeight)) ? Number(robot._forkBarDisplayHeight) : (isFinite(Number(robot.forkHeight)) ? Number(robot.forkHeight) : 0));
        robot._forkBarAnimTargetHeight = target;
      } catch (_) { /* 忽略一次错误 */ }
      startPalletAnimationLoop();
    }

    // 动画循环（16ms）
    let palletAnimTimer = null;
    function startPalletAnimationLoop() {
      if (palletAnimTimer) return;
      palletAnimTimer = setInterval(() => {
        const now = performance.now();
        let any = false;
        registeredRobots.forEach(r => {
          if (r._palletAnimLoading) {
            const dur = 3000;
            const p = Math.max(0, Math.min(1, (now - (r._palletAnimStart || now)) / dur));
            r._palletAnimProgress = p;
            if (p >= 1) {
              r._palletAnimLoading = false;
              r.hasPallet = true;
            } else {
              any = true;
            }
          } else if (r._palletAnimUnloading) {
            const dur = 3000;
            const p = Math.max(0, Math.min(1, (now - (r._palletAnimStart || now)) / dur));
            r._palletAnimProgress = p;
            if (p >= 1) {
              r._palletAnimUnloading = false;
              r.hasPallet = false;
              r.shelfModel = null;
            } else {
              any = true;
            }
          }
          // 叉高竖条动画（加载/卸载 3 秒）：显示值向目标值平滑过渡
          try {
            if (r._forkBarAnimLoading) {
              const dur = 3000;
              const p = Math.max(0, Math.min(1, (now - (r._forkBarAnimStart || now)) / dur));
              r._forkBarAnimProgress = p;
              const startH = (isFinite(Number(r._forkBarAnimStartHeight)) ? Number(r._forkBarAnimStartHeight) : 0);
              // 目标高度优先取当前状态中的叉高，回退到启动时目标
              const liveTarget = (isFinite(Number(r.forkHeight)) ? Number(r.forkHeight) : undefined);
              const targetH = (typeof liveTarget !== 'undefined') ? liveTarget : (isFinite(Number(r._forkBarAnimTargetHeight)) ? Number(r._forkBarAnimTargetHeight) : 0.1);
              r._forkBarDisplayHeight = startH + (targetH - startH) * p;
              if (p >= 1) {
                r._forkBarAnimLoading = false;
                r._forkBarDisplayHeight = (isFinite(Number(r.forkHeight)) ? Number(r.forkHeight) : targetH);
              } else {
                any = true;
              }
            } else if (r._forkBarAnimUnloading) {
              const dur = 3000;
              const p = Math.max(0, Math.min(1, (now - (r._forkBarAnimStart || now)) / dur));
              r._forkBarAnimProgress = p;
              const startH = (isFinite(Number(r._forkBarAnimStartHeight)) ? Number(r._forkBarAnimStartHeight) : 0);
              const liveTarget = (isFinite(Number(r.forkHeight)) ? Number(r.forkHeight) : undefined);
              const targetH = (typeof liveTarget !== 'undefined') ? liveTarget : 0.0;
              r._forkBarDisplayHeight = startH + (targetH - startH) * p;
              if (p >= 1) {
                r._forkBarAnimUnloading = false;
                r._forkBarDisplayHeight = (isFinite(Number(r.forkHeight)) ? Number(r.forkHeight) : targetH);
              } else {
                any = true;
              }
            } else {
              // 无动画时保持与状态同步
              const live = Number(r.forkHeight);
              if (isFinite(live)) r._forkBarDisplayHeight = live;
            }
          } catch (_) { /* 忽略一次错误 */ }
        });
        drawMap();
        if (!any) {
          clearInterval(palletAnimTimer);
          palletAnimTimer = null;
        }
      }, 16);
    }

    // 路段方向与箭头渲染辅助函数
    function getRouteDirection(route) {
      let d = route.direction;
      if (d === undefined && Array.isArray(route.properties)) {
        const p = route.properties.find(pr => (pr.name === 'direction' || pr.key === 'direction'));
        if (p) d = Number(p.value);
      }
      if (typeof d !== 'number' || isNaN(d)) return 1; // 默认正向
      if (d === 0) return 0; // 双向
      return d > 0 ? 1 : -1;
    }

    function drawArrowAt(x, y, angle) {
      const arrowLength = 10;
      const arrowAngle = Math.PI / 6;
      ctx.save();
      // 使用当前路段描边颜色
      ctx.fillStyle = ctx.strokeStyle;
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.lineTo(
        x - arrowLength * Math.cos(angle - arrowAngle),
        y - arrowLength * Math.sin(angle - arrowAngle)
      );
      ctx.lineTo(
        x - arrowLength * Math.cos(angle + arrowAngle),
        y - arrowLength * Math.sin(angle + arrowAngle)
      );
      ctx.closePath();
      ctx.fill();
      ctx.restore();
    }

    // 直线路段箭头：在末端绘制，角度取线段方向
    function drawArrow(start, end) {
      const angle = Math.atan2(end.y - start.y, end.x - start.x);
      drawArrowAt(end.x, end.y, angle);
    }

    function bezierPoint(p0, p1, p2, p3, t) {
      const u = 1 - t;
      const tt = t * t;
      const uu = u * u;
      const uuu = uu * u;
      const ttt = tt * t;
      return {
        x: uuu * p0.x + 3 * uu * t * p1.x + 3 * u * tt * p2.x + ttt * p3.x,
        y: uuu * p0.y + 3 * uu * t * p1.y + 3 * u * tt * p2.y + ttt * p3.y
      };
    }

    function bezierTangent(p0, p1, p2, p3, t) {
      const u = 1 - t;
      return {
        x: 3 * u * u * (p1.x - p0.x) + 6 * u * t * (p2.x - p1.x) + 3 * t * t * (p3.x - p2.x),
        y: 3 * u * u * (p1.y - p0.y) + 6 * u * t * (p2.y - p1.y) + 3 * t * t * (p3.y - p2.y)
      };
    }

    // 解析 binLocationList，按楼层分别建立索引：
    // { byFloor: [ Map(pointNameUpper -> { locationNames, binTaskStrings, binTaskObjects }) ] }
    // 注意：不跨楼层聚合，同名点位仅在当前楼层显示其对应的库位信息。
    function buildBinLocationIndex(layers) {
      const byFloor = [];

      function buildIndexForLayer(layer) {
        const byPointName = new Map();

        function recordEntry(pointName, instanceName, binTaskString) {
          if (!pointName) return;
          const key = String(pointName).trim().toUpperCase();
          let entry = byPointName.get(key);
          if (!entry) { entry = { locationNames: [], binTaskStrings: [], binTaskObjects: [] }; byPointName.set(key, entry); }
          if (instanceName) entry.locationNames.push(String(instanceName).trim());
          if (typeof binTaskString === 'string' && binTaskString.trim() !== '') {
            entry.binTaskStrings.push(binTaskString);
            try {
              const parsed = JSON.parse(binTaskString);
              entry.binTaskObjects.push(parsed);
            } catch (_) {
              // 非 JSON 内容时忽略解析错误，仅保留字符串
            }
          }
        }

        function traverse(obj) {
          if (!obj) return;
          if (Array.isArray(obj)) { obj.forEach(traverse); return; }
          if (typeof obj === 'object') {
            if (Array.isArray(obj.binLocationList)) {
              for (const loc of obj.binLocationList) {
                const pName = String(loc?.pointName || '').trim();
                const iName = String(loc?.instanceName || '').trim();
                const props = Array.isArray(loc?.property) ? loc.property : (Array.isArray(loc?.properties) ? loc.properties : []);
                let taskStrs = [];
                for (const prop of (props || [])) {
                  if (prop && String(prop.key || '').trim() === 'binTask' && typeof prop.stringValue === 'string') {
                    taskStrs.push(prop.stringValue);
                  }
                }
                if (taskStrs.length === 0) {
                  // 某些地图可能将 JSON 存在 "value" 中（Base64 或其它），此处仅兜底尝试字符串字段
                  // 若无可用字符串，则仍记录库位名称，库位详情为空
                  recordEntry(pName, iName, undefined);
                } else {
                  for (const s of taskStrs) recordEntry(pName, iName, s);
                }
              }
            }
            // 继续递归对象子键（仅遍历当前楼层对象）
            for (const k in obj) {
              if (!Object.prototype.hasOwnProperty.call(obj, k)) continue;
              const v = obj[k];
              if (v && (typeof v === 'object' || Array.isArray(v))) traverse(v);
            }
          }
        }

        try { traverse(layer); } catch (_) {}
        return byPointName;
      }

      try {
        for (const layer of (layers || [])) {
          byFloor.push(buildIndexForLayer(layer));
        }
      } catch (_) { /* 忽略异常 */ }

      window.binLocationIndex = { byFloor };
    }

    // 在当前楼层查找点位对应的库位信息，不跨楼层聚合
    function lookupBinLocationInfo(pointName) {
      const key = String(pointName || '').trim().toUpperCase();
      const idx = (typeof currentFloorIndex === 'number') ? currentFloorIndex : 0;
      const byFloor = window.binLocationIndex?.byFloor;
      const map = Array.isArray(byFloor) ? byFloor[idx] : null;
      return (map && map.get(key)) || null;
    }

    // 将 binTaskObjects 中的操作列表格式化为可读文本
    function formatBinTaskDetails(entry) {
      try {
        const objs = Array.isArray(entry?.binTaskObjects) ? entry.binTaskObjects : [];
        const sections = [];
        for (const obj of objs) {
          const arr = Array.isArray(obj) ? obj : [obj];
          for (const item of arr) {
            if (item && typeof item === 'object') {
              for (const actionName of Object.keys(item)) {
                const params = item[actionName];
                const lines = [];
                lines.push(`${actionName}：`);
                if (params && typeof params === 'object') {
                  for (const k of Object.keys(params)) {
                    const v = params[k];
                    const vs = (typeof v === 'string') ? `"${v}"` : String(v);
                    lines.push(` "${k}": ${vs}`);
                  }
                } else {
                  lines.push(` ${String(params)}`);
                }
                sections.push(lines.join('\n'));
              }
            } else if (typeof item === 'string') {
              sections.push(item);
            } else {
              sections.push(String(item));
            }
          }
        }
        if (sections.length > 0) return sections.join('\n\n');
        const raw = Array.isArray(entry?.binTaskStrings) ? entry.binTaskStrings : [];
        return raw.join('\n');
      } catch (_) {
        const raw = Array.isArray(entry?.binTaskStrings) ? entry.binTaskStrings : [];
        return raw.join('\n');
      }
    }

    // 将 binTaskObjects 渲染为卡片布局：每个对象一个卡片，标题为字段名，内部两列显示 key/value
    function renderBinTaskDetails(entry) {
      const container = document.getElementById('stStorageDetails');
      if (!container) return false;
      container.innerHTML = '';
      const objs = Array.isArray(entry?.binTaskObjects) ? entry.binTaskObjects : [];
      let made = false;
      function makeCard(title, kv) {
        const card = document.createElement('div');
        card.className = 'bin-card';
        const t = document.createElement('div');
        t.className = 'bin-card-title';
        t.textContent = title || 'Detail';
        card.appendChild(t);
        for (const [k, v] of kv) {
          const row = document.createElement('div');
          row.className = 'bin-kv';
          const kEl = document.createElement('div');
          kEl.className = 'key';
          kEl.textContent = String(k);
          const vEl = document.createElement('div');
          vEl.className = 'val';
          vEl.textContent = (typeof v === 'string') ? v : String(v);
          row.appendChild(kEl);
          row.appendChild(vEl);
          card.appendChild(row);
        }
        container.appendChild(card);
      }
      for (const obj of objs) {
        const list = Array.isArray(obj) ? obj : [obj];
        for (const item of list) {
          if (item && typeof item === 'object' && Object.keys(item).length > 0) {
            const actionName = Object.keys(item)[0];
            const params = item[actionName];
            const kv = [];
            if (params && typeof params === 'object') {
              for (const k of Object.keys(params)) kv.push([k, params[k]]);
            }
            makeCard(actionName, kv);
            made = true;
          } else if (typeof item === 'string') {
            makeCard('Raw', [['string', item]]);
            made = true;
          }
        }
      }
      if (!made) {
        const raws = Array.isArray(entry?.binTaskStrings) ? entry.binTaskStrings : [];
        for (const r of raws) { makeCard('Raw', [['string', r]]); made = true; }
      }
      return made;
    }

    async function loadMapData() {
      try {
        document.getElementById('loading').style.display = 'block';
        document.getElementById('status').textContent = '正在加载地图数据...';
        const resp = await fetch('/maps/' + CURRENT_MAP_ID);
        if (!resp.ok) throw new Error(`HTTP ${resp.status}: ${resp.statusText}`);
        const raw = await resp.json();
        mapLayers = Array.isArray(raw) ? raw : (raw ? [raw] : []);
        // 构建库位索引
        buildBinLocationIndex(mapLayers);
        // 预取每个楼层（layer）的名称：从 scene 的 list 或对象 name 提取
        floorNames = mapLayers.map(extractFloorNameFromLayer);
        // Fallback：若顶层无法提取楼层名，则从 points 的 layer 字段聚合唯一楼层名
        if (!Array.isArray(floorNames) || floorNames.filter(v => !!v).length === 0) {
          const root = mapLayers.length > 0 ? mapLayers[0] : null;
          const unique = new Set();
          const pts = (root && Array.isArray(root.points)) ? root.points : [];
          pts.forEach(p => {
            const nm = extractFloorNameFromLayer(p.layer || '');
            if (nm) unique.add(nm);
          });
          if (unique.size > 0) {
            floorNames = Array.from(unique);
          }
        }
        currentFloorIndex = 0;
      mapData = mapLayers.length > 0 ? normalizeScene(mapLayers[currentFloorIndex]) : null;
      await loadSceneStations();
        populateFloorSelect();
        updateMapInfo();
        fitMapToView();
        drawMap();
        document.getElementById('status').textContent = '地图加载完成';
      } catch (err) {
        console.error('加载地图数据失败:', err);
        document.getElementById('status').textContent = '加载失败: ' + err.message;
      } finally {
        document.getElementById('loading').style.display = 'none';
      }
    }
    function normalizeScene(scene) {
      // 方案A：统一世界坐标为 y 向上；不再对数据进行 y 取反，
      // 仅在 world<->screen 换算中处理屏幕坐标的 y 反向。
      if (!scene) return null;
      return JSON.parse(JSON.stringify(scene));
    }

    function populateFloorSelect() {
      const sel = document.getElementById('floorSelect');
      if (!sel) return;
      sel.innerHTML = '';
      const availableFloorCount = (Array.isArray(floorNames) && floorNames.length > 0) ? floorNames.length : mapLayers.length;
      if (!Array.isArray(mapLayers) || mapLayers.length === 0 || availableFloorCount === 0) {
        const opt = document.createElement('option');
        opt.value = '';
        opt.textContent = '无楼层';
        sel.appendChild(opt);
        sel.disabled = true;
        return;
      }
      sel.disabled = false;
      for (let i = 0; i < availableFloorCount; i++) {
        const opt = document.createElement('option');
        opt.value = String(i);
        const fname = floorNames[i];
        opt.textContent = fname ? `${fname}` : `${i + 1}层`;
        sel.appendChild(opt);
      }
      sel.value = String(currentFloorIndex);
    }

    function switchFloor(idx) {
      const i = parseInt(idx, 10);
      const availableFloorCount = (Array.isArray(floorNames) && floorNames.length > 0) ? floorNames.length : mapLayers.length;
      if (isNaN(i) || i < 0 || i >= availableFloorCount) return;
      currentFloorIndex = i;
      // 若 mapLayers 仅有一个根对象（楼层来源于 points.layer），仍保持同一 scene；否则切换到对应层
      const layerIndex = Math.min(currentFloorIndex, Math.max(0, mapLayers.length - 1));
      mapData = normalizeScene(mapLayers[layerIndex]);
      // 切换楼层后预取该层站点详情（scene）
      loadSceneStations();
      updateMapInfo();
      fitMapToView();
      drawMap();
      const fname = floorNames[currentFloorIndex];
      document.getElementById('status').textContent = fname ? `已切换到楼层: ${fname}` : `已切换到${i + 1}层`;
    }

    function cycleFloor() {
      const availableFloorCount = (Array.isArray(floorNames) && floorNames.length > 0) ? floorNames.length : mapLayers.length;
      if (availableFloorCount === 0) return;
      const next = (currentFloorIndex + 1) % availableFloorCount;
      switchFloor(next);
      const sel = document.getElementById('floorSelect');
      if (sel) sel.value = String(next);
    }

    function updateMapInfo() { const pc = mapData?.points?.length || 0; const rc = mapData?.routes?.length || 0; document.getElementById('pointCount').textContent = pc; document.getElementById('routeCount').textContent = rc; updateInitialPositionOptions(); }
    function updateInitialPositionOptions() {
      const regMapSel = document.getElementById('registerMapSelect');
      const chosen = regMapSel ? regMapSel.value : '';
      if (regMapSel && /(^|\/)VehicleMap\/[^\/]+\.scene$/.test(chosen)) { updateRegisterInitialPositionOptions(); return; }
      const sel = document.getElementById('initialPosition');
      sel.innerHTML = '<option value="">选择初始位置</option>';
      (mapData?.points || []).forEach(p => { if (p.name) { const opt = document.createElement('option'); opt.value = p.id; opt.textContent = `${p.name} (${p.x.toFixed(2)}, ${p.y.toFixed(2)})`; sel.appendChild(opt); } });
      sel.disabled = false;
    }
    function fitMapToView() { if (!mapData || !mapData.points || mapData.points.length === 0) return; let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity; mapData.points.forEach(p => { const sx = p.x * 20, sy = p.y * 20; minX = Math.min(minX, sx); minY = Math.min(minY, sy); maxX = Math.max(maxX, sx); maxY = Math.max(maxY, sy); }); const mapW = maxX - minX, mapH = maxY - minY, cx = (minX + maxX) / 2, cy = (minY + maxY) / 2; const pad = 50; const sX = (canvas.width - pad * 2) / mapW; const sY = (canvas.height - pad * 2) / mapH; viewTransform.scale = Math.min(sX, sY, 2); viewTransform.x = canvas.width / 2 - cx * viewTransform.scale; viewTransform.y = canvas.height / 2 + cy * viewTransform.scale; updateZoomDisplay(); }
    function updateZoomDisplay() { document.getElementById('zoomLevel').textContent = Math.round(viewTransform.scale * 100) + '%'; }
    function drawMap() { if (!mapData) return; ctx.clearRect(0, 0, canvas.width, canvas.height); if (showGrid) drawGrid(); if (mapData.routes) drawRoutes(); if (mapData.points) drawPoints(); if (equipments && equipments.length > 0) drawEquipments(); if (registeredRobots.length > 0) drawRobots(); }
    function drawGrid() { ctx.save(); ctx.strokeStyle = '#34495e'; ctx.lineWidth = 1; const g = 50 * viewTransform.scale; const ox = viewTransform.x % g, oy = viewTransform.y % g; for (let x = ox; x < canvas.width; x += g) { ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); ctx.stroke(); } for (let y = oy; y < canvas.height; y += g) { ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(canvas.width, y); ctx.stroke(); } ctx.restore(); }
    function drawPoints() {
      (mapData.points || []).forEach(point => {
        // 楼层过滤：仅绘制当前楼层的点
        const currentFloorName = floorNames[currentFloorIndex] || null;
        const pfloor = extractFloorNameFromLayer(point.layer || '');
        if (currentFloorName && pfloor && String(pfloor).trim().toLowerCase() !== String(currentFloorName).trim().toLowerCase()) {
          return;
        }
        const sp = worldToScreen(point.x, point.y);
        if (sp.x < -20 || sp.x > canvas.width + 20 || sp.y < -20 || sp.y > canvas.height + 20) return;
        ctx.save();

        // 动态尺寸与颜色
        let color = '#95a5a6';
        let size = pointDrawSize();
        const t = Number(point.type);
        if (!Number.isNaN(t) && POINT_TYPE_INFO[t]) {
          color = POINT_TYPE_INFO[t].color;
        } else {
          const nm = point.name || '';
          if (nm.startsWith('AP')) { color = '#e74c3c'; }
          else if (nm.startsWith('LM')) { color = '#f39c12'; }
          else if (nm.startsWith('CP')) { color = '#27ae60'; }
        }

        // 绘制圆点
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(sp.x, sp.y, size, 0, 2 * Math.PI);
        ctx.fill();
        ctx.strokeStyle = '#2c3e50';
        ctx.lineWidth = 2;
        ctx.stroke();

        const name = point.name || '';
        // 选中高亮：外圈描边与闪烁轻微效果
        const key = name || point.id;
        let isSelected = !!selectedStationId && key === selectedStationId;
        if (!isSelected && selectedNavStation && selectedNavStation.pos) {
          const hitRadius = pointDrawSize() + 2;
          const spSel = worldToScreen(selectedNavStation.pos.x, selectedNavStation.pos.y);
          const dxs = sp.x - spSel.x, dys = sp.y - spSel.y;
          if (dxs * dxs + dys * dys <= (hitRadius + 4) * (hitRadius + 4)) {
            isSelected = true;
          }
        }
        if (isSelected) {
          ctx.strokeStyle = '#f1c40f';
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.arc(sp.x, sp.y, size + 4, 0, 2 * Math.PI);
          ctx.stroke();
        }

        // 标签
        if (viewTransform.scale > 0.5 && name) {
          ctx.fillStyle = '#ecf0f1';
          ctx.font = '12px Arial';
          ctx.textAlign = 'center';
          ctx.fillText(name, sp.x, sp.y - size - 6);
        }
        ctx.restore();
      });
    }
    function drawRoutes() {
      if (!mapData || !mapData.points) return;
      const pmap = {};
      mapData.points.forEach(p => pmap[p.id] = p);
    
      (mapData.routes || []).forEach(route => {
        const fp = pmap[route.from], tp = pmap[route.to];
        if (!fp || !tp) return;
    
        const dir = getRouteDirection(route);
        // 楼层过滤：路段两端点需在当前楼层
        const currentFloorName = floorNames[currentFloorIndex] || null;
        if (currentFloorName) {
          const nf = String(currentFloorName).trim().toLowerCase();
          const ff = extractFloorNameFromLayer(fp.layer || '');
          const tf = extractFloorNameFromLayer(tp.layer || '');
          const ffn = ff ? String(ff).trim().toLowerCase() : '';
          const tfn = tf ? String(tf).trim().toLowerCase() : '';
          if (ffn && ffn !== nf) return;
          if (tfn && tfn !== nf) return;
        }

        ctx.save();
        const passCode = (route.pass !== undefined) ? Number(route.pass) : 0;
        const baseColor = getRouteColorByPass(passCode);
        ctx.strokeStyle = baseColor;
        ctx.lineWidth = 2;
        ctx.lineCap = 'round';
        if (passCode === 10) {
          ctx.setLineDash([6, 4]);
        } else {
          ctx.setLineDash([]);
        }

        const rid = String(route.id ?? (`${route.from}->${route.to}`));
        const isSelected = !!selectedRouteId && String(selectedRouteId) === rid;
        if (isSelected) {
          ctx.lineWidth = 3;
        }

        if (route.type === 'bezier3' && route.c1 && route.c2) {
          // 世界坐标下的控制点
          const p0 = { x: fp.x, y: fp.y };
          const p1 = { x: route.c1.x, y: route.c1.y };
          const p2 = { x: route.c2.x, y: route.c2.y };
          const p3 = { x: tp.x, y: tp.y };
    
          // 绘制曲线
          const fromScreen = worldToScreen(p0.x, p0.y);
          const c1Screen = worldToScreen(p1.x, p1.y);
          const c2Screen = worldToScreen(p2.x, p2.y);
          const toScreen = worldToScreen(p3.x, p3.y);
    
          ctx.beginPath();
          ctx.moveTo(fromScreen.x, fromScreen.y);
          ctx.bezierCurveTo(c1Screen.x, c1Screen.y, c2Screen.x, c2Screen.y, toScreen.x, toScreen.y);
          ctx.stroke();
    
          // 方向箭头
          if (viewTransform.scale > 0.3) {
            if (dir !== 0) {
              const t = 0.7;
              const q0 = dir > 0 ? p0 : p3;
              const q1 = dir > 0 ? p1 : p2;
              const q2 = dir > 0 ? p2 : p1;
              const q3 = dir > 0 ? p3 : p0;
              const pt = bezierPoint(q0, q1, q2, q3, t);
              const tg = bezierTangent(q0, q1, q2, q3, t);
              const ptScreen = worldToScreen(pt.x, pt.y);
              const tgScreen = {
                x: worldToScreen(q0.x + tg.x, q0.y + tg.y).x - worldToScreen(q0.x, q0.y).x,
                y: worldToScreen(q0.x + tg.x, q0.y + tg.y).y - worldToScreen(q0.x, q0.y).y
              };
              const angle = Math.atan2(tgScreen.y, tgScreen.x);
              drawArrowAt(ptScreen.x, ptScreen.y, angle);
            } else {
              // 双向：两端各画一个箭头
              const t1 = 0.3;
              const pt1 = bezierPoint(p0, p1, p2, p3, t1);
              const tg1 = bezierTangent(p0, p1, p2, p3, t1);
              const pt1Screen = worldToScreen(pt1.x, pt1.y);
              const tg1Screen = {
                x: worldToScreen(p0.x + tg1.x, p0.y + tg1.y).x - worldToScreen(p0.x, p0.y).x,
                y: worldToScreen(p0.x + tg1.x, p0.y + tg1.y).y - worldToScreen(p0.x, p0.y).y
              };
              drawArrowAt(pt1Screen.x, pt1Screen.y, Math.atan2(tg1Screen.y, tg1Screen.x));
    
              const r0 = p3, r1 = p2, r2 = p1, r3 = p0;
              const pt2 = bezierPoint(r0, r1, r2, r3, t1);
              const tg2 = bezierTangent(r0, r1, r2, r3, t1);
              const pt2Screen = worldToScreen(pt2.x, pt2.y);
              const tg2Screen = {
                x: worldToScreen(r0.x + tg2.x, r0.y + tg2.y).x - worldToScreen(r0.x, r0.y).x,
                y: worldToScreen(r0.x + tg2.x, r0.y + tg2.y).y - worldToScreen(r0.x, r0.y).y
              };
              drawArrowAt(pt2Screen.x, pt2Screen.y, Math.atan2(tg2Screen.y, tg2Screen.x));
            }
          }
        } else {
          // 直线
          const fromScreen = worldToScreen(fp.x, fp.y);
          const toScreen = worldToScreen(tp.x, tp.y);
    
          ctx.beginPath();
          ctx.moveTo(fromScreen.x, fromScreen.y);
          ctx.lineTo(toScreen.x, toScreen.y);
          ctx.stroke();
    
          if (viewTransform.scale > 0.3) {
            if (dir === 0) {
              drawArrow(fromScreen, toScreen);
              drawArrow(toScreen, fromScreen);
            } else {
              const start = dir > 0 ? fromScreen : toScreen;
              const end = dir > 0 ? toScreen : fromScreen;
              drawArrow(start, end);
            }
          }
        }
    
        ctx.restore();
      });
    }
    function drawRobots() {
      registeredRobots.forEach(robot => {
        // 楼层过滤：根据 scene 的楼层名与机器人当前加载 scene 的文件名匹配
        if (robot.currentMap) {
          const robotFloor = extractFloorFromMapId(robot.currentMap);
          const currentFloorName = floorNames[currentFloorIndex] || null;
          if (
            robotFloor && currentFloorName &&
            String(robotFloor).trim().toLowerCase() !== String(currentFloorName).trim().toLowerCase()
          ) {
            return; // 不在当前楼层，不渲染
          }
        }
        let pos = robot.currentPosition || robot.initialPosition || null;
        if (!pos) return;
        const sp = worldToScreen(pos.x, pos.y);
        if (sp.x < -50 || sp.x > canvas.width + 50 || sp.y < -50 || sp.y > canvas.height + 50) return;
        // 安全范围绘制（雷达/水波纹动画）
        try { drawSafetyRange(sp.x, sp.y, ((pos.theta ?? pos.orientation) || 0), robot); } catch (_) { /* 忽略绘制异常 */ }
        drawRobotIcon(sp.x, sp.y, ((pos.theta ?? pos.orientation) || 0), robot);
      });
    }

    function extractFloorNameFromLayer(layer) {
      try {
        // 新增：字符串楼层名（常见于点/路段的 layer 字段）
        if (typeof layer === 'string') {
          const v = layer.trim();
          if (v) return v;
        }
        // 按照 scene 的 list，依次提取对象下的一级 key: name（字符串）
        if (layer && Array.isArray(layer.list)) {
          for (const item of layer.list) {
            if (item && typeof item.name === 'string') {
              const v = item.name.trim();
              if (v) return v; // 不限制为数字，直接使用字符串名称
            }
          }
        }
        // 兜底：如果楼层对象本身有 name
        if (layer && typeof layer.name === 'string' && layer.name.trim() !== '') {
          return layer.name.trim();
        }
      } catch (e) { /* 忽略异常并返回 null */ }
      return null;
    }
    function extractFloorFromMapId(mapId) {
      const raw = String(mapId || '').trim();
      if (!raw) return null;
      const mScene = /^VehicleMap\/(.+)\.scene$/i.exec(raw);
      if (mScene) return mScene[1];
      const mViewer = /^ViewerMap\/(.+)\.scene$/i.exec(raw);
      if (mViewer) return mViewer[1];
      const fname = raw.replace(/\\/g, '/').split('/').pop();
      return (fname || '').replace(/\.scene$/i, '') || null;
    }

    function drawRobotIcon(x, y, rotationDeg, robot) {
      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(Math.PI - rotationDeg);
      const s = Math.max(0.5, Math.min(2, viewTransform.scale));
      ctx.scale(s, s);

      // 机器人身体（24x24）
      ctx.fillStyle = '#4A90E2';
      ctx.strokeStyle = '#2E5C8A';
      ctx.lineWidth = 1;
      ctx.fillRect(-12, -12, 24, 24);
      ctx.strokeRect(-12, -12, 24, 24);

      // 顶部半圆盖
      ctx.fillStyle = '#6BB6FF';
      ctx.beginPath();
      ctx.arc(0, -12, 12, 0, Math.PI, true);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();

      // 朝向箭头（指向前方：局部坐标 -Y，与 0rad 一致）
      ctx.fillStyle = '#FF6B6B';
      ctx.strokeStyle = '#D63031';
      ctx.beginPath();
      ctx.moveTo(0, -22);
      ctx.lineTo(-4, -14);
      ctx.lineTo(4, -14);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();

      // 托盘绘制：模型 footprint（米），按米转换
      const fp = robot.shelfModel && robot.shelfModel.footprint;
      const wm = Number(fp && (fp.width_m ?? fp.width));
      const lm = Number(fp && (fp.length_m ?? fp.length));
      if (isFinite(wm) && isFinite(lm) && wm > 0 && lm > 0) {
        const meterScale = 20; // 与 worldToScreen 保持一致
        palletW = wm * meterScale;
        palletL = lm * meterScale;
      }
      const shouldDrawPallet = !!robot.hasPallet || !!robot._palletAnimLoading || !!robot._palletAnimUnloading;
      if (shouldDrawPallet) {
        // 动画：加载时 3 秒淡入，并略微上滑（+6px 到 0），最终与身体居中重合
        let alpha = 1.0;
        let slide = 0;
        if (robot._palletAnimLoading) {
          const p = Math.max(0, Math.min(1, robot._palletAnimProgress || 0));
          alpha = p;
          slide = (1 - p) * 6; // 初始更靠后，逐步贴近
        } else if (robot._palletAnimUnloading) {
          const p = Math.max(0, Math.min(1, robot._palletAnimProgress || 0));
          alpha = 1 - p;
          slide = p * 6; // 卸载：逐步远离
        }
        ctx.save();
        ctx.globalAlpha = alpha;
        ctx.fillStyle = '#8B5E3C'; // 木质托盘色
        ctx.strokeStyle = '#5D3A1A';
        ctx.lineWidth = 1;
        // 矩形托盘：与机器人正方体身体居中重合
        ctx.fillRect(-palletW / 2, -palletL / 2 + slide, palletW, palletL);
        ctx.strokeRect(-palletW / 2, -palletL / 2 + slide, palletW, palletL);
        // 简单栈板纹理线
        ctx.strokeStyle = '#704A2B';
        for (let i = 1; i <= 2; i++) {
          const y = -palletL / 2 + slide + (i * palletL / 3);
          ctx.beginPath();
          ctx.moveTo(-palletW / 2 + 2, y);
          ctx.lineTo(palletW / 2 - 2, y);
          ctx.stroke();
        }
        ctx.restore();
      }
      // 叉高指示：在机器人右侧绘制竖直高度条，并标注数值
      try {
        const fhDisplay = Number(robot && robot._forkBarDisplayHeight);
        const fhRaw = Number(robot && robot.forkHeight);
        const fh = (isFinite(fhDisplay) ? fhDisplay : fhRaw);
        if (isFinite(fh) && fh >= 0) {
          // 将“米高度”压缩到像素：每 0.01m ≈ 1px，上限 30px，最小 2px
          const barH = Math.max(2, Math.min(30, fh * 160));
          ctx.save();
          ctx.fillStyle = '#f1c40f';
          ctx.strokeStyle = '#f39c12';
          ctx.lineWidth = 1;
          // 竖条位于机器人身体右侧（局部坐标 +X 方向），自身体顶部向上延伸
          ctx.fillRect(16, 8 - barH, 3, barH);
          ctx.strokeRect(16, 8 - barH, 3, barH);
          if (viewTransform.scale > 0.8) {
            ctx.fillStyle = '#ecf0f1';
            ctx.font = '6px Arial';
            ctx.textAlign = 'left';
            ctx.fillText(`${truncateToOneDecimal(fh).toFixed(1)}m`, 11, 8 - barH - 2);
          }
          ctx.restore();
        }
      } catch (_) { /* 忽略绘制异常 */ }

      ctx.restore();

      // 名称标注
      if (viewTransform.scale > 0.5 && robot.robot_name) {
        ctx.save();
        ctx.fillStyle = '#ecf0f1';
        ctx.font = '12px Arial';
        ctx.textAlign = 'center';
        ctx.strokeStyle = '#2c3e50';
        ctx.lineWidth = 3;
        ctx.strokeText(robot.robot_name, x, y - 5);
        ctx.fillText(robot.robot_name, x, y - 5);
        ctx.restore();
      }
    }

    // 安全范围开关与绘制（雷达/水波纹动画）
    let showSafetyRange = true;
    function toggleSafetyRange() { showSafetyRange = !showSafetyRange; try { document.getElementById('status').textContent = showSafetyRange ? '安全范围：开启' : '安全范围：关闭'; setTimeout(() => document.getElementById('status').textContent = '准备就绪', 2000); } catch (_) {} }

    function drawSafetyRange(cx, cy, thetaRad, robot) {
      if (!showSafetyRange) return;
      // 物理尺寸（米）
      const defaults = { width: 0.745, length: 1.03 };
      const cp = robot && robot.collisionParams ? robot.collisionParams : {};
      const baseWm = (typeof cp.width === 'number' && cp.width > 0) ? Number(cp.width) : defaults.width;
      const baseLm = (typeof cp.length === 'number' && cp.length > 0) ? Number(cp.length) : defaults.length;
      const fp = robot && robot.shelfModel && robot.shelfModel.footprint ? robot.shelfModel.footprint : null;
      const shelfWm = fp ? Number(fp.width_m ?? fp.width) : NaN;
      const shelfLm = fp ? Number(fp.length_m ?? fp.length) : NaN;
      const hasShelf = isFinite(shelfWm) && isFinite(shelfLm) && shelfWm > 0 && shelfLm > 0;
      const safeFactor = 1.05; // 与服务端一致
      // 取 AGV 与托盘的矩形，以相同朝向叠加，最终安全范围为同向矩形的并集
      const finalWm = (hasShelf ? Math.max(baseWm, shelfWm) : baseWm) * safeFactor; // 宽（局部 X）
      const finalLm = (hasShelf ? Math.max(baseLm, shelfLm) : baseLm) * safeFactor; // 长（局部 Y）

      // 转屏：米→像素（保持 worldToScreen 的比例与缩放）
      const meterScale = 20;
      const wpx = finalWm * meterScale * viewTransform.scale;
      const lpx = finalLm * meterScale * viewTransform.scale;

      // 绘制“朝向一致”的旋转矩形（中心前移偏移量）
      ctx.save();
      ctx.translate(cx, cy);
      ctx.rotate(Math.PI - thetaRad);
      // 将几何中心沿车头方向（局部 -Y）平移 CENTER_FORWARD_OFFSET_M 米
      try {
        const offsetPx = (Number(window.CENTER_FORWARD_OFFSET_M) || 0) * meterScale * viewTransform.scale;
        if (offsetPx) ctx.translate(0, -offsetPx);
      } catch (_) {}
      const isCollision = !!(robot && robot._collisionActive);
      const fillColor = isCollision ? '#e74c3c' : '#3498db';
      const strokeColor = isCollision ? '#c0392b' : '#3498db';
      const fillAlpha = isCollision ? 0.18 : 0.12;
      const strokeAlpha = isCollision ? 0.8 : 0.45;
      const rippleBaseColor = isCollision ? '231, 76, 60' : '52, 152, 219';
      const rippleWidth = isCollision ? 2.8 : 2.2;
      // 基础填充与描边（加深可视性）
      ctx.globalAlpha = fillAlpha;
      ctx.fillStyle = fillColor;
      ctx.fillRect(-wpx / 2, -lpx / 2, wpx, lpx);
      ctx.globalAlpha = strokeAlpha;
      ctx.strokeStyle = strokeColor;
      ctx.lineWidth = 1.8;
      ctx.setLineDash([8, 6]);
      ctx.strokeRect(-wpx / 2, -lpx / 2, wpx, lpx);
      ctx.globalAlpha = 1.0;

      // 水波纹动画：在旋转矩形内剪裁后绘制同心圆，表达“探测中”
      ctx.save();
      ctx.beginPath();
      ctx.rect(-wpx / 2, -lpx / 2, wpx, lpx);
      ctx.clip();
      const now = Date.now();
      const t = (now % 2000) / 2000; // 2s 周期
      const maxR = Math.sqrt((wpx * 0.5) ** 2 + (lpx * 0.5) ** 2);
      for (let i = 0; i < 4; i++) {
        const p = (t + i / 4) % 1;
        const r = 10 + p * maxR;
        const alpha = (isCollision ? 0.70 : 0.55) * (1 - p);
        ctx.beginPath();
        ctx.strokeStyle = `rgba(${rippleBaseColor}, ${alpha.toFixed(3)})`;
        ctx.lineWidth = rippleWidth;
        // 圆心取机器人中心（局部坐标原点）
        ctx.arc(0, 0, r, 0, Math.PI * 2);
        ctx.stroke();
      }
      ctx.restore();
      ctx.restore();
    }

    // 控制
    function resetView() { fitMapToView(); drawMap(); }
    function toggleGrid() { showGrid = !showGrid; drawMap(); }
    function toggleSidebar() { const s = document.getElementById('sidebar'), t = document.getElementById('sidebarToggle'), c = document.getElementById('canvasContainer'); sidebarOpen = !sidebarOpen; if (sidebarOpen) { s.classList.add('open'); c.classList.add('sidebar-open'); t.classList.add('open'); t.textContent = '收起'; } else { s.classList.remove('open'); c.classList.remove('sidebar-open'); t.classList.remove('open'); t.textContent = '打开'; } setTimeout(resizeCanvas, 400); }
    function switchTab(name) { document.querySelectorAll('.tab-button').forEach(b => b.classList.remove('active')); document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active')); if (name === 'register') { document.querySelector('.tab-button[onclick="switchTab(\'register\')"]').classList.add('active'); document.getElementById('registerTab').classList.add('active'); updateRegisterMapOptions(); } else if (name === 'list') { document.querySelector('.tab-button[onclick="switchTab(\'list\')"]').classList.add('active'); document.getElementById('listTab').classList.add('active'); } else { document.querySelector('.tab-button[onclick="switchTab(\'equip\')"]').classList.add('active'); document.getElementById('equipTab').classList.add('active'); loadEquipmentList(); } }

    // 机器人管理（适配当前后端）
    async function loadRobotList() { try { const resp = await fetch(`${API_BASE_URL}/agvs`); if (!resp.ok) throw new Error(`HTTP ${resp.status}: ${resp.statusText}`); const agvs = await resp.json(); registeredRobots = (agvs || []).map(info => ({ robot_name: info.serial_number, type: info.type, ip: info.IP, manufacturer: info.manufacturer, vda_version: info.vda_version, battery: 100, initialPosition: null, currentPosition: null, currentMap: null, commConnected: false, instanceStatus: '停止', lastUpdateTs: 0, hasPallet: false, forkHeight: 0 })); updateRobotList(); drawMap(); } catch (err) { console.error('加载机器人列表失败:', err); document.getElementById('status').textContent = '加载机器人列表失败: ' + err.message; } }
    function clearRobotForm() {
      document.getElementById('robotName').value = '';
      document.getElementById('robotType').value = 'AGV';
      document.getElementById('robotIP').value = '';
      const regMapSel = document.getElementById('registerMapSelect');
      if (regMapSel) regMapSel.value = '';
      const lbl = document.getElementById('registerMapSelectedLabel');
      if (lbl) lbl.textContent = '未设置';
      const sel = document.getElementById('initialPosition');
      if (sel) {
        sel.innerHTML = '<option value="">请先选择地图</option>';
        sel.disabled = true;
      }
    }

    let equipments = [];
    async function loadEquipmentList() { try { const resp = await fetch(`${API_BASE_URL}/equipments`); if (!resp.ok) throw new Error(`HTTP ${resp.status}: ${resp.statusText}`); equipments = await resp.json(); updateEquipmentList(); } catch (err) { console.error('加载设备列表失败:', err); const el = document.getElementById('status'); if (el) el.textContent = '加载设备列表失败: ' + err.message; } }
    function updateEquipmentList() { const c = document.getElementById('equipListContainer'); if (!c) return; if (!equipments || equipments.length === 0) { c.innerHTML = '<p style="color:#bdc3c7;font-style:italic;">暂无设备</p>'; return; } c.innerHTML = equipments.map(eq => { const mqtt = eq.mqtt || {}; const title = (eq.name || eq.dir_name || '设备'); const line1 = `类型: ${'SimEquip'} | IP: ${eq.ip || '-'} | 厂商: ${eq.manufacturer || '-'}`; const line2 = `站点: ${eq.site || '-'} | 地图: ${eq.map_id || '-'}`; const line3 = `动作时长: ${typeof eq.action_time !== 'undefined' && eq.action_time !== null ? String(eq.action_time) : '-'} | 触发模式: ${eq.trigger_mode || '-'}`; const line4 = `MQTT: ${mqtt.host || '-'}:${mqtt.port || '-'} (${mqtt.vda_interface || '-'}) | 版本: ${eq.vda_full_version || eq.vda_version || '-'}`; return `<div class=\"robot-item\"><div class=\"robot-header\"><div class=\"robot-name\">${title}</div></div><div class=\"robot-info\" style=\"word-break:break-all;\">${line1}<br>${line2}<br>${line3}<br>${line4}</div></div>`; }).join(''); }
    function getEquipmentType(eq) { const nm = String(eq?.name || eq?.dir_name || '').toLowerCase(); if (nm.includes('door')) return 'door'; if (nm.includes('elevator')) return 'elevator'; if (nm.includes('light')) return 'light'; if (nm.includes('caller')) return 'caller'; return 'device'; }
    function findPointByNameOrId(name) { if (!mapData || !Array.isArray(mapData.points)) return null; const key = String(name || '').trim().toLowerCase(); if (!key) return null; for (const p of mapData.points) { const nm = String(p.name || '').trim().toLowerCase(); const id = String(p.id || '').trim().toLowerCase(); if ((nm && nm === key) || (id && id === key)) return p; } for (const p of mapData.points) { const nm = String(p.name || '').toLowerCase(); if (key && nm && nm.includes(key)) return p; } return null; }
    function findRouteByIdOrDesc(key) { if (!mapData || !Array.isArray(mapData.routes)) return null; const k = String(key || '').trim().toLowerCase(); if (!k) return null; for (const r of mapData.routes) { const id = String(r.id ?? `${r.from}->${r.to}`).trim().toLowerCase(); const desc = String(r.desc || '').trim().toLowerCase(); if (id === k || (desc && desc === k)) return r; } for (const r of mapData.routes) { const id = String(r.id ?? `${r.from}->${r.to}`).toLowerCase(); const desc = String(r.desc || '').toLowerCase(); if ((id && id.includes(k)) || (desc && desc.includes(k))) return r; } return null; }
    function routeMidPoint(route) { const pmap = {}; (mapData.points || []).forEach(p => { pmap[String(p.id)] = p; }); const fp = pmap[String(route.from)]; const tp = pmap[String(route.to)]; if (!fp || !tp) return null; if (route.type === 'bezier3' && route.c1 && route.c2) { const p0 = { x: fp.x, y: fp.y }; const p1 = { x: route.c1.x, y: route.c1.y }; const p2 = { x: route.c2.x, y: route.c2.y }; const p3 = { x: tp.x, y: tp.y }; const pt = bezierPoint(p0, p1, p2, p3, 0.5); return pt; } return { x: (fp.x + tp.x) / 2, y: (fp.y + tp.y) / 2 }; }
    function computeEquipmentAnchor(eq) { const floor = extractFloorFromMapId(eq?.map_id); const currentFloorName = floorNames[currentFloorIndex] || null; if (floor && currentFloorName && String(floor).trim().toLowerCase() !== String(currentFloorName).trim().toLowerCase()) return null; const site = String(eq?.site || '').trim(); if (site) { const p = findPointByNameOrId(site); if (p) return { x: Number(p.x), y: Number(p.y) }; const r = findRouteByIdOrDesc(site); if (r) { const mid = routeMidPoint(r); if (mid) return mid; } } const r0 = (mapData.routes || [])[0]; if (r0) { const mid = routeMidPoint(r0); if (mid) return mid; } const p0 = (mapData.points || [])[0]; if (p0) return { x: Number(p0.x), y: Number(p0.y) }; return null; }
    function drawEquipmentIcon(x, y, type) { ctx.save(); const sp = worldToScreen(x, y); if (sp.x < -50 || sp.x > canvas.width + 50 || sp.y < -50 || sp.y > canvas.height + 50) { ctx.restore(); return; } ctx.translate(sp.x, sp.y); const s = Math.max(0.6, Math.min(2.2, viewTransform.scale)); ctx.scale(s, s); if (type === 'door') { ctx.fillStyle = '#7f8c8d'; ctx.strokeStyle = '#2c3e50'; ctx.lineWidth = 2; ctx.fillRect(-16, -20, 12, 40); ctx.fillRect(4, -20, 12, 40); ctx.strokeRect(-16, -20, 12, 40); ctx.strokeRect(4, -20, 12, 40); } else if (type === 'elevator') { ctx.fillStyle = '#34495e'; ctx.strokeStyle = '#2c3e50'; ctx.lineWidth = 2; ctx.fillRect(-18, -18, 36, 36); ctx.strokeRect(-18, -18, 36, 36); ctx.fillStyle = '#ecf0f1'; ctx.beginPath(); ctx.moveTo(0, -12); ctx.lineTo(-8, 0); ctx.lineTo(8, 0); ctx.closePath(); ctx.fill(); ctx.beginPath(); ctx.moveTo(0, 12); ctx.lineTo(-8, 0); ctx.lineTo(8, 0); ctx.closePath(); ctx.fill(); } else if (type === 'light') { ctx.fillStyle = '#f1c40f'; ctx.strokeStyle = '#d35400'; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(0, -6, 10, 0, Math.PI * 2); ctx.fill(); ctx.stroke(); ctx.fillStyle = '#f39c12'; ctx.fillRect(-6, 4, 12, 8); for (let i = 0; i < 6; i++) { const ang = (Math.PI * 2 / 6) * i; const rx = Math.cos(ang) * 20; const ry = Math.sin(ang) * 20; ctx.beginPath(); ctx.moveTo(0, -6); ctx.lineTo(rx, ry - 6); ctx.strokeStyle = '#f1c40f'; ctx.lineWidth = 2; ctx.stroke(); } } else if (type === 'caller') { ctx.fillStyle = '#e74c3c'; ctx.strokeStyle = '#c0392b'; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(0, 0, 14, 0, Math.PI * 2); ctx.fill(); ctx.stroke(); ctx.fillStyle = '#ecf0f1'; ctx.fillRect(-2, -6, 4, 8); ctx.beginPath(); ctx.arc(0, 8, 2, 0, Math.PI * 2); ctx.fill(); } else { ctx.fillStyle = '#3498db'; ctx.strokeStyle = '#2c3e50'; ctx.lineWidth = 2; ctx.fillRect(-14, -14, 28, 28); ctx.strokeRect(-14, -14, 28, 28); } ctx.restore(); }
    function drawEquipments() { for (const eq of (equipments || [])) { const anchor = computeEquipmentAnchor(eq); if (!anchor) continue; const tp = getEquipmentType(eq); drawEquipmentIcon(anchor.x, anchor.y, tp); } }

    async function updateRegisterMapOptions() {
      const sel = document.getElementById('registerMapSelect');
      if (!sel) return;
      sel.innerHTML = '<option value="">请选择地图</option>';
      try {
        const resp = await fetch(`${API_BASE_URL}/maps`);
        if (!resp.ok) throw new Error(`HTTP ${resp.status}: ${resp.statusText}`);
        const files = await resp.json();
        (files || []).forEach(name => {
          const opt = document.createElement('option');
          opt.value = name;
          opt.textContent = name;
          sel.appendChild(opt);
        });
        if (CURRENT_MAP_ID && CURRENT_MAP_ID.startsWith('VehicleMap/')) {
          sel.value = CURRENT_MAP_ID;
        }
      } catch (err) {
        console.error('加载地图列表失败:', err);
        const opt = document.createElement('option');
        opt.value = CURRENT_MAP_ID;
        opt.textContent = `已加载地图 (${CURRENT_MAP_ID})`;
        sel.appendChild(opt);
        sel.value = CURRENT_MAP_ID;
      }
      const mapLabel = document.getElementById('registerMapSelectedLabel');
      if (mapLabel) mapLabel.textContent = sel.value || '未设置';
      updateRegisterInitialPositionOptions();
    }

    async function updateRegisterInitialPositionOptions() {
      const sel = document.getElementById('initialPosition');
      const selMap = document.getElementById('registerMapSelect');
      const chosen = selMap ? selMap.value : '';
      sel.innerHTML = '';
      const placeholder = document.createElement('option');
      placeholder.value = '';
      placeholder.textContent = (typeof chosen === 'string' && /(^|\/)VehicleMap\/[^\/]+\.scene$/.test(chosen)) ? '站点加载中...' : '请先选择地图';
      sel.appendChild(placeholder);
      sel.disabled = true;

      if (!chosen || !(/(^|\/)VehicleMap\/[^\/]+\.scene$/.test(chosen))) {
        return;
      }

      const fname = String(chosen).split('/').pop();
      window.registerSceneStationsCache = window.registerSceneStationsCache || {};
      let stations = window.registerSceneStationsCache[fname];
      if (!stations) {
        try {
          const resp = await fetch(`/maps/VehicleMap/${encodeURIComponent(fname)}`);
          if (!resp.ok) throw new Error(`站点获取失败: ${resp.status}`);
          const data = await resp.json();
          const allowedPrefixes = ['AP','CP','PP','LM','WP'];
          const startsAllowed = (txt) => allowedPrefixes.some(pref => String(txt || '').trim().startsWith(pref));
          const root = Array.isArray(data) ? data[0] : data;
          const points = (root && Array.isArray(root.points)) ? root.points : [];
          stations = points.filter(p => {
            const nm = String(p.name || p.id || '').trim();
            return nm && startsAllowed(nm);
          }).map(p => ({ id: String(p.id || p.name), instanceName: String(p.name || p.id), pointName: String(p.name || p.id), pos: { x: Number(p.x), y: Number(p.y) } }));
          window.registerSceneStationsCache[fname] = stations;
        } catch (e) {
          console.error('加载站点失败:', e);
          stations = [];
        }
      }

      sel.innerHTML = '<option value="">选择初始位置</option>';
      stations.forEach(s => {
        const id = String(s.id || s.instanceName || s.pointName);
        const name = String(s.instanceName || s.pointName || id);
        const px = (s && s.pos && typeof s.pos.x !== 'undefined') ? Number(s.pos.x) : Number(s.x);
        const py = (s && s.pos && typeof s.pos.y !== 'undefined') ? Number(s.pos.y) : Number(s.y);
        const opt = document.createElement('option');
        opt.value = id;
        opt.textContent = `${name} (${isFinite(px) ? px.toFixed(2) : 'NaN'}, ${isFinite(py) ? py.toFixed(2) : 'NaN'})`;
        sel.appendChild(opt);
      });
      sel.disabled = false;
    }
    async function registerRobot() { const name = document.getElementById('robotName').value.trim(); const type = document.getElementById('robotType').value; const ip = document.getElementById('robotIP').value.trim(); const manu = document.getElementById('robotManufacturer').value.trim() || 'SEER'; const ver = document.getElementById('robotVersion').value.trim() || 'v2'; const initId = document.getElementById('initialPosition').value; const mapVal = document.getElementById('registerMapSelect').value; if (!name) { try { window.printErrorToStatus('请输入机器人名称','注册'); } catch (_) {} return; } if (!ip) { try { window.printErrorToStatus('请输入机器人IP地址','注册'); } catch (_) {} return; } if (!initId) { try { window.printErrorToStatus('请选择初始位置','注册'); } catch (_) {} return; } const ipRegex = /^(\d{1,3}\.){3}\d{1,3}$/; if (!ipRegex.test(ip)) { try { window.printErrorToStatus('请输入有效的IP地址格式','注册'); } catch (_) {} return; } const payload = [{ serial_number: name, manufacturer: manu, type: type, vda_version: ver, IP: ip }]; try { const resp = await fetch(`${API_BASE_URL}/agvs/register`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) }); if (!resp.ok) throw new Error(`HTTP ${resp.status}: ${resp.statusText}`); const result = await resp.json(); if ((result.registered || []).includes(name)) { await loadRobotList(); const robot = registeredRobots.find(r => r.robot_name === name); let pos = null; if (mapVal && /(^|\/)VehicleMap\/[^\/]+\.scene$/.test(mapVal)) { const fname = String(mapVal).split('/').pop(); window.registerSceneStationsCache = window.registerSceneStationsCache || {}; let stations = window.registerSceneStationsCache[fname]; if (!stations) { try { const sresp = await fetch(`/maps/VehicleMap/${encodeURIComponent(fname)}`); if (sresp.ok) { const data = await sresp.json(); const root = Array.isArray(data) ? data[0] : data; const points = (root && Array.isArray(root.points)) ? root.points : []; const allowedPrefixes = ['AP','CP','PP','LM','WP']; const startsAllowed = (txt) => allowedPrefixes.some(pref => String(txt || '').trim().toUpperCase().startsWith(pref)); stations = points.filter(p => startsAllowed(String(p.name || p.id || ''))).map(p => ({ id: String(p.id || p.name), instanceName: String(p.name || p.id), pointName: String(p.name || p.id), pos: { x: Number(p.x), y: Number(p.y) } })); } } catch (e) { /* 忽略一次失败 */ } } const s = (stations || []).find(x => String(x.id || x.instanceName || x.pointName) === initId); if (s) { const px = (s && s.pos && typeof s.pos.x !== 'undefined') ? Number(s.pos.x) : Number(s.x); const py = (s && s.pos && typeof s.pos.y !== 'undefined') ? Number(s.pos.y) : Number(s.y); if (isFinite(px) && isFinite(py)) { pos = { x: px, y: py, theta: 0 }; } } } else { const point = (mapData?.points || []).find(p => String(p.id || p.name) === initId); if (point) { pos = { x: point.x, y: point.y, theta: 0 }; } } // 同步地图与初始位置到后端（持久化并发布 initPosition）
      // 使用即时动作 switchMap 设置地图与初始位置（避免与动态配置冲突）
      if (mapVal && /(^|\/)(VehicleMap|ViewerMap)\/[^\/]+\.scene$/.test(mapVal)) {
        const swBody = { map: mapVal };
        if (initId) swBody.switch_point = initId;
        if (pos && isFinite(pos.x) && isFinite(pos.y)) { swBody.center_x = pos.x; swBody.center_y = pos.y; }
        try {
          const swResp = await fetch(`${API_BASE_URL}/agv/${encodeURIComponent(name)}/instant/switch-map`, {
            method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(swBody)
          });
          if (!swResp.ok) console.warn('注册后 switchMap 失败:', swResp.status);
        } catch (e) { console.warn('注册后 switchMap 异常:', e); }
      }
      if (robot && pos) { robot.initialPosition = pos; /* 地图由状态更新覆盖，不在此处强设 */ }
      clearRobotForm();
      document.getElementById('status').textContent = `机器人 ${name} 注册成功`;
      setTimeout(() => document.getElementById('status').textContent = '准备就绪', 3000);
    } else { try { window.printErrorToStatus('注册失败: ' + JSON.stringify(result),'注册'); } catch (_) {} }
  } catch (err) { console.error('注册机器人失败:', err); try { window.printErrorToStatus('注册机器人失败: ' + (err && err.message ? err.message : String(err)),'注册'); } catch (_) {} document.getElementById('status').textContent = '注册失败: ' + (err && err.message ? err.message : String(err)); }
}
    async function removeRobot(serial) { if (!confirm('确定要删除这个机器人吗？')) return; try { const resp = await fetch(`${API_BASE_URL}/agvs/${serial}`, { method: 'DELETE' }); if (!resp.ok) throw new Error(`HTTP ${resp.status}: ${resp.statusText}`); await loadRobotList(); document.getElementById('status').textContent = '机器人已删除'; setTimeout(() => document.getElementById('status').textContent = '准备就绪', 2000); } catch (err) { console.error('删除机器人失败:', err); try { window.printErrorToStatus('删除机器人失败: ' + (err && err.message ? err.message : String(err)),'删除'); } catch (_) {} } }

 function updateRobotList() { const c = document.getElementById('robotListContainer'); if (registeredRobots.length === 0) { c.innerHTML = '<p style="color:#bdc3c7;font-style:italic;">暂无注册的机器人</p>'; return; } c.innerHTML = registeredRobots.map(robot => { const battery = robot.battery || 0; const batteryText = truncateToOneDecimal(Number(battery)).toFixed(1); const pos = robot.currentPosition || robot.initialPosition; const posText = pos ? `当前位置: (${pos.x.toFixed(2)}, ${pos.y.toFixed(2)}) | 方向: ${(pos.theta || 0).toFixed(2)}` : '位置未知'; const selectedStyle = (selectedRobotId === robot.robot_name) ? 'border-left:4px solid #2ecc71;background:#3b4f63;' : ''; const commText = robot.commConnected ? '连接' : '断开'; const commColor = robot.commConnected ? '#00ff00' : '#ff0000'; const instStatus = robot.instanceStatus || '停止'; const instText = instStatus; const instColor = instStatus === '启动' ? '#00ff00' : '#ff0000'; const mapText = robot.currentMap ? robot.currentMap : '未设置'; const fhText = (typeof robot.forkHeight !== 'undefined' && robot.forkHeight !== null) ? `${truncateToOneDecimal(Number(robot.forkHeight)).toFixed(1)} m` : '-'; return `<div class=\"robot-item\" style=\"${selectedStyle}\" onclick=\"selectRobot('${robot.robot_name}')\"><div class=\"robot-header\"><div class=\"robot-name\">${robot.robot_name}</div></div><div class=\"robot-info\" style=\"word-break:break-all;\">类型: ${robot.type} | IP: ${robot.ip} | 厂商: ${robot.manufacturer || '未知'} | 地图: ${mapText}<br>${posText} | 叉高: ${fhText}<br><span style=\"color:${commColor}\">电量: ${batteryText}%</span> | <span style=\"color:${commColor}\">通信状态: ${commText}</span> | <span style=\"color:${instColor}\">实例状态: ${instText}</span></div><div class=\"robot-actions\"><button class=\"btn-small btn-danger\" onclick=\"removeRobot('${robot.robot_name}')\">删除</button><button class=\"btn-small btn-config-small\" onclick=\"openRobotConfig('${robot.robot_name}')\">配置</button></div></div>`; }).join(''); }

    // 配置模态框（实例卡片配置菜单）
    let currentConfigRobotId = null;
    async function openRobotConfig(id) {
      currentConfigRobotId = id;
      const robot = registeredRobots.find(r => r.robot_name === id);
      if (!robot) return;
      // 预填数据
      document.getElementById('configRobotName').value = robot.robot_name || '';
      const t = robot.type || 'AGV';
      document.getElementById('configRobotType').value = (t === 'Forklift' ? 'Fork' : (t === 'AMR' ? 'Load' : t));
      await updateConfigMapOptions();
      const selMap = document.getElementById('configMapSelect');
      if (selMap) { selMap.addEventListener('change', () => { updateConfigInitialPositionOptions(); }); }
      if (robot.currentMap && robot.currentMap.startsWith('VehicleMap/')) {
        // 如果列表中存在，则预选当前地图
        const exists = Array.from(selMap.options).some(o => o.value === robot.currentMap);
        if (exists) selMap.value = robot.currentMap;
      }
      const mapLabel = document.getElementById('configMapSelectedLabel');
      if (mapLabel) mapLabel.textContent = robot.currentMap || '未设置';
      document.getElementById('configRobotIP').value = robot.ip || '';
      document.getElementById('configRobotManufacturer').value = robot.manufacturer || '';
      document.getElementById('configRobotVersion').value = 'v2';
      if (selMap && !selMap.value && robot.currentMap && /(^|\/)VehicleMap\/[^\/]+\.scene$/.test(robot.currentMap)) { selMap.value = robot.currentMap; }
      updateConfigInitialPositionOptions();
      const pos = robot.currentPosition || robot.initialPosition || { x: 0, y: 0, theta: 0 };
      document.getElementById('configBattery').value = robot.battery ?? 100;
      document.getElementById('configOrientation').value = pos.theta ?? 0;
      // 预填物理参数（factsheet 默认值）
      try { await prefillFactsheetPhysicalParams(robot); } catch (e) { console.warn('预填物理参数失败', e); }
      // 默认选中“基本”标签
      switchConfigTab('basic');
      // 打开弹窗
      const modal = document.getElementById('configModal');
      modal.style.display = 'flex';
    }
    function closeConfigModal() {
      const modal = document.getElementById('configModal');
      modal.style.display = 'none';
      currentConfigRobotId = null;
    }
    async function updateConfigInitialPositionOptions() {
      const sel = document.getElementById('configInitialPosition');
      const selMap = document.getElementById('configMapSelect');
      const chosen = selMap ? selMap.value : '';
      // 先清空并禁用，要求先选择地图
      sel.innerHTML = '';
      const placeholder = document.createElement('option');
      placeholder.value = '';
      placeholder.textContent = (typeof chosen === 'string' && /(^|\/)VehicleMap\/[^\/]+\.scene$/.test(chosen)) ? '站点加载中...' : '请先选择地图';
      sel.appendChild(placeholder);
      sel.disabled = true;

      if (!chosen || !(/(^|\/)VehicleMap\/[^\/]+\.scene$/.test(chosen))) {
        return; // 未选择 VehicleMap scene 地图，不提供初始位置选项
      }

      // 获取并缓存站点
      const fname = String(chosen).split('/').pop();
      window.configSceneStationsCache = window.configSceneStationsCache || {};
      let stations = window.configSceneStationsCache[fname];
      if (!stations) {
        try {
          const resp = await fetch(`/maps/VehicleMap/${encodeURIComponent(fname)}`);
          if (!resp.ok) throw new Error(`站点获取失败: ${resp.status}`);
          const data = await resp.json();
          const allowedPrefixes = ['AP','CP','PP','LM','WP'];
          const allowedClasses = new Set(['ActionPoint','LocationMark','ChargingPoint','ChargePoint','ParkingPoint','ParkPoint','WayPoint','Waypoint']);
          const startsAllowed = (txt) => allowedPrefixes.some(pref => String(txt || '').trim().startsWith(pref));
          const root = Array.isArray(data) ? data[0] : data;
          const points = (root && Array.isArray(root.points)) ? root.points : [];
          stations = points.filter(p => {
            const nm = String(p.name || p.id || '').trim();
            return nm && startsAllowed(nm);
          }).map(p => ({ id: String(p.id || p.name), instanceName: String(p.name || p.id), pointName: String(p.name || p.id), pos: { x: Number(p.x), y: Number(p.y) } }));
          window.configSceneStationsCache[fname] = stations;
        } catch (e) {
          console.error('加载站点失败:', e);
          stations = [];
        }
      }

      sel.innerHTML = '<option value="">选择初始位置</option>';
      stations.forEach(s => {
        const id = String(s.id || s.instanceName || s.pointName);
        const name = String(s.instanceName || s.pointName || id);
        const px = (s && s.pos && typeof s.pos.x !== 'undefined') ? Number(s.pos.x) : Number(s.x);
        const py = (s && s.pos && typeof s.pos.y !== 'undefined') ? Number(s.pos.y) : Number(s.y);
        const opt = document.createElement('option');
        opt.value = id;
        opt.textContent = `${name} (${isFinite(px) ? px.toFixed(2) : 'NaN'}, ${isFinite(py) ? py.toFixed(2) : 'NaN'})`;
        sel.appendChild(opt);
      });
      sel.disabled = false;
    }
    async function updateConfigMapOptions() {
      const sel = document.getElementById('configMapSelect');
      if (!sel) return;
      sel.innerHTML = '<option value="">不变</option>';
      try {
        const resp = await fetch(`${API_BASE_URL}/maps`);
        if (!resp.ok) throw new Error(`HTTP ${resp.status}: ${resp.statusText}`);
        const files = await resp.json();
        (files || []).forEach(name => {
          const opt = document.createElement('option');
          opt.value = name;
          opt.textContent = name;
          sel.appendChild(opt);
        });
        const robot = registeredRobots.find(r => r.robot_name === currentConfigRobotId);
        if (robot && robot.currentMap && robot.currentMap.startsWith('VehicleMap/')) {
          const exists = Array.from(sel.options).some(o => o.value === robot.currentMap);
          if (exists) sel.value = robot.currentMap;
        }
      } catch (err) {
        console.error('加载地图列表失败:', err);
        const opt = document.createElement('option');
        opt.value = CURRENT_MAP_ID;
        opt.textContent = `已加载地图 (${CURRENT_MAP_ID})`;
        sel.appendChild(opt);
        sel.value = CURRENT_MAP_ID;
      }
      const mapLabel = document.getElementById('configMapSelectedLabel');
      if (mapLabel) {
        const robot = registeredRobots.find(r => r.robot_name === currentConfigRobotId);
        mapLabel.textContent = (robot && robot.currentMap) ? robot.currentMap : '未设置';
      }
    }
    async function saveConfig() {
      const id = currentConfigRobotId;
      if (!id) { closeConfigModal(); return; }
      const robot = registeredRobots.find(r => r.robot_name === id);
      if (!robot) { closeConfigModal(); return; }
      const newName = document.getElementById('configRobotName').value.trim();
      const newType = document.getElementById('configRobotType').value;
      const newIP = document.getElementById('configRobotIP').value.trim();
      const newManu = document.getElementById('configRobotManufacturer').value.trim();
      const newVer = document.getElementById('configRobotVersion').value.trim() || 'v2';
      const battery = parseInt(document.getElementById('configBattery').value, 10);
      const orientation = parseFloat(document.getElementById('configOrientation').value);
      const initId = document.getElementById('configInitialPosition').value;
      const mapVal = document.getElementById('configMapSelect').value;
      // 读取物理参数输入值
      const n = (v) => { const x = Number(v); return isFinite(x) ? x : undefined; };
      const phys = {
        speedMin: n(document.getElementById('factsheetSpeedMin').value),
        speedMax: n(document.getElementById('factsheetSpeedMax').value),
        accelerationMax: n(document.getElementById('factsheetAccelMax').value),
        decelerationMax: n(document.getElementById('factsheetDecelMax').value),
        heightMin: n(document.getElementById('factsheetHeightMin').value),
        heightMax: n(document.getElementById('factsheetHeightMax').value),
        width: n(document.getElementById('factsheetWidth').value),
        length: n(document.getElementById('factsheetLength').value)
      };
      // 位置组装
      let pos = robot.currentPosition || robot.initialPosition || { x: 0, y: 0, theta: 0 };
      if (initId) {
        if (mapVal && /(^|\/)VehicleMap\/[^\/]+\.scene$/.test(mapVal)) {
          const fname = String(mapVal).split('/').pop();
          window.configSceneStationsCache = window.configSceneStationsCache || {};
          let stations = window.configSceneStationsCache[fname];
          if (!stations) {
            try {
              const resp = await fetch(`/maps/VehicleMap/${encodeURIComponent(fname)}`);
              if (resp.ok) {
                const data = await resp.json();
                const root = Array.isArray(data) ? data[0] : data;
                const points = (root && Array.isArray(root.points)) ? root.points : [];
                const allowedPrefixes = ['AP','CP','PP','LM','WP'];
                const startsAllowed = (txt) => allowedPrefixes.some(pref => String(txt || '').trim().toUpperCase().startsWith(pref));
                stations = points.filter(p => startsAllowed(String(p.name || p.id || '')))
                  .map(p => ({ id: String(p.id || p.name), instanceName: String(p.name || p.id), pointName: String(p.name || p.id), pos: { x: Number(p.x), y: Number(p.y) } }));
              }
            } catch (e) { /* 忽略一次失败 */ }
          }
          const s = (stations || []).find(x => String(x.id || x.instanceName || x.pointName) === initId);
          if (s) {
            const px = (s && s.pos && typeof s.pos.x !== 'undefined') ? Number(s.pos.x) : Number(s.x);
            const py = (s && s.pos && typeof s.pos.y !== 'undefined') ? Number(s.pos.y) : Number(s.y);
            if (!isFinite(px) || !isFinite(py)) { try { window.printErrorToStatus('站点坐标无效，无法保存配置','配置'); } catch (_) {} return; }
            pos = { x: px, y: py, theta: isNaN(orientation) ? 0 : orientation };
          }
        } else {
          const point = (mapData?.points || []).find(p => p.id === initId);
          if (point) { pos = { x: point.x, y: point.y, theta: isNaN(orientation) ? 0 : orientation }; }
        }
      } else {
        pos = { x: pos.x, y: pos.y, theta: isNaN(orientation) ? (pos.theta || 0) : orientation };
      }
      try {
        // 静态配置更新（仅 IP）
        if (newIP && newIP !== robot.ip) {
          const sResp = await fetch(`${API_BASE_URL}/agv/${id}/config/static`, {
            method: 'PATCH', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ IP: newIP })
          });
          if (!sResp.ok) throw new Error(`静态配置更新失败: HTTP ${sResp.status}`);
          robot.ip = newIP;
        }
        // 使用即时动作 switchMap 进行地图切换与重定位（替代原逻辑）
        if (mapVal && /(^|\/)(VehicleMap|ViewerMap)\/[^\/]+\.scene$/.test(mapVal)) {
          const swBody = { map: mapVal };
          if (initId) swBody.switch_point = initId;
          if (isFinite(pos?.x) && isFinite(pos?.y)) { swBody.center_x = pos.x; swBody.center_y = pos.y; }
          if (!isNaN(orientation)) swBody.initiate_angle = orientation;
          const swResp = await fetch(`${API_BASE_URL}/agv/${id}/instant/switch-map`, {
            method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(swBody)
          });
          if (!swResp.ok) throw new Error(`发布 switchMap 失败: HTTP ${swResp.status}`);
        }
        // 不再通过动态配置更新位置/地图，避免与 switchMap 冲突
        // 若需要仅更新电量，可在此处独立调用动态配置接口（可选）。此处遵循“删除原本的逻辑”，不提交动态配置。
        if (newType) robot.type = newType;
        if (newManu) robot.manufacturer = newManu;
        if (newVer) robot.version = newVer;
        // 应用物理参数到运动控制（速度/加减速）
        try { await applyPhysicalParamsToMotionControl(id, phys); robot.motionParams = phys; } catch (e) { console.warn('应用运动参数失败', e); }
        // 传递碰撞参数接口（占位，后续实现具体逻辑）
        try { await updateCollisionParameters(id, phys); robot.collisionParams = { width: phys.width, length: phys.length, heightMin: phys.heightMin, heightMax: phys.heightMax }; } catch (e) { console.warn('更新碰撞参数失败', e); }
        updateRobotList();
        drawMap();
        document.getElementById('status').textContent = `机器人 ${id} 已发送 switchMap 即时动作`;
        setTimeout(() => document.getElementById('status').textContent = '准备就绪', 2000);
      } catch (err) {
        console.error('更新配置失败:', err);
        try { window.printErrorToStatus('更新配置失败: ' + (err && err.message ? err.message : String(err)),'配置'); } catch (_) {}
      } finally {
        closeConfigModal();
      }
    }
    function switchConfigTab(tab) {
      const btnBasic = document.getElementById('configTabBtnBasic');
      const btnPhysical = document.getElementById('configTabBtnPhysical');
      const vBasic = document.getElementById('configTabBasic');
      const vPhysical = document.getElementById('configTabPhysical');
      const isBasic = tab === 'basic';
      vBasic.style.display = isBasic ? 'block' : 'none';
      vPhysical.style.display = isBasic ? 'none' : 'block';
      btnBasic.style.background = isBasic ? '#34495e' : '#2b3b4b';
      btnPhysical.style.background = isBasic ? '#2b3b4b' : '#34495e';
    }
    async function prefillFactsheetPhysicalParams(robot) {
      const setVal = (id, v) => { const el = document.getElementById(id); if (el && typeof v !== 'undefined' && v !== null) el.value = String(v); };
      const defaults = { speedMin: 0.01, speedMax: 2, accelerationMax: 2, decelerationMax: 2, heightMin: 0.01, heightMax: 0.10, width: 0.745, length: 1.03 };
      let cfg = null;
      // 优先从后端读取当前仿真设置（包含物理参数），避免每次打开都退回默认值
      try {
        const id = (robot && robot.robot_name) || selectedRobotId || (((registeredRobots || [])[0] && (registeredRobots || [])[0].robot_name) || '');
        if (id) {
          const resp = await fetch(`${API_BASE_URL}/agv/${encodeURIComponent(id)}/sim/settings`);
          if (resp && resp.ok) {
            const s = await resp.json();
            cfg = {
              speedMin: Number(s.speed_min ?? defaults.speedMin),
              speedMax: Number(s.speed_max ?? (typeof s.speed === 'number' ? s.speed : defaults.speedMax)),
              accelerationMax: Number(s.acceleration_max ?? defaults.accelerationMax),
              decelerationMax: Number(s.deceleration_max ?? defaults.decelerationMax),
              heightMin: Number(s.height_min ?? defaults.heightMin),
              heightMax: Number(s.height_max ?? defaults.heightMax),
              width: Number(s.width ?? defaults.width),
              length: Number(s.length ?? defaults.length)
            };
          }
        }
      } catch (e) {
        console.warn('读取后端物理参数失败，回退到factsheet.json', e);
      }
      // 其次使用已缓存到机器人实例的参数
      if (!cfg && robot && robot.motionParams) {
        cfg = Object.assign({}, defaults, robot.motionParams);
      }
      // 最后回退到 factsheet.json
      if (!cfg) {
        try {
          let resp = await fetch('/factsheet.json');
          if (!resp || !resp.ok) resp = await fetch('../factsheet.json');
          if (resp && resp.ok) {
            const data = await resp.json();
            const p = (data && data.physicalParameters) ? data.physicalParameters : {};
            cfg = {
              speedMin: Number(p.speedMin ?? defaults.speedMin),
              speedMax: Number(p.speedMax ?? defaults.speedMax),
              accelerationMax: Number(p.accelerationMax ?? defaults.accelerationMax),
              decelerationMax: Number(p.decelerationMax ?? defaults.decelerationMax),
              heightMin: Number(p.heightMin ?? defaults.heightMin),
              heightMax: Number(p.heightMax ?? defaults.heightMax),
              width: Number(p.width ?? defaults.width),
              length: Number(p.length ?? defaults.length)
            };
          }
        } catch (e) { /* 读取失败使用默认值 */ }
      }
      cfg = cfg || defaults;
      setVal('factsheetSpeedMin', cfg.speedMin);
      setVal('factsheetSpeedMax', cfg.speedMax);
      setVal('factsheetAccelMax', cfg.accelerationMax);
      setVal('factsheetDecelMax', cfg.decelerationMax);
      setVal('factsheetHeightMin', cfg.heightMin);
      setVal('factsheetHeightMax', cfg.heightMax);
      setVal('factsheetWidth', cfg.width);
      setVal('factsheetLength', cfg.length);
    }
    async function applyPhysicalParamsToMotionControl(id, params) {
      // 将物理参数同步到仿真设置（速度、速度上下限、加减速）
      const patch = {};
      const n = (v) => { const x = Number(v); return isFinite(x) ? x : undefined; };
      const sMin = n(params.speedMin), sMax = n(params.speedMax), aMax = n(params.accelerationMax), dMax = n(params.decelerationMax);
      // 注意：后端对 speed 的校验为 [0,2]，避免 400 报错，不直接用 speedMax 覆盖运行速度。
      // 若希望同步运行速度，仅在合法范围内设置；否则跳过，让速度由现有值与上下限共同决定。
      if (typeof sMax !== 'undefined') {
        const candidate = Number(sMax);
        if (isFinite(candidate) && candidate >= 0 && candidate <= 2) {
          patch.speed = candidate;
        }
      }
      if (typeof sMin !== 'undefined') patch.speed_min = sMin;
      if (typeof sMax !== 'undefined') patch.speed_max = sMax;
      if (typeof aMax !== 'undefined') patch.acceleration_max = aMax;
      if (typeof dMax !== 'undefined') patch.deceleration_max = dMax;
      // 同步几何与高度约束到后端（用于碰撞与 factsheet）
      const hMin = n(params.heightMin), hMax = n(params.heightMax), w = n(params.width), l = n(params.length);
      if (typeof hMin !== 'undefined') patch.height_min = hMin;
      if (typeof hMax !== 'undefined') patch.height_max = hMax;
      if (typeof w !== 'undefined') patch.width = w;
      if (typeof l !== 'undefined') patch.length = l;
      // 基本有效性校验（避免发送明显无效值）
      const errs = [];
      if (typeof sMin !== 'undefined' && typeof sMax !== 'undefined' && sMin > sMax) errs.push('最小速度不能大于最大速度');
      if (typeof patch.speed !== 'undefined') {
        if (!(patch.speed >= 0 && patch.speed <= 2)) errs.push('运行速度需在[0,2]范围内');
        if (typeof sMin !== 'undefined' && patch.speed < sMin) errs.push('运行速度应不低于最小速度');
      }
      if (errs.length) {
        try { window.printErrorToStatus('参数无效: ' + errs.join('; '), '配置'); } catch (_) {}
        return;
      }
      // 缓存到前端，供可能的本地绘制或校验使用
      window.MOTION_LIMITS = { speedMin: sMin, speedMax: sMax, accelerationMax: aMax, decelerationMax: dMax };
      if (Object.keys(patch).length > 0) {
        const resp = await fetch(`${API_BASE_URL}/agv/${encodeURIComponent(id)}/sim/settings`, {
          method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(patch)
        });
        if (!resp.ok) throw new Error(`HTTP ${resp.status}: ${resp.statusText}`);
      }
    }
    async function updateCollisionParameters(id, params) {
      // 碰撞参数接口占位：将几何与高度约束写入前端缓存，后续用于碰撞检测绘制/后端同步
      try {
        const robot = registeredRobots.find(r => r.robot_name === id);
        if (robot) {
          robot.collisionParams = { width: params.width, length: params.length, heightMin: params.heightMin, heightMax: params.heightMax };
        }
        // 后续：可在此处调用后端 API 提交碰撞几何参数，例如 /agv/:id/sim/collision
      } catch (e) { console.warn('碰撞参数缓存失败', e); }
    }
    // WebSocket 和基础运动辅助函数
    function initWebSocket() {
      try {
        const url = (location.protocol === 'https:' ? 'wss' : 'ws') + '://' + location.host + '/ws';
        ws = new WebSocket(url);
        ws.onopen = () => { document.getElementById('status').textContent = 'WS已连接'; setTimeout(() => document.getElementById('status').textContent = '准备就绪', 2000); };
        ws.onmessage = (ev) => {
          try {
            const msg = JSON.parse(ev.data);
            if (msg && msg.type === 'mqtt_state' && msg.payload) {
              applyWSState(msg.payload);
            } else if (msg && msg.type === 'mqtt_instantActions' && msg.payload) {
              try { handleWSInstantActions(msg.payload); } catch (e) { console.warn('处理即时动作失败', e); }
            } else if (msg && msg.type === 'pallet_action') {
              const serial = String(msg.serial || msg.serial_number || '').trim();
              const op = String(msg.operation || '').trim();
              const recfile = String(msg.recfile || '').trim();
              if (serial && op) handlePalletAction(serial, op, recfile);
            }
          } catch (e) {
            console.error('WS消息解析失败', e);
          }
        };
        ws.onclose = () => {
          document.getElementById('status').textContent = 'WS断开，重连中...';
          try {
            registeredRobots.forEach(r => { r.commConnected = false; r.instanceStatus = '断开'; });
            // 统一渲染循环会刷新画布，这里只更新列表
            updateRobotList();
          } catch (e) { console.warn('WS关闭状态更新失败', e); }
          setTimeout(initWebSocket, 1000);
        };
        ws.onerror = () => { try { ws.close(); } catch (e) {} };
      } catch (err) {
        console.error('WS初始化失败:', err);
      }
    }
    function handleWSInstantActions(payload) {
      try {
        const serial = String((payload && (payload.serial_number || payload.serialNumber)) || '').trim();
        if (!serial) return;
        const robot = registeredRobots.find(r => r.robot_name === serial);
        if (!robot) return;
        const actions = Array.isArray(payload.actions) ? payload.actions : [];
        for (const a of actions) {
          const type = String((a && (a.action_type || a.actionType)) || '').trim();
          const aid = String((a && (a.action_id || a.actionId)) || '').trim();
          if (type.toLowerCase() === 'stoppause' && /^collision_stop_/i.test(aid)) {
            robot._collisionActive = true;
          } else if (type.toLowerCase() === 'startpause' && /^collision_start_/i.test(aid)) {
            robot._collisionActive = false;
          }
        }
      } catch (e) { /* 忽略异常 */ }
    }
    // 电量显示辅助：截断到 1 位小数，限制在 [0,100]
    function truncateToOneDecimal(v) {
      const num = Number(v);
      if (!isFinite(num)) return 0;
      const t = Math.floor(num * 10) / 10;
      return Math.max(0, Math.min(100, t));
    }

    // 解析 WS 推送的 VDA5050 state，更新内存状态但不立即渲染
    function applyWSState(stateMsg) {
      try {
        const payload = stateMsg || {};
        const sn = String(payload.serial_number || payload.serialNumber || '').trim();
        if (!sn) return;
        const robot = registeredRobots.find(r => r.robot_name === sn);
        if (!robot) return;
        const agvPos = payload.agv_position || payload.agvPosition || {};
        const batt = payload.battery_state || payload.batteryState || {};
        const fork = payload.fork_state || payload.forkState || {};
        const mapId = (agvPos && (agvPos.map_id || agvPos.mapId)) || null;
        const px = Number(agvPos && agvPos.x);
        const py = Number(agvPos && agvPos.y);
        const th = Number(agvPos && (agvPos.theta ?? agvPos.orientation));
        const bc = Number(batt && (batt.battery_charge || batt.batteryCharge));
        if (isFinite(bc)) robot.battery = truncateToOneDecimal(bc);
        if (mapId) robot.currentMap = String(mapId);
        if (isFinite(px) && isFinite(py)) {
          robot.currentPosition = { x: px, y: py, theta: isFinite(th) ? th : (robot.currentPosition?.theta || 0) };
        }
        const fh = Number(fork && (fork.fork_height ?? fork.forkHeight));
        if (isFinite(fh)) robot.forkHeight = fh;
        robot.instanceStatus = '启动';
        robot.commConnected = true;
        robot.lastUpdateTs = Date.now();
        // 消费信息字段：托盘动作（JackLoad/JackUnload）
        try {
          const infos = Array.isArray(payload.information) ? payload.information : [];
          for (const info of infos) {
            const t = String(info.info_type || info.infoType || '').trim();
            if (t === 'PalletAction') {
              const refs = Array.isArray(info.info_references || info.infoReferences) ? (info.info_references || info.infoReferences) : [];
              const kv = {};
              for (const r of refs) {
                const k = String(r.reference_key || r.referenceKey || r.key || '').trim();
                const v = String(r.reference_value || r.referenceValue || r.value || '').trim();
                if (k) kv[k] = v;
              }
              const op = String(kv.operation || '').trim();
              const recfile = String(kv.recfile || '').trim();
              if (op) handlePalletAction(sn, op, recfile);
            }
          }
        } catch (e) { /* ignore */ }
        // 列表信息变化较慢，交给独立节流逻辑
      } catch (e) {
        console.warn('应用 WS 状态失败:', e);
      }
    }

    async function fetchShelfModel(recfile) {
      try {
        let path = String(recfile || '').trim();
        if (!path) return null;
        // 规范化分隔符并解析到后端静态路由 /shelf/<name>.shelf
        path = path.replace(/\\/g, '/');
        let url = '';
        if (/^\/shelf\//i.test(path)) {
          url = path;
        } else if (/\/shelf\//i.test(path)) {
          url = path.substring(path.toLowerCase().indexOf('/shelf/'));
        } else if (/\.shelf$/i.test(path)) {
          const name = path.split('/').pop();
          url = '/shelf/' + name;
        } else {
          // 非预期路径，直接归一到 /shelf/<basename>.shelf
          const base = path.split('/').pop();
          url = '/shelf/' + base;
        }
        if (!url.startsWith('/')) url = '/' + url;
        const resp = await fetch(url);
        if (!resp.ok) return null;
        return await resp.json();
      } catch (_) { return null; }
    }

    async function handlePalletAction(serial, operation, recfile) {
      const robot = registeredRobots.find(r => r.robot_name === serial);
      if (!robot) return;
      const key = String(operation || '') + '|' + String(recfile || '');
      if (robot._lastPalletOpKey === key) return; // 简单去重
      robot._lastPalletOpKey = key;
      if (String(operation).toLowerCase() === 'jackload') {
        const model = await fetchShelfModel(recfile);
        robot.shelfModel = model || null;
        loadPallet(serial);
      } else if (String(operation).toLowerCase() === 'jackunload') {
        unloadPallet(serial);
      }
    }

    // 统一 10ms 渲染调度：仅重绘画布，避免频繁 DOM 变更
    let renderTimer = null;
    let lastListUpdate = 0;
    function startRenderLoop() {
      if (renderTimer) return;
      renderTimer = setInterval(() => {
        try { drawMap(); } catch (e) { /* 忽略单帧错误 */ }
        const now = Date.now();
        if (now - lastListUpdate > 250) {
          lastListUpdate = now;
          try { updateRobotList(); } catch (e) { /* 忽略 */ }
        }
      }, 10);
    }

    function applyStatusUpdates(list) {
      (list || []).forEach(st => {
        const robot = registeredRobots.find(r => r.robot_name === st.serial_number);
        if (robot) {
          if (st.battery_level !== undefined && st.battery_level !== null) {
            const bc = Number(st.battery_level);
            if (isFinite(bc)) robot.battery = truncateToOneDecimal(bc);
          }
          robot.currentPosition = st.position || robot.currentPosition;
          robot.currentMap = st.current_map || robot.currentMap;
          robot.instanceStatus = (st.status === 'running') ? '启动' : '停止';
          robot.commConnected = true;
          robot.lastUpdateTs = Date.now();
        }
      });
      // 统一渲染循环会刷新画布和定期刷新列表，这里不立即渲染
    }

    // 状态改为从后端实例状态接口直接读取（电量、地图、位置、方向）
    async function fetchRobotStatus(id) {
      try {
        const resp = await fetch(`${API_BASE_URL}/agv/${encodeURIComponent(id)}/status`);
        if (!resp.ok) return;
        const st = await resp.json();
        const robot = registeredRobots.find(r => r.robot_name === (st.serial_number || id));
        if (!robot) return;
        // 电量
        if (st.battery_level !== undefined && st.battery_level !== null) {
          const bc = Number(st.battery_level);
          if (isFinite(bc)) robot.battery = truncateToOneDecimal(bc);
        }
        // 地图
        if (st.current_map) {
          robot.currentMap = st.current_map;
        }
        // 位置与方向
        if (st.position && typeof st.position.x !== 'undefined' && typeof st.position.y !== 'undefined') {
          const px = Number(st.position.x);
          const py = Number(st.position.y);
          const th = Number(st.position.theta ?? 0);
          if (isFinite(px) && isFinite(py)) {
            robot.currentPosition = { x: px, y: py, theta: isFinite(th) ? th : (robot.currentPosition?.theta || 0) };
          }
        }
        // 实例运行状态与通信标记
        robot.instanceStatus = (st.status === 'running') ? '启动' : '停止';
        robot.commConnected = true;
        robot.lastUpdateTs = Date.now();
      } catch (_) {
        // 单次失败忽略，保持上次状态
      }
    }

    async function pollAllRobotStatus() {
      const ids = registeredRobots.map(r => r.robot_name);
      if (ids.length === 0) return;
      await Promise.all(ids.map(id => fetchRobotStatus(id)));
      updateRobotList();
      drawMap();
    }

    // 移除状态轮询，改由 WS 推送 + 10ms 统一渲染

    async function selectRobot(id) { selectedRobotId = id; updateRobotList(); }

    function setupKeyboardControl() {
      window.addEventListener('keydown', function (e) {
        // 避免输入框等控件下触发
        const tag = document.activeElement && document.activeElement.tagName;
        if (tag && ['INPUT','TEXTAREA','SELECT'].includes(tag)) return;
        if (!selectedRobotId) return;
        const key = e.key.toLowerCase();
        if (key === 'w') { moveForward(selectedRobotId); }
        else if (key === 's') { moveBackward(selectedRobotId); }
        else if (key === 'a') { rotateLeft(selectedRobotId); }
        else if (key === 'd') { rotateRight(selectedRobotId); }
      });
    }

    async function moveBackward(id) {
      const step = 0.1;
      const robot = registeredRobots.find(r => r.robot_name === id);
      const pos = robot?.currentPosition || robot?.initialPosition || { x: 0, y: 0, theta: 0 };
      const heading = (pos.theta ?? pos.orientation ?? 0);
      const dx = -step * Math.sin(heading);
      const dy = step * Math.cos(heading);
      try {
        const resp = await fetch(`${API_BASE_URL}/agv/${id}/move/translate`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ dx, dy, movement_state: 'backward' }) });
        if (!resp.ok) throw new Error(`HTTP ${resp.status}: ${resp.statusText}`);
      } catch (err) { console.error('后退失败:', err); }
    }

    async function moveForward(id) {
      const step = 0.1;
      const robot = registeredRobots.find(r => r.robot_name === id);
      const pos = robot?.currentPosition || robot?.initialPosition || { x: 0, y: 0, theta: 0 };
      const heading = (pos.theta ?? pos.orientation ?? 0);
      const dx = step * Math.sin(heading);
      const dy = -step * Math.cos(heading);
      try {
        const resp = await fetch(`${API_BASE_URL}/agv/${id}/move/translate`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ dx, dy, movement_state: 'forward' }) });
        if (!resp.ok) throw new Error(`HTTP ${resp.status}: ${resp.statusText}`);
      } catch (err) { console.error('前进失败:', err); }
    }

    async function rotateLeft(id) { const dtheta = -0.15; try { const resp = await fetch(`${API_BASE_URL}/agv/${id}/move/rotate`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ dtheta }) }); if (!resp.ok) throw new Error(`HTTP ${resp.status}: ${resp.statusText}`); } catch (err) { console.error('左转失败:', err); } }
    async function rotateRight(id) { const dtheta = 0.15; try { const resp = await fetch(`${API_BASE_URL}/agv/${id}/move/rotate`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ dtheta }) }); if (!resp.ok) throw new Error(`HTTP ${resp.status}: ${resp.statusText}`); } catch (err) { console.error('右转失败:', err); } }

    let commGuardTimer = null;
    function startCommStatusGuard() {
      if (commGuardTimer) return;
      commGuardTimer = setInterval(() => {
        const now = Date.now();
        let changed = false;
        registeredRobots.forEach(r => {
          if (!r.lastUpdateTs || (now - r.lastUpdateTs > 5000)) {
            if (r.commConnected || r.instanceStatus === '启动') {
              r.commConnected = false;
              r.instanceStatus = '断开';
              changed = true;
            }
          }
        });
        if (changed) {
          updateRobotList();
          drawMap();
        }
      }, 1000);
    }
  </script>
  <!-- 仿真设置弹窗 -->
  <div id="settingsModal" class="modal" style="display:none; position:fixed; inset:0; background:rgba(0,0,0,0.5); align-items:center; justify-content:center; z-index:2100;">
    <div class="modal-content" style="width:460px; background:#2c3e50; color:#ecf0f1; border-radius:8px; box-shadow:0 10px 25px rgba(0,0,0,.3);">
      <div class="modal-header" style="padding:12px 16px; border-bottom:1px solid #34495e; display:flex; align-items:center; justify-content:space-between;">
        <div class="modal-title" style="font-weight:bold;">仿真设置（热加载）</div>
        <button class="modal-close" onclick="closeSettingsModal()" style="background:transparent; border:none; color:#ecf0f1; font-size:20px; cursor:pointer;">&times;</button>
      </div>
      <div class="modal-body" style="padding:16px;">
        <div class="form-group"><label class="form-label">速度 (m/s)</label><input type="number" class="form-input" id="settingsSpeed" placeholder="如: 2.0" step="0.01"></div>
        <div class="form-group"><label class="form-label">时间缩放</label><input type="number" class="form-input" id="settingsTimeScale" placeholder="如: 1.0" step="0.01"></div>
        <div class="form-group"><label class="form-label">状态频率 (Hz)</label><input type="number" class="form-input" id="settingsStateFreq" placeholder="如: 10" step="1"></div>
        <div class="form-group"><label class="form-label">可视化频率 (Hz)</label><input type="number" class="form-input" id="settingsVisFreq" placeholder="如: 1" step="1"></div>
        <div class="form-group"><label class="form-label">动作时长 (s)</label><input type="number" class="form-input" id="settingsActionTime" placeholder="如: 1.0" step="0.1"></div>
        <div class="form-group"><label class="form-label">前端轮询间隔 (ms)</label><input type="number" class="form-input" id="settingsFrontendPoll" placeholder="如: 1000" step="10"></div>
        <details style="margin-top:8px;">
          <summary style="cursor:pointer;">电池参数（可选）</summary>
          <div class="form-group" style="margin-top:8px;"><label class="form-label">默认电量 (%)</label><input type="number" class="form-input" id="settingsBatteryDefault" placeholder="如: 100" step="0.1"></div>
          <div class="form-group"><label class="form-label">空闲耗电 (百分点/分钟)</label><input type="number" class="form-input" id="settingsBatteryIdle" placeholder="如: 1.0" step="0.1"></div>
          <div class="form-group"><label class="form-label">空载耗电系数</label><input type="number" class="form-input" id="settingsBatteryEmptyMult" placeholder="如: 1.5" step="0.1"></div>
          <div class="form-group"><label class="form-label">载货耗电系数</label><input type="number" class="form-input" id="settingsBatteryLoadedMult" placeholder="如: 2.5" step="0.1"></div>
          <div class="form-group"><label class="form-label">充电速度 (百分点/分钟)</label><input type="number" class="form-input" id="settingsBatteryCharge" placeholder="如: 10.0" step="0.1"></div>
        </details>
        <div style="margin-top:12px; display:flex; gap:8px; justify-content:flex-end;">
          <button class="btn-saveconfig" onclick="saveSimSettings()">保存</button>
          <button class="btn-cancel-small" onclick="closeSettingsModal()">取消</button>
        </div>
      </div>
    </div>
  </div>
  <script>
    async function openSettingsModal() {
      const modal = document.getElementById('settingsModal');
      modal.style.display = 'flex';
      // 在首次打开后锁定弹窗高度为当前计算值（保持初始大小）
      requestAnimationFrame(() => {
        const content = modal.querySelector('.modal-content');
        if (content && !content.dataset.fixedHeight) {
          const rect = content.getBoundingClientRect();
          content.style.height = rect.height + 'px';
          content.style.maxHeight = rect.height + 'px';
          content.dataset.fixedHeight = '1';
        }
      });
      // 预填当前仿真设置
      // 仿真设置全局生效：统一从全局接口读取
      try {
        const resp = await fetch(`${API_BASE_URL}/sim/settings`);
        if (resp && resp.ok) {
          const data = await resp.json();
          prefillSimSettings(data);
        }
      } catch (e) {
        try { window.printErrorToStatus('读取当前仿真设置失败: ' + (e && e.message ? e.message : String(e)), '设置'); } catch (_) {}
      }
    }
    function closeSettingsModal() { document.getElementById('settingsModal').style.display = 'none'; }
    function prefillSimSettings(s) {
      const setVal = (id, v) => { const el = document.getElementById(id); if (el && typeof v !== 'undefined' && v !== null) el.value = String(v); };
      setVal('settingsSpeed', s.speed);
      setVal('settingsTimeScale', s.sim_time_scale);
      setVal('settingsStateFreq', s.state_frequency);
      setVal('settingsVisFreq', s.visualization_frequency);
      setVal('settingsActionTime', s.action_time);
      setVal('settingsFrontendPoll', s.frontend_poll_interval_ms);
      setVal('settingsBatteryDefault', s.battery_default);
      setVal('settingsBatteryIdle', s.battery_idle_drain_per_min);
      setVal('settingsBatteryEmptyMult', s.battery_move_empty_multiplier);
      setVal('settingsBatteryLoadedMult', s.battery_move_loaded_multiplier);
      setVal('settingsBatteryCharge', s.battery_charge_per_min);
    }
    async function saveSimSettings() {
      try {
        const patch = {};
        const n = (v) => { const x = Number(v); return isFinite(x) ? x : undefined; };
        const s = (v) => { const x = String(v||'').trim(); return x ? x : undefined; };
        const speed = n(document.getElementById('settingsSpeed').value);
        const ts = n(document.getElementById('settingsTimeScale').value);
        const sf = n(document.getElementById('settingsStateFreq').value);
        const vf = n(document.getElementById('settingsVisFreq').value);
        const at = n(document.getElementById('settingsActionTime').value);
        const fp = n(document.getElementById('settingsFrontendPoll').value);
        const bd = n(document.getElementById('settingsBatteryDefault').value);
        const bi = n(document.getElementById('settingsBatteryIdle').value);
        const be = n(document.getElementById('settingsBatteryEmptyMult').value);
        const bl = n(document.getElementById('settingsBatteryLoadedMult').value);
        const bc = n(document.getElementById('settingsBatteryCharge').value);
        // 参数校验
        const errs = [];
        const intIn = (x, a, b) => Number.isInteger(x) && x >= a && x <= b;
        const numIn = (x, a, b, openLeft=false, openRight=false) => {
          if (typeof x !== 'number' || !isFinite(x)) return false;
          const leftOk = openLeft ? (x > a) : (x >= a);
          const rightOk = openRight ? (x < b) : (x <= b);
          return leftOk && rightOk;
        };
        if (typeof speed !== 'undefined') {
          if (!numIn(speed, 0, 2)) errs.push('速度需在[0,2]内'); else patch.speed = speed;
        }
        if (typeof ts !== 'undefined') {
          if (!numIn(ts, 0, 10)) errs.push('时间缩放需在(0,10)内'); else patch.sim_time_scale = ts;
        }
        if (typeof sf !== 'undefined') {
          if (!intIn(sf, 1, 10)) errs.push('状态频率需为[1,10]的正整数'); else patch.state_frequency = parseInt(sf, 10);
        }
        if (typeof vf !== 'undefined') {
          if (!intIn(vf, 1, 10)) errs.push('可视化频率需为[1,10]的正整数'); else patch.visualization_frequency = parseInt(vf, 10);
        }
        if (typeof at !== 'undefined') {
          if (!numIn(at, 1, 10)) errs.push('动作时长需在[1,10]内'); else patch.action_time = at;
        }
        if (typeof fp !== 'undefined') {
          if (!intIn(fp, 10, 1000)) errs.push('前端轮询间隔需为[10,1000]的正整数'); else patch.frontend_poll_interval_ms = parseInt(fp, 10);
        }
        if (typeof bd !== 'undefined') {
          if (!numIn(bd, 0, 100, true, false)) errs.push('默认电量需在(0,100]内'); else patch.battery_default = bd;
        }
        if (typeof bi !== 'undefined') {
          if (!numIn(bi, 1, 100)) errs.push('空闲耗电需在[1,100]内'); else patch.battery_idle_drain_per_min = bi;
        }
        if (typeof be !== 'undefined') {
          if (!numIn(be, 1, 100)) errs.push('空载耗电系数需在[1,100]内'); else patch.battery_move_empty_multiplier = be;
        }
        if (typeof bl !== 'undefined') {
          if (!numIn(bl, 1, 100)) errs.push('载重耗电系数需在[1,100]内'); else patch.battery_move_loaded_multiplier = bl;
        }
        if (typeof bc !== 'undefined') {
          if (!numIn(bc, 1, 100)) errs.push('充电速度需在[1,100]内'); else patch.battery_charge_per_min = bc;
        }
        if (errs.length) {
          try { window.printErrorToStatus('参数无效: ' + errs.join('; '), '设置'); } catch (_) {}
          return; // 不提交，保持弹窗打开
        }
        const resp = await fetch(`${API_BASE_URL}/sim/settings`, {
          method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(patch)
        });
        if (!resp.ok) throw new Error(`HTTP ${resp.status}: ${resp.statusText}`);
        // 同步前端轮询间隔（若更新）
        if (patch.frontend_poll_interval_ms) {
          window.FRONTEND_POLL_INTERVAL_MS = patch.frontend_poll_interval_ms;
        }
        document.getElementById('status').textContent = '仿真设置已更新';
        setTimeout(() => document.getElementById('status').textContent = '准备就绪', 2000);
      } catch (err) {
        console.error('更新仿真设置失败:', err);
        try { window.printErrorToStatus('更新仿真设置失败: ' + (err && err.message ? err.message : String(err)),'设置'); } catch (_) {}
        return;
      }
      // 成功后关闭弹窗
      closeSettingsModal();
    }
  </script>
  <!-- 配置弹窗（参考 SimulatorViewer 设计，简化样式） -->
  <div id="configModal" class="modal" style="display:none; position:fixed; inset:0; background:rgba(0,0,0,0.5); align-items:center; justify-content:center; z-index:2000;">
    <div class="modal-content" style="width:520px; background:#2c3e50; color:#ecf0f1; border-radius:8px; box-shadow:0 10px 25px rgba(0,0,0,.3);">
      <div class="modal-header" style="padding:12px 16px; border-bottom:1px solid #34495e; display:flex; align-items:center; justify-content:space-between;">
        <div class="modal-title" style="font-weight:bold;">机器人高级配置</div>
        <button class="modal-close" onclick="closeConfigModal()" style="background:transparent; border:none; color:#ecf0f1; font-size:20px; cursor:pointer;">&times;</button>
      </div>
      <div style="padding:16px;">
        <div style="display:flex; gap:8px; margin-bottom:12px;">
          <button id="configTabBtnBasic" onclick="switchConfigTab('basic')" style="flex:1; padding:8px; border:none; border-radius:4px; background:#34495e; color:#ecf0f1; cursor:pointer;">基本</button>
          <button id="configTabBtnPhysical" onclick="switchConfigTab('physical')" style="flex:1; padding:8px; border:none; border-radius:4px; background:#2b3b4b; color:#ecf0f1; cursor:pointer;">物理参数</button>
        </div>
        <div id="configTabBasic" style="display:block;">
          <div class="form-group"><label class="form-label">机器人名称</label><input type="text" class="form-input" id="configRobotName" placeholder=""></div>
          <div class="form-group"><label class="form-label">机器人类型</label><select class="form-select" id="configRobotType"><option value="AGV">AGV</option><option value="Fork">Fork</option><option value="Load">Load</option></select></div>
          <div class="form-group"><label class="form-label">机器人IP地址</label><input type="text" class="form-input" id="configRobotIP" placeholder=""></div>
          <div class="form-group"><label class="form-label">厂商</label><input type="text" class="form-input" id="configRobotManufacturer" placeholder="厂商名称"></div>
          <div class="form-group"><label class="form-label">版本</label><input type="text" class="form-input" id="configRobotVersion" placeholder="版本号" value="v2"></div>
          <div class="form-group"><label class="form-label">已加载地图</label><select class="form-select" id="configMapSelect" style="width:100%"><option value="">不变</option><option value="testmap">已加载地图 (testmap)</option></select><div id="configMapSelectedText" class="form-hint" style="font-size:12px;color:#bdc3c7;word-break:break-all;margin-top:4px;">当前: <span id="configMapSelectedLabel"></span></div></div>
          <div class="form-group"><label class="form-label">初始位置</label><select class="form-select" id="configInitialPosition"><option value="">选择初始位置</option></select></div>
          <div class="form-group"><label class="form-label">电量 (%)</label><input type="number" class="form-input" id="configBattery" value="100" min="0" max="100"></div>
          <div class="form-group"><label class="form-label">朝向 (弧度)</label><input type="number" class="form-input" id="configOrientation" value="0" step="0.01" min="-3.14" max="3.14"></div>
        </div>
        <div id="configTabPhysical" style="display:none;">
          <div class="form-group"><label class="form-label">最小速度 (m/s)</label><input type="number" class="form-input" id="factsheetSpeedMin" step="0.01" placeholder="默认 0.01"></div>
          <div class="form-group"><label class="form-label">最大速度 (m/s)</label><input type="number" class="form-input" id="factsheetSpeedMax" step="0.01" placeholder="默认 2"></div>
          <div class="form-group"><label class="form-label">最大加速度 (m/s²)</label><input type="number" class="form-input" id="factsheetAccelMax" step="0.01" placeholder="默认 2"></div>
          <div class="form-group"><label class="form-label">最大减速度 (m/s²)</label><input type="number" class="form-input" id="factsheetDecelMax" step="0.01" placeholder="默认 2"></div>
          <div class="form-group"><label class="form-label">最小高度 (m)</label><input type="number" class="form-input" id="factsheetHeightMin" step="0.01" placeholder="默认 0.01"></div>
          <div class="form-group"><label class="form-label">最大高度 (m)</label><input type="number" class="form-input" id="factsheetHeightMax" step="0.01" placeholder="默认 0.10"></div>
          <div class="form-group"><label class="form-label">宽度 (m)</label><input type="number" class="form-input" id="factsheetWidth" step="0.001" placeholder="默认 0.745"></div>
          <div class="form-group"><label class="form-label">长度 (m)</label><input type="number" class="form-input" id="factsheetLength" step="0.001" placeholder="默认 1.03"></div>
          <div class="form-hint" style="font-size:12px;color:#bdc3c7;word-break:break-all;margin-top:6px;">注：速度/加减速会影响运动控制；宽度/长度/高度参数留作碰撞管理接口。</div>
        </div>
        <div style="margin-top:12px; display:flex; gap:8px; justify-content:flex-end;">
          <button class="btn-saveconfig" onclick="saveConfig()">保存配置</button>
          <button class="btn-cancel-small" onclick="closeConfigModal()">取消</button>
        </div>
      </div>
    </div>
  </div>
 <script>
   document.addEventListener('contextmenu', function (e) {
     e.preventDefault();
   }, { capture: true });
 </script>
 </body>

</html>
